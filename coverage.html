
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cyberark/ark-sdk-golang/cmd/ark.go (0.0%)</option>
				
				<option value="file1">github.com/cyberark/ark-sdk-golang/internal/common/basic_keyring.go (79.2%)</option>
				
				<option value="file2">github.com/cyberark/ark-sdk-golang/internal/common/header_transport.go (100.0%)</option>
				
				<option value="file3">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_action.go (81.2%)</option>
				
				<option value="file4">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_cache_action.go (82.4%)</option>
				
				<option value="file5">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_configure_action.go (19.8%)</option>
				
				<option value="file6">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_exec_action.go (71.4%)</option>
				
				<option value="file7">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_login_action.go (52.5%)</option>
				
				<option value="file8">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_profiles_action.go (58.2%)</option>
				
				<option value="file9">github.com/cyberark/ark-sdk-golang/pkg/actions/ark_service_exec_action.go (43.8%)</option>
				
				<option value="file10">github.com/cyberark/ark-sdk-golang/pkg/ark_api.go (5.1%)</option>
				
				<option value="file11">github.com/cyberark/ark-sdk-golang/pkg/auth/ark_auth.go (0.0%)</option>
				
				<option value="file12">github.com/cyberark/ark-sdk-golang/pkg/auth/ark_auth_types.go (0.0%)</option>
				
				<option value="file13">github.com/cyberark/ark-sdk-golang/pkg/auth/ark_isp_auth.go (0.0%)</option>
				
				<option value="file14">github.com/cyberark/ark-sdk-golang/pkg/auth/identity/ark_identity.go (0.0%)</option>
				
				<option value="file15">github.com/cyberark/ark-sdk-golang/pkg/auth/identity/ark_identity_fqdn_resolver.go (0.0%)</option>
				
				<option value="file16">github.com/cyberark/ark-sdk-golang/pkg/auth/identity/ark_identity_service_user.go (0.0%)</option>
				
				<option value="file17">github.com/cyberark/ark-sdk-golang/pkg/cli/ark_cli_api.go (0.0%)</option>
				
				<option value="file18">github.com/cyberark/ark-sdk-golang/pkg/common/args/ark_args_formatter.go (0.0%)</option>
				
				<option value="file19">github.com/cyberark/ark-sdk-golang/pkg/common/ark_client.go (0.0%)</option>
				
				<option value="file20">github.com/cyberark/ark-sdk-golang/pkg/common/ark_error_utils.go (100.0%)</option>
				
				<option value="file21">github.com/cyberark/ark-sdk-golang/pkg/common/ark_folder_utils.go (88.9%)</option>
				
				<option value="file22">github.com/cyberark/ark-sdk-golang/pkg/common/ark_keyring.go (69.7%)</option>
				
				<option value="file23">github.com/cyberark/ark-sdk-golang/pkg/common/ark_logger.go (88.7%)</option>
				
				<option value="file24">github.com/cyberark/ark-sdk-golang/pkg/common/ark_random_utils.go (100.0%)</option>
				
				<option value="file25">github.com/cyberark/ark-sdk-golang/pkg/common/ark_retry.go (100.0%)</option>
				
				<option value="file26">github.com/cyberark/ark-sdk-golang/pkg/common/ark_serializer.go (79.4%)</option>
				
				<option value="file27">github.com/cyberark/ark-sdk-golang/pkg/common/ark_system_config.go (100.0%)</option>
				
				<option value="file28">github.com/cyberark/ark-sdk-golang/pkg/common/ark_user_agent.go (100.0%)</option>
				
				<option value="file29">github.com/cyberark/ark-sdk-golang/pkg/common/ark_version.go (100.0%)</option>
				
				<option value="file30">github.com/cyberark/ark-sdk-golang/pkg/common/connections/ssh/ark_ssh_connection.go (50.6%)</option>
				
				<option value="file31">github.com/cyberark/ark-sdk-golang/pkg/common/connections/winrm/ark_winrm_connection.go (25.6%)</option>
				
				<option value="file32">github.com/cyberark/ark-sdk-golang/pkg/common/isp/ark_isp_service_client.go (74.8%)</option>
				
				<option value="file33">github.com/cyberark/ark-sdk-golang/pkg/models/ark_profile.go (90.9%)</option>
				
				<option value="file34">github.com/cyberark/ark-sdk-golang/pkg/models/auth/ark_auth_profile.go (0.0%)</option>
				
				<option value="file35">github.com/cyberark/ark-sdk-golang/pkg/models/common/ark_env.go (100.0%)</option>
				
				<option value="file36">github.com/cyberark/ark-sdk-golang/pkg/models/common/ark_rfc3339_time.go (100.0%)</option>
				
				<option value="file37">github.com/cyberark/ark-sdk-golang/pkg/models/common/identity/ark_identity_directory_schemas.go (100.0%)</option>
				
				<option value="file38">github.com/cyberark/ark-sdk-golang/pkg/models/common/identity/ark_identity_schemas.go (100.0%)</option>
				
				<option value="file39">github.com/cyberark/ark-sdk-golang/pkg/profiles/ark_profile_loader.go (89.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the entry point for the Ark CLI application.
//
// The Ark CLI is a command-line interface that provides access to various
// Ark services and functionality including profile management, authentication,
// configuration, caching, and service execution.
//
// The application uses the Cobra library for command-line interface management
// and supports multiple subcommands for different operations. Build information
// including version, build number, build date, and git commit are embedded
// at compile time through build variables.
//
// Example usage:
//
//        ark --version
//        ark profiles list
//        ark login
//        ark configure
package main

import (
        "fmt"
        "os"

        "github.com/cyberark/ark-sdk-golang/pkg/actions"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/spf13/cobra"
)

var (
        // GitCommit is the commit hash of the Ark CLI application.
        GitCommit = "N/A"

        // BuildDate is the build date of the Ark CLI application.
        BuildDate = "N/A"
        // Version is the version of the Ark CLI application.
        Version = "N/A"

        // BuildNumber is the build number of the Ark CLI application.
        BuildNumber = "N/A"
)

// main is the entry point for the Ark CLI application.
//
// This function initializes the Cobra root command with version information,
// sets up the application version in the common package, creates a profiles
// loader, and registers all available actions (profiles, cache, configure,
// login, and service execution) with the root command.
//
// The function handles command execution and exits with code 1 if an error
// occurs during command execution. The version template is customized to
// display build information in a specific format.
//
// Build variables (GitCommit, BuildDate, Version, BuildNumber) are expected
// to be set at compile time using ldflags but will default to "N/A" if not
// provided.
//
// Available commands after initialization:
//   - profiles: Manage user profiles
//   - cache: Manage application cache
//   - configure: Configure the CLI
//   - login: Authenticate with services
//   - exec: Execute service actions
//
// The function will call os.Exit(1) if command execution fails.
func main() <span class="cov0" title="0">{
        var rootCmd = &amp;cobra.Command{
                Use:     "ark",
                Version: fmt.Sprintf("Version: %s\nBuild Number: %s\nBuild Date: %s\nGit Commit: %s", Version, BuildNumber, BuildDate, GitCommit),
                Short:   "Ark CLI",
        }
        rootCmd.SetVersionTemplate("{{.Version}}\n")
        common.SetArkVersion(Version)
        profilesLoader := profiles.DefaultProfilesLoader()
        arkActions := []actions.ArkAction{
                actions.NewArkProfilesAction(profilesLoader),
                actions.NewArkCacheAction(),
                actions.NewArkConfigureAction(profilesLoader),
                actions.NewArkLoginAction(profilesLoader),
                actions.NewArkServiceExecAction(profilesLoader),
        }

        for _, action := range arkActions </span><span class="cov0" title="0">{
                action.DefineAction(rootCmd)
        }</span>
        <span class="cov0" title="0">if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package common provides internal shared utilities for the ARK SDK.
//
// This package contains internal implementations including a basic keyring
// system for secure password storage using AES encryption. The BasicKeyring
// provides file-based storage with MAC (Message Authentication Code) validation
// to ensure data integrity.
package common

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "os"
        "path/filepath"
)

const (
        // nonceSize defines the size in bytes for AES-GCM nonce generation.
        nonceSize = 16
        // tagSize defines the size in bytes for AES-GCM authentication tag.
        tagSize = 16
        // blockSize defines the block size in bytes for PKCS7 padding operations.
        blockSize = 32
)

// Keyring configuration constants
const (
        // DefaultBasicKeyringFolder is the default folder path relative to HOME directory
        // where the basic keyring files are stored.
        DefaultBasicKeyringFolder = ".ark_cache/keyring"

        // ArkBasicKeyringFolderEnvVar is the environment variable name that can be used
        // to override the default keyring folder location.
        ArkBasicKeyringFolderEnvVar = "ARK_KEYRING_FOLDER"
)

// BasicKeyring is a simple keyring implementation that uses AES encryption to store passwords.
//
// BasicKeyring provides secure password storage using AES-GCM encryption with the hostname
// as the encryption key. Passwords are stored in a JSON file with MAC (Message Authentication
// Code) validation to ensure data integrity. The keyring supports multiple services and
// usernames within each service.
//
// The encryption key is derived from the system hostname and padded using PKCS7 padding
// to ensure consistent key length. Each password entry is encrypted separately with its
// own nonce for security.
//
// File Structure:
//   - keyring: JSON file containing encrypted password data
//   - mac: File containing SHA256 hash of keyring file for integrity validation
type BasicKeyring struct {
        // basicFolderPath is the absolute path to the keyring folder
        basicFolderPath string
        // keyringFilePath is the absolute path to the keyring data file
        keyringFilePath string
        // macFilePath is the absolute path to the MAC validation file
        macFilePath string
}

// NewBasicKeyring creates a new BasicKeyring instance with initialized folder and file paths.
//
// NewBasicKeyring initializes the keyring folder structure and returns a new BasicKeyring
// instance. The folder location is determined by the ArkBasicKeyringFolderEnvVar environment
// variable, or defaults to DefaultBasicKeyringFolder within the user's HOME directory.
//
// The function automatically creates the keyring folder if it doesn't exist. If folder
// creation fails, the function returns nil.
//
// Returns a new BasicKeyring instance or nil if folder creation fails.
//
// Environment Variables:
//   - ARK_KEYRING_FOLDER: Override default keyring folder location
//   - HOME: Used for default keyring folder path construction
//
// Example:
//
//        keyring := NewBasicKeyring()
//        if keyring == nil {
//            // Handle keyring initialization failure
//        }
func NewBasicKeyring() *BasicKeyring <span class="cov8" title="23">{
        basicFolderPath := filepath.Join(os.Getenv("HOME"), DefaultBasicKeyringFolder)
        if folder := os.Getenv(ArkBasicKeyringFolderEnvVar); folder != "" </span><span class="cov8" title="22">{
                basicFolderPath = folder
        }</span>
        <span class="cov8" title="23">if _, err := os.Stat(basicFolderPath); os.IsNotExist(err) </span><span class="cov3" title="3">{
                err := os.MkdirAll(basicFolderPath, os.ModePerm)
                if err != nil </span><span class="cov1" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="22">return &amp;BasicKeyring{
                basicFolderPath: basicFolderPath,
                keyringFilePath: filepath.Join(basicFolderPath, "keyring"),
                macFilePath:     filepath.Join(basicFolderPath, "mac"),
        }</span>
}

func (b *BasicKeyring) encrypt(secret []byte, data string) (map[string]string, error) <span class="cov8" title="25">{
        block, err := aes.NewCipher(secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="25">aesGCM, err := cipher.NewGCMWithNonceSize(block, nonceSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="25">nonce := make([]byte, aesGCM.NonceSize())
        ciphertextWithTag := aesGCM.Seal(nil, nonce, []byte(data), nil)
        tag := ciphertextWithTag[len(ciphertextWithTag)-tagSize:]
        ciphertext := ciphertextWithTag[:len(ciphertextWithTag)-tagSize]
        return map[string]string{
                "nonce":      base64.StdEncoding.EncodeToString(nonce),
                "ciphertext": base64.StdEncoding.EncodeToString(ciphertext),
                "tag":        base64.StdEncoding.EncodeToString(tag),
        }, nil</span>
}

func (b *BasicKeyring) decrypt(secret []byte, data map[string]string) (string, error) <span class="cov7" title="16">{
        block, err := aes.NewCipher(secret)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="16">aesGCM, err := cipher.NewGCMWithNonceSize(block, nonceSize)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="16">nonce, err := base64.StdEncoding.DecodeString(data["nonce"])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="16">ciphertext, err := base64.StdEncoding.DecodeString(data["ciphertext"])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="16">tag, err := base64.StdEncoding.DecodeString(data["tag"])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="16">fullCiphertext := append(ciphertext, tag...)
        plaintext, err := aesGCM.Open(nil, nonce, fullCiphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="16">return string(plaintext), nil</span>
}

func (b *BasicKeyring) getCurrentMac() (string, error) <span class="cov9" title="34">{
        if _, err := os.Stat(b.macFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", errors.New("invalid keyring")
        }</span>
        <span class="cov9" title="34">data, err := os.ReadFile(b.macFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="34">return string(data), nil</span>
}

func (b *BasicKeyring) validateMacAndGetData() (string, error) <span class="cov9" title="34">{
        mac, err := b.getCurrentMac()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="34">data, err := os.ReadFile(b.keyringFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="34">dataMac := sha256.Sum256(data)
        if mac == hex.EncodeToString(dataMac[:]) </span><span class="cov9" title="34">{
                return string(data), nil
        }</span>
        <span class="cov0" title="0">return "", errors.New("invalid keyring")</span>
}

func (b *BasicKeyring) updateMac() error <span class="cov8" title="28">{
        data, err := os.ReadFile(b.keyringFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="28">dataMac := sha256.Sum256(data)
        return os.WriteFile(b.macFilePath, []byte(hex.EncodeToString(dataMac[:])), 0644)</span>
}

func (b *BasicKeyring) pKCS7Pad(data []byte, blockSize int) []byte <span class="cov10" title="47">{
        padding := blockSize - len(data)%blockSize
        padText := bytes.Repeat([]byte{byte(padding)}, padding)
        return append(data, padText...)
}</span>

// SetPassword sets a password for a given service and username in the keyring.
//
// SetPassword encrypts and stores a password for the specified service and username
// combination. The password is encrypted using AES-GCM with a key derived from the
// system hostname. If a keyring file already exists, it loads the existing data and
// adds the new entry. The function updates the MAC file after successful storage
// to maintain data integrity validation.
//
// Parameters:
//   - serviceName: The name of the service (e.g., "github", "aws")
//   - username: The username for the service
//   - password: The password to encrypt and store
//
// Returns an error if encryption, file operations, or MAC update fails.
//
// Example:
//
//        err := keyring.SetPassword("github", "myuser", "mypassword")
//        if err != nil {
//            // Handle password storage error
//        }
func (b *BasicKeyring) SetPassword(serviceName, username, password string) error <span class="cov8" title="25">{
        key := make([]byte, blockSize)
        hostname, _ := os.Hostname()
        copy(key, b.pKCS7Pad([]byte(hostname), blockSize))
        existingKeyring := make(map[string]map[string]map[string]string)
        if _, err := os.Stat(b.keyringFilePath); err == nil </span><span class="cov5" title="8">{
                data, err := b.validateMacAndGetData()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov5" title="8">if err := json.Unmarshal([]byte(data), &amp;existingKeyring); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="25">if _, ok := existingKeyring[serviceName]; !ok </span><span class="cov8" title="21">{
                existingKeyring[serviceName] = make(map[string]map[string]string)
        }</span>
        <span class="cov8" title="25">encryptedPassword, err := b.encrypt(key, password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="25">existingKeyring[serviceName][username] = encryptedPassword
        data, err := json.Marshal(existingKeyring)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="25">if err := os.WriteFile(b.keyringFilePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="25">return b.updateMac()</span>
}

// GetPassword retrieves a password for a given service and username from the keyring.
//
// GetPassword decrypts and returns the stored password for the specified service
// and username combination. The function validates the keyring MAC before accessing
// the data to ensure integrity. If the keyring file doesn't exist, the service
// doesn't exist, or the username doesn't exist, an empty string is returned without error.
//
// Parameters:
//   - serviceName: The name of the service to retrieve password for
//   - username: The username to retrieve password for
//
// Returns the decrypted password string and any error encountered during retrieval.
// Returns empty string with nil error if the entry doesn't exist.
//
// Example:
//
//        password, err := keyring.GetPassword("github", "myuser")
//        if err != nil {
//            // Handle retrieval error
//        }
//        if password == "" {
//            // Password not found
//        }
func (b *BasicKeyring) GetPassword(serviceName, username string) (string, error) <span class="cov8" title="22">{
        key := make([]byte, blockSize)
        hostname, _ := os.Hostname()
        copy(key, b.pKCS7Pad([]byte(hostname), blockSize))
        if _, err := os.Stat(b.keyringFilePath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="21">data, err := b.validateMacAndGetData()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="21">existingKeyring := make(map[string]map[string]map[string]string)
        if err := json.Unmarshal([]byte(data), &amp;existingKeyring); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="21">if _, ok := existingKeyring[serviceName]; !ok </span><span class="cov1" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="20">if _, ok := existingKeyring[serviceName][username]; !ok </span><span class="cov4" title="4">{
                return "", nil
        }</span>
        <span class="cov7" title="16">return b.decrypt(key, existingKeyring[serviceName][username])</span>
}

// DeletePassword deletes a password for a given service and username from the keyring.
//
// DeletePassword removes the specified password entry from the keyring and updates
// the MAC file to maintain data integrity. If the keyring file doesn't exist, the
// service doesn't exist, or the username doesn't exist, the function returns nil
// without error (idempotent behavior).
//
// Parameters:
//   - serviceName: The name of the service to delete password from
//   - username: The username to delete password for
//
// Returns an error if file operations, JSON marshaling, or MAC update fails.
//
// Example:
//
//        err := keyring.DeletePassword("github", "myuser")
//        if err != nil {
//            // Handle deletion error
//        }
func (b *BasicKeyring) DeletePassword(serviceName, username string) error <span class="cov5" title="6">{
        if _, err := os.Stat(b.keyringFilePath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="5">data, err := b.validateMacAndGetData()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">existingKeyring := make(map[string]map[string]map[string]string)
        if err := json.Unmarshal([]byte(data), &amp;existingKeyring); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="5">if _, ok := existingKeyring[serviceName]; !ok </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="4">if _, ok := existingKeyring[serviceName][username]; !ok </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov3" title="3">delete(existingKeyring[serviceName], username)
        dataBytes, err := json.Marshal(existingKeyring)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">if err := os.WriteFile(b.keyringFilePath, dataBytes, 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">return b.updateMac()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

import "net/http"

// HeaderTransport is a custom HTTP transport that adds headers to requests.
//
// HeaderTransport wraps an existing http.RoundTripper and automatically adds
// specified headers to every HTTP request. This is useful for adding common
// headers like User-Agent, Content-Type, or custom API headers to all requests
// made through the transport.
//
// The transport preserves the behavior of the underlying transport while
// ensuring that all specified headers are set on outgoing requests. If a
// header already exists in the request, it will be overwritten with the
// value from the Headers map.
//
// Example:
//
//        transport := &amp;HeaderTransport{
//            Transport: http.DefaultTransport,
//            Headers: map[string]string{
//                "User-Agent": "MyApp/1.0",
//                "X-API-Key": "secret-key",
//            },
//        }
type HeaderTransport struct {
        // Transport is the underlying http.RoundTripper to wrap
        Transport http.RoundTripper
        // Headers is a map of header names to values that will be added to every request
        Headers map[string]string
}

// RoundTrip implements the http.RoundTripper interface and adds headers to the request.
//
// RoundTrip iterates through all headers in the Headers map and sets them on the
// provided request using req.Header.Set(). This overwrites any existing headers
// with the same name. After setting all headers, it delegates to the underlying
// Transport's RoundTrip method to perform the actual HTTP request.
//
// Parameters:
//   - req: The HTTP request to modify and execute
//
// Returns the HTTP response from the underlying transport and any error encountered.
//
// Example:
//
//        transport := &amp;HeaderTransport{
//            Transport: http.DefaultTransport,
//            Headers: map[string]string{"User-Agent": "MyApp/1.0"},
//        }
//        resp, err := transport.RoundTrip(req)
func (t *HeaderTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="9">{
        for key, value := range t.Headers </span><span class="cov10" title="11">{
                req.Header.Set(key, value)
        }</span>
        <span class="cov9" title="9">return t.Transport.RoundTrip(req)</span>
}

// BasicAuthTransport is a custom HTTP transport that adds Basic Authentication to requests.
//
// BasicAuthTransport wraps an existing http.RoundTripper and automatically adds
// HTTP Basic Authentication headers to every HTTP request using the provided
// username and password credentials. This is useful for APIs that require
// Basic Authentication for all requests.
//
// The transport preserves the behavior of the underlying transport while
// ensuring that the Authorization header is set with properly encoded
// Basic Authentication credentials on outgoing requests.
//
// Example:
//
//        transport := &amp;BasicAuthTransport{
//            Transport: http.DefaultTransport,
//            Username: "myuser",
//            Password: "mypassword",
//        }
type BasicAuthTransport struct {
        // Transport is the underlying http.RoundTripper to wrap
        Transport http.RoundTripper
        // Username is the username for Basic Authentication
        Username string
        // Password is the password for Basic Authentication
        Password string
}

// RoundTrip implements the http.RoundTripper interface and adds Basic Authentication to the request.
//
// RoundTrip sets the Authorization header on the provided request using HTTP Basic
// Authentication with the configured username and password. The credentials are
// automatically encoded using base64 as required by the HTTP Basic Authentication
// standard. After setting the authentication header, it delegates to the underlying
// Transport's RoundTrip method to perform the actual HTTP request.
//
// Parameters:
//   - req: The HTTP request to modify and execute
//
// Returns the HTTP response from the underlying transport and any error encountered.
//
// Example:
//
//        transport := &amp;BasicAuthTransport{
//            Transport: http.DefaultTransport,
//            Username: "myuser",
//            Password: "mypassword",
//        }
//        resp, err := transport.RoundTrip(req)
func (t *BasicAuthTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="10">{
        req.SetBasicAuth(t.Username, t.Password)
        return t.Transport.RoundTrip(req)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package actions provides base functionality for Ark SDK command line actions.
//
// This package defines the core interfaces and base implementations for creating
// command line actions in the Ark SDK. It includes configuration management,
// flag handling, and common execution patterns that can be shared across
// different CLI commands.
package actions

import (
        "os"

        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// ArkAction is an interface that defines the structure for actions in the Ark SDK.
//
// ArkAction provides a contract for implementing command line actions that can
// be integrated with the Ark SDK CLI framework. Implementations should define
// their specific command behavior through the DefineAction method.
type ArkAction interface {
        // DefineAction configures the provided cobra command with action-specific behavior
        DefineAction(cmd *cobra.Command)
}

// ArkBaseAction is a struct that implements the ArkAction interface as a base action.
//
// ArkBaseAction provides common functionality that can be shared across different
// action implementations. It includes logger management and common flag handling
// patterns. This struct can be embedded in more specific action implementations
// to provide consistent behavior across the CLI.
type ArkBaseAction struct {
        // logger is the internal logger instance for the action
        logger *common.ArkLogger
}

// NewArkBaseAction creates a new instance of ArkBaseAction.
//
// NewArkBaseAction initializes a new ArkBaseAction with a configured logger.
// The logger is set up with a default configuration using the "ArkBaseAction"
// name and Unknown log level.
//
// Returns a new ArkBaseAction instance ready for use.
//
// Example:
//
//        action := NewArkBaseAction()
//        action.CommonActionsConfiguration(cmd)
func NewArkBaseAction() *ArkBaseAction <span class="cov10" title="139">{
        return &amp;ArkBaseAction{
                logger: common.GetLogger("ArkBaseAction", common.Unknown),
        }
}</span>

// CommonActionsConfiguration sets up common flags for the command line interface.
//
// CommonActionsConfiguration adds standard persistent flags to the provided cobra
// command that are commonly used across different Ark SDK actions. These flags
// control logging behavior, output formatting, certificate handling, and other
// common CLI options.
//
// The following flags are added:
//   - raw: Controls whether output should be in raw format
//   - silent: Enables silent execution without interactive prompts
//   - allow-output: Allows stdout/stderr output even in silent mode
//   - verbose: Enables verbose logging
//   - logger-style: Specifies the style for verbose logging
//   - log-level: Sets the log level for verbose mode
//   - disable-cert-verification: Disables HTTPS certificate verification (unsafe)
//   - trusted-cert: Specifies a trusted certificate for HTTPS calls
//
// Parameters:
//   - cmd: The cobra command to configure with persistent flags
//
// Example:
//
//        action := NewArkBaseAction()
//        action.CommonActionsConfiguration(rootCmd)
func (a *ArkBaseAction) CommonActionsConfiguration(cmd *cobra.Command) <span class="cov7" title="42">{
        cmd.PersistentFlags().Bool("raw", false, "Whether to raw output")
        cmd.PersistentFlags().Bool("silent", false, "Silent execution, no interactiveness")
        cmd.PersistentFlags().Bool("allow-output", false, "Allow stdout / stderr even when silent and not interactive")
        cmd.PersistentFlags().Bool("verbose", false, "Whether to verbose log")
        cmd.PersistentFlags().String("logger-style", "default", "Which verbose logger style to use")
        cmd.PersistentFlags().String("log-level", "INFO", "Log level to use while verbose")
        cmd.PersistentFlags().Bool("disable-cert-verification", false, "Disables certificate verification on HTTPS calls, unsafe! Avoid using in production environments!")
        cmd.PersistentFlags().String("trusted-cert", "", "Certificate to use for HTTPS calls")
}</span>

// CommonActionsExecution executes common actions based on the command line flags.
//
// CommonActionsExecution processes the standard flags set up by CommonActionsConfiguration
// and applies the corresponding configuration changes to the Ark SDK runtime. This
// function should be called early in command execution to ensure proper setup.
//
// The function performs the following operations:
//  1. Sets default states for color, interactivity, logging, and certificates
//  2. Processes each flag and applies the corresponding configuration
//  3. Handles certificate verification settings (disable or trusted cert)
//  4. Configures profile name if provided
//  5. Sets default DEPLOY_ENV if not already set
//
// Parameters:
//   - cmd: The cobra command containing the parsed flags
//   - args: Command line arguments (not currently used but part of cobra pattern)
//
// The function ignores flag parsing errors and uses default values in such cases,
// following the principle of graceful degradation for CLI flag handling.
//
// Example:
//
//        action := NewArkBaseAction()
//        action.CommonActionsExecution(cmd, args)
func (a *ArkBaseAction) CommonActionsExecution(cmd *cobra.Command, args []string) <span class="cov6" title="26">{
        common.EnableColor()
        common.EnableInteractive()
        common.DisableVerboseLogging()
        common.DisallowOutput()
        common.SetLoggerStyle(viper.GetString("logger-style"))
        common.EnableCertificateVerification()

        if raw, err := cmd.Flags().GetBool("raw"); err == nil &amp;&amp; raw </span><span class="cov0" title="0">{
                common.DisableColor()
        }</span>
        <span class="cov6" title="26">if silent, err := cmd.Flags().GetBool("silent"); err == nil &amp;&amp; silent </span><span class="cov0" title="0">{
                common.DisableInteractive()
        }</span>
        <span class="cov6" title="26">if verbose, err := cmd.Flags().GetBool("verbose"); err == nil &amp;&amp; verbose </span><span class="cov0" title="0">{
                common.EnableVerboseLogging(viper.GetString("log-level"))
        }</span>
        <span class="cov6" title="26">if allowOutput, err := cmd.Flags().GetBool("allow-output"); err == nil &amp;&amp; allowOutput </span><span class="cov0" title="0">{
                common.AllowOutput()
        }</span>
        <span class="cov6" title="26">if disableCertValidation, err := cmd.Flags().GetBool("disable-cert-verification"); err == nil &amp;&amp; disableCertValidation </span><span class="cov0" title="0">{
                common.DisableCertificateVerification()
        }</span> else<span class="cov6" title="26"> if trustedCert, err := cmd.Flags().GetString("trusted-cert"); err == nil &amp;&amp; trustedCert != "" </span><span class="cov0" title="0">{
                common.SetTrustedCertificate(viper.GetString("trusted-cert"))
        }</span>
        <span class="cov6" title="26">a.logger = common.GetLogger("ArkBaseAction", common.Unknown)

        if profileName, err := cmd.Flags().GetString("profile-name"); err == nil &amp;&amp; profileName != "" </span><span class="cov5" title="13">{
                viper.Set("profile-name", profiles.DeduceProfileName(profileName))
        }</span>
        <span class="cov6" title="26">if os.Getenv("DEPLOY_ENV") == "" </span><span class="cov3" title="3">{
                _ = os.Setenv("DEPLOY_ENV", "prod")
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package actions

import (
        "os"
        "reflect"

        commoninternal "github.com/cyberark/ark-sdk-golang/internal/common"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        commonargs "github.com/cyberark/ark-sdk-golang/pkg/common/args"
        "github.com/spf13/cobra"
)

// ArkCacheAction is a struct that implements the ArkAction interface for cache management.
//
// ArkCacheAction provides functionality for managing cache operations in the Ark SDK CLI.
// It embeds ArkBaseAction to inherit common CLI functionality and adds specific cache
// management commands such as clearing cached profiles and credentials.
//
// The action specifically supports clearing cache for basic keyring implementations,
// which store credentials and profile information in local files.
type ArkCacheAction struct {
        // ArkBaseAction provides common action functionality
        *ArkBaseAction
}

// NewArkCacheAction creates a new instance of ArkCacheAction.
//
// NewArkCacheAction initializes a new ArkCacheAction with an embedded ArkBaseAction,
// providing all the common CLI functionality along with cache-specific operations.
// The returned instance is ready to be used for defining cache management commands.
//
// Returns a new ArkCacheAction instance with initialized base action functionality.
//
// Example:
//
//        cacheAction := NewArkCacheAction()
//        cacheAction.DefineAction(rootCmd)
func NewArkCacheAction() *ArkCacheAction <span class="cov10" title="15">{
        return &amp;ArkCacheAction{
                ArkBaseAction: NewArkBaseAction(),
        }
}</span>

// DefineAction defines the CLI cache action and adds cache management subcommands.
//
// DefineAction creates a "cache" command with subcommands for cache management operations.
// Currently, it provides a "clear" subcommand that removes cached credentials and profile
// information from the basic keyring implementation.
//
// The function sets up:
//  1. A parent "cache" command for cache management
//  2. Common action configuration through embedded ArkBaseAction
//  3. A "clear" subcommand for clearing cached data
//  4. Persistent pre-run hook for common action execution
//
// Parameters:
//   - cmd: The parent cobra command to which the cache command will be added
//
// The cache command supports the standard CLI flags inherited from ArkBaseAction
// and executes common action setup before running cache-specific operations.
//
// Example:
//
//        cacheAction := NewArkCacheAction()
//        cacheAction.DefineAction(rootCmd)
//        // This adds: myapp cache clear
func (a *ArkCacheAction) DefineAction(cmd *cobra.Command) <span class="cov6" title="6">{
        cacheCmd := &amp;cobra.Command{
                Use:   "cache",
                Short: "Manage cache",
        }
        cacheCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                a.CommonActionsExecution(cmd, args)
        }</span>
        <span class="cov6" title="6">a.CommonActionsConfiguration(cacheCmd)

        clearCmd := &amp;cobra.Command{
                Use:   "clear",
                Short: "Clears all profiles cache",
                Run:   a.runClearCacheAction,
        }

        cacheCmd.AddCommand(clearCmd)
        cmd.AddCommand(cacheCmd)</span>
}

// runClearCacheAction clears cached credentials and profile data for basic keyring implementations.
//
// runClearCacheAction attempts to clear cached data by removing the keyring and MAC files
// from the basic keyring storage location. The function only operates on basic keyring
// implementations and will print a message for other keyring types.
//
// The function performs the following operations:
//  1. Creates a new ArkKeyring instance and retrieves the keyring
//  2. Checks if the keyring is a BasicKeyring implementation
//  3. If not BasicKeyring, prints an informational message and returns
//  4. Determines the cache folder path from HOME or environment variable
//  5. Removes the "keyring" and "mac" files from the cache folder
//
// Parameters:
//   - cmd: The cobra command (not currently used)
//   - args: Command line arguments (not currently used)
//
// The function gracefully handles errors by ignoring file removal failures,
// following the pattern of best-effort cleanup operations.
//
// Cache folder resolution:
//   - Default: $HOME/.ark-keyring/
//   - Override: ARK_BASIC_KEYRING_FOLDER environment variable
func (a *ArkCacheAction) runClearCacheAction(cmd *cobra.Command, args []string) <span class="cov5" title="4">{
        if keyring, err := common.NewArkKeyring("").GetKeyring(false); err == nil </span><span class="cov5" title="4">{
                if reflect.TypeOf(keyring) != reflect.TypeOf(&amp;commoninternal.BasicKeyring{}) </span><span class="cov0" title="0">{
                        commonargs.PrintNormal("Cache clear is only valid for basic keyring implementation at the moment")
                        return
                }</span>
                <span class="cov5" title="4">cacheFolderPath := os.ExpandEnv("$HOME") + string(os.PathSeparator) + commoninternal.DefaultBasicKeyringFolder
                if envPath := os.Getenv(commoninternal.ArkBasicKeyringFolderEnvVar); envPath != "" </span><span class="cov1" title="1">{
                        cacheFolderPath = envPath
                }</span>
                <span class="cov5" title="4">_ = os.Remove(cacheFolderPath + string(os.PathSeparator) + "keyring")
                _ = os.Remove(cacheFolderPath + string(os.PathSeparator) + "mac")</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package actions

import (
        "encoding/json"
        "fmt"
        "slices"
        "strings"

        "github.com/cyberark/ark-sdk-golang/pkg/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/common/args"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        authmodels "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/mitchellh/mapstructure"
        "github.com/octago/sflags"
        "github.com/octago/sflags/gen/gpflag"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

// ArkConfigureAction is a struct that implements the ArkAction interface for configuring the CLI profiles.
//
// ArkConfigureAction provides functionality for managing CLI configuration profiles,
// including both interactive and silent configuration modes. It handles profile
// creation, modification, and persistence, as well as configuring authentication
// profiles for different authenticators supported by the Ark SDK.
//
// The action supports dynamic flag generation based on available authenticators
// and their supported authentication methods, allowing for flexible configuration
// of different authentication backends.
type ArkConfigureAction struct {
        // ArkBaseAction provides common action functionality
        *ArkBaseAction
        // profilesLoader handles loading and saving of profile configurations
        profilesLoader *profiles.ProfileLoader
}

// NewArkConfigureAction creates a new instance of ArkConfigureAction.
//
// NewArkConfigureAction initializes a new ArkConfigureAction with the provided
// profile loader and an embedded ArkBaseAction for common CLI functionality.
// The profile loader is used for loading existing profiles and saving new
// or modified profile configurations.
//
// Parameters:
//   - profilesLoader: A pointer to a ProfileLoader for handling profile operations
//
// Returns a new ArkConfigureAction instance ready for defining configure commands.
//
// Example:
//
//        loader := profiles.NewProfileLoader()
//        configAction := NewArkConfigureAction(loader)
//        configAction.DefineAction(rootCmd)
func NewArkConfigureAction(profilesLoader *profiles.ProfileLoader) *ArkConfigureAction <span class="cov5" title="11">{
        return &amp;ArkConfigureAction{
                ArkBaseAction:  NewArkBaseAction(),
                profilesLoader: profilesLoader,
        }
}</span>

// DefineAction defines the CLI configure action and adds configuration management commands.
//
// DefineAction creates a "configure" command that allows users to set up and modify
// CLI profiles for the Ark SDK. The command supports both interactive and silent
// modes of operation, dynamically generates flags based on available authenticators,
// and handles complex profile configuration scenarios.
//
// The function performs the following setup:
//  1. Creates a "configure" command with appropriate usage and help text
//  2. Sets up common action configuration through embedded ArkBaseAction
//  3. Dynamically generates flags for ArkProfile struct fields
//  4. Iterates through supported authenticators and adds their specific flags
//  5. Generates flags for authentication methods and their settings
//  6. Handles flag conflicts by filtering duplicate flags
//
// Parameters:
//   - cmd: The parent cobra command to which the configure command will be added
//
// The configure command supports extensive flag generation including:
//   - Profile-level settings (from models.ArkProfile)
//   - Authenticator enablement flags (work-with-&lt;authenticator&gt;)
//   - Authentication method selection flags
//   - Authenticator-specific configuration flags
//   - Authentication method-specific settings flags
//
// Example:
//
//        configAction := NewArkConfigureAction(loader)
//        configAction.DefineAction(rootCmd)
//        // This adds: myapp configure [flags]
func (a *ArkConfigureAction) DefineAction(cmd *cobra.Command) <span class="cov3" title="4">{
        confCmd := &amp;cobra.Command{
                Use:   "configure",
                Short: "Configure the CLI",
                Run:   a.runConfigureAction,
        }
        confCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                a.CommonActionsExecution(cmd, args)
        }</span>
        <span class="cov3" title="4">a.CommonActionsConfiguration(confCmd)

        // Add the profile settings to the arguments
        err := gpflag.ParseTo(&amp;models.ArkProfile{}, confCmd.Flags())
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Error parsing flags to ArkProfile %v", err)
                panic(err)</span>
        }

        // Add the supported authenticator settings and whether to work with them or not
        <span class="cov3" title="4">for _, authenticator := range auth.SupportedAuthenticatorsList </span><span class="cov3" title="4">{
                confCmd.Flags().Bool(
                        "work-with-"+strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1),
                        false,
                        "Whether to work with "+authenticator.AuthenticatorHumanReadableName()+" services",
                )
                if len(authenticator.SupportedAuthMethods()) &gt; 1 </span><span class="cov3" title="4">{
                        confCmd.Flags().String(
                                strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1)+"-auth-method",
                                string(authmodels.Default),
                                "Authentication method for "+authenticator.AuthenticatorHumanReadableName(),
                        )
                }</span>
                // Add the rest of the ark auth profile params
                <span class="cov3" title="4">err = gpflag.ParseTo(&amp;authmodels.ArkAuthProfile{}, confCmd.Flags(), sflags.Prefix(strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1)+"-"))
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Error parsing flags to ArkAuthProfile %v", err)
                        panic(err)</span>
                }

                // Add the supported authentication methods settings of the authenticators
                <span class="cov3" title="4">for _, authMethod := range authenticator.SupportedAuthMethods() </span><span class="cov4" title="8">{
                        authSettings := authmodels.ArkAuthMethodSettingsMap[authMethod]
                        flags, err := sflags.ParseStruct(authSettings, sflags.Prefix(strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1)+"-"))
                        if err != nil </span><span class="cov0" title="0">{
                                a.logger.Error("Error parsing flags to ArkAuthMethod settings %v", err)
                                panic(err)</span>
                        }
                        <span class="cov4" title="8">existingFlags := make([]string, 0)
                        for _, flag := range flags </span><span class="cov6" title="32">{
                                confCmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov10" title="220">{
                                        if f.Name == flag.Name </span><span class="cov4" title="8">{
                                                existingFlags = append(existingFlags, flag.Name)
                                        }</span>
                                })
                        }
                        <span class="cov4" title="8">filteredFlags := make([]*sflags.Flag, 0)
                        for _, flag := range flags </span><span class="cov6" title="32">{
                                if !slices.Contains(existingFlags, flag.Name) </span><span class="cov6" title="24">{
                                        filteredFlags = append(filteredFlags, flag)
                                }</span>
                        }
                        <span class="cov4" title="8">gpflag.GenerateTo(filteredFlags, confCmd.Flags())</span>
                }
        }
        <span class="cov3" title="4">cmd.AddCommand(confCmd)</span>
}

// runInteractiveConfigureAction handles interactive profile configuration through prompts.
//
// runInteractiveConfigureAction provides an interactive mode for configuring CLI profiles
// where users are prompted for each configuration value. It loads existing profiles,
// presents current values as defaults, and guides users through the configuration
// process for both profile settings and authenticator configurations.
//
// The function performs the following operations:
//  1. Prompts for profile name with intelligent default deduction
//  2. Loads existing profile or creates new one if not found
//  3. Prompts for each profile field with existing values as defaults
//  4. Presents checkbox selection for which authenticators to configure
//  5. For each selected authenticator, prompts for authentication method and settings
//  6. Handles authentication method-specific configuration dynamically
//
// Parameters:
//   - cmd: The cobra command containing flag definitions and values
//   - configureArgs: Command line arguments (not currently used)
//
// Returns the configured ArkProfile and any error encountered during configuration.
//
// The function uses the args package for interactive prompting and supports
// complex scenarios like multiple authenticators and different authentication methods.
func (a *ArkConfigureAction) runInteractiveConfigureAction(cmd *cobra.Command, configureArgs []string) (*models.ArkProfile, error) <span class="cov0" title="0">{
        profileName, err := args.GetArg(
                cmd,
                "profile-name",
                "Profile Name",
                profiles.DeduceProfileName(""),
                false,
                true,
                false,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">profile, err := (*a.profilesLoader).LoadProfile(profileName)
        if err != nil || profile == nil </span><span class="cov0" title="0">{
                profile = &amp;models.ArkProfile{
                        ProfileName:  profileName,
                        AuthProfiles: make(map[string]*authmodels.ArkAuthProfile),
                }
        }</span>
        <span class="cov0" title="0">flags, err := sflags.ParseStruct(profile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">answers := map[string]interface{}{}
        err = mapstructure.Decode(profile, &amp;answers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, flag := range flags </span><span class="cov0" title="0">{
                if flag.Name == "profile-name" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">val, err := cmd.Flags().GetString(flag.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                        existingVal, ok := answers[strings.Replace(flag.Name, "-", "_", -1)]
                        if ok </span><span class="cov0" title="0">{
                                val = existingVal.(string)
                        }</span>
                }
                <span class="cov0" title="0">val, err = args.GetArg(
                        cmd,
                        flag.Name,
                        flag.Usage,
                        val,
                        false,
                        true,
                        true,
                )
                answers[strings.Replace(flag.Name, "-", "_", -1)] = val</span>
        }
        <span class="cov0" title="0">err = mapstructure.Decode(answers, &amp;profile)

        var workWithAuthenticators []string
        if len(auth.SupportedAuthenticatorsList) == 1 </span><span class="cov0" title="0">{
                workWithAuthenticators = []string{auth.SupportedAuthenticatorsList[0].AuthenticatorHumanReadableName()}
        }</span> else<span class="cov0" title="0"> {
                workWithAuthenticators, err = args.GetCheckboxArgs(
                        cmd,
                        func() []string </span><span class="cov0" title="0">{
                                keys := make([]string, len(auth.SupportedAuthenticatorsList))
                                for i, a := range auth.SupportedAuthenticatorsList </span><span class="cov0" title="0">{
                                        keys[i] = fmt.Sprintf("work_with_%s", strings.Replace(a.AuthenticatorName(), "-", "_", -1))
                                }</span>
                                <span class="cov0" title="0">return keys</span>
                        }(),
                        "Which authenticators would you like to connect to",
                        func() []string <span class="cov0" title="0">{
                                names := make([]string, len(auth.SupportedAuthenticatorsList))
                                for i, a := range auth.SupportedAuthenticatorsList </span><span class="cov0" title="0">{
                                        names[i] = a.AuthenticatorHumanReadableName()
                                }</span>
                                <span class="cov0" title="0">return names</span>
                        }(),
                        func() map[string]string <span class="cov0" title="0">{
                                existingVals := make(map[string]string)
                                for _, a := range auth.SupportedAuthenticatorsList </span><span class="cov0" title="0">{
                                        if _, exists := profile.AuthProfiles[a.AuthenticatorName()]; exists </span><span class="cov0" title="0">{
                                                existingVals[fmt.Sprintf("work_with_%s", strings.Replace(a.AuthenticatorName(), "-", "_", -1))] = a.AuthenticatorHumanReadableName()
                                        }</span>
                                }
                                <span class="cov0" title="0">return existingVals</span>
                        }(),
                        true,
                )
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">for _, authenticator := range auth.SupportedAuthenticatorsList </span><span class="cov0" title="0">{
                authProfile, ok := profile.AuthProfiles[authenticator.AuthenticatorName()]
                if !ok || authProfile == nil </span><span class="cov0" title="0">{
                        authProfile = &amp;authmodels.ArkAuthProfile{}
                }</span>

                <span class="cov0" title="0">if slices.Contains(workWithAuthenticators, authenticator.AuthenticatorHumanReadableName()) </span><span class="cov0" title="0">{
                        args.PrintSuccessBright(fmt.Sprintf("\n◉ Configuring %s", authenticator.AuthenticatorHumanReadableName()))

                        var authMethod authmodels.ArkAuthMethod
                        if len(authenticator.SupportedAuthMethods()) &gt; 1 </span><span class="cov0" title="0">{
                                authMethodStr, err := args.GetSwitchArg(
                                        cmd,
                                        fmt.Sprintf("%s_auth_method", strings.Replace(authenticator.AuthenticatorName(), "-", "_", -1)),
                                        "Authentication Method",
                                        func() []string </span><span class="cov0" title="0">{
                                                methods := make([]string, len(authenticator.SupportedAuthMethods()))
                                                for i, m := range authenticator.SupportedAuthMethods() </span><span class="cov0" title="0">{
                                                        methods[i] = authmodels.ArkAuthMethodsDescriptionMap[m]
                                                }</span>
                                                <span class="cov0" title="0">return methods</span>
                                        }(),
                                        func() string <span class="cov0" title="0">{
                                                if _, exists := profile.AuthProfiles[authenticator.AuthenticatorName()]; exists </span><span class="cov0" title="0">{
                                                        return authmodels.ArkAuthMethodsDescriptionMap[authProfile.AuthMethod]
                                                }</span>
                                                <span class="cov0" title="0">authMethod, _ := authenticator.DefaultAuthMethod()
                                                return authmodels.ArkAuthMethodsDescriptionMap[authMethod]</span>
                                        }(),
                                        true,
                                )
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">for key, val := range authmodels.ArkAuthMethodsDescriptionMap </span><span class="cov0" title="0">{
                                        if val == authMethodStr </span><span class="cov0" title="0">{
                                                authMethod = key
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if authMethod == authmodels.Default </span><span class="cov0" title="0">{
                                        authMethod, _ = authenticator.DefaultAuthMethod()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                authMethod, _ = authenticator.DefaultAuthMethod()
                        }</span>
                        <span class="cov0" title="0">authPrefix := strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1) + "-"
                        authProfileFlags, err := sflags.ParseStruct(authProfile, sflags.Prefix(authPrefix))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">authProfileAnswers := map[string]interface{}{}
                        err = mapstructure.Decode(authProfile, &amp;authProfileAnswers)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">for _, flag := range authProfileFlags </span><span class="cov0" title="0">{
                                val, err := cmd.Flags().GetString(flag.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                                        existingVal, ok := authProfileAnswers[strings.Replace(strings.TrimPrefix(flag.Name, authPrefix), "-", "_", -1)]
                                        if ok </span><span class="cov0" title="0">{
                                                val = existingVal.(string)
                                        }</span>
                                }
                                <span class="cov0" title="0">val, err = args.GetArg(
                                        cmd,
                                        flag.Name,
                                        flag.Usage,
                                        val,
                                        false,
                                        true,
                                        true,
                                )
                                authProfileAnswers[strings.Replace(strings.TrimPrefix(flag.Name, authPrefix), "-", "_", -1)] = val</span>
                        }
                        <span class="cov0" title="0">err = mapstructure.Decode(authProfileAnswers, &amp;authProfile)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">var methodSettings interface{}
                        if authMethod != authProfile.AuthMethod </span><span class="cov0" title="0">{
                                methodSettings = authmodels.ArkAuthMethodSettingsMap[authMethod]
                        }</span> else<span class="cov0" title="0"> {
                                methodSettings = authmodels.ArkAuthMethodSettingsMap[authMethod]
                                err = mapstructure.Decode(authProfile.AuthMethodSettings, methodSettings)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">methodSettingsFlags, err := sflags.ParseStruct(methodSettings, sflags.Prefix(strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1)+"-"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">methodSettingsAnswers := map[string]interface{}{}
                        err = mapstructure.Decode(methodSettings, &amp;methodSettingsAnswers)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">for _, flag := range methodSettingsFlags </span><span class="cov0" title="0">{
                                if flag.Value.Type() == "bool" </span><span class="cov0" title="0">{
                                        val, err := cmd.Flags().GetBool(flag.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">val, err = args.GetBoolArg(
                                                cmd,
                                                flag.Name,
                                                flag.Usage,
                                                nil,
                                                true,
                                        )
                                        methodSettingsAnswers[strings.Replace(strings.TrimPrefix(flag.Name, authPrefix), "-", "_", -1)] = val</span>
                                } else<span class="cov0" title="0"> {
                                        val, err := cmd.Flags().GetString(flag.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">if val == "" </span><span class="cov0" title="0">{
                                                existingVal, ok := methodSettingsAnswers[strings.Replace(strings.TrimPrefix(flag.Name, authPrefix), "-", "_", -1)]
                                                if ok </span><span class="cov0" title="0">{
                                                        val = existingVal.(string)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">val, err = args.GetArg(
                                                cmd,
                                                flag.Name,
                                                flag.Usage,
                                                val,
                                                false,
                                                true,
                                                true,
                                        )
                                        methodSettingsAnswers[strings.Replace(strings.TrimPrefix(flag.Name, authPrefix), "-", "_", -1)] = val</span>
                                }
                        }
                        <span class="cov0" title="0">err = mapstructure.Decode(methodSettingsAnswers, methodSettings)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">authProfile.AuthMethod = authMethod
                        authProfile.AuthMethodSettings = methodSettings
                        profile.AuthProfiles[authenticator.AuthenticatorName()] = authProfile</span>
                } else<span class="cov0" title="0"> if _, exists := profile.AuthProfiles[authenticator.AuthenticatorName()]; exists </span><span class="cov0" title="0">{
                        delete(profile.AuthProfiles, authenticator.AuthenticatorName())
                }</span>
        }
        <span class="cov0" title="0">return profile, nil</span>
}

// runSilentConfigureAction handles non-interactive profile configuration using command flags.
//
// runSilentConfigureAction processes configuration in silent mode where all configuration
// values are provided through command line flags rather than interactive prompts. It
// loads existing profiles, merges flag values, and validates the configuration for
// completeness and correctness.
//
// The function performs the following operations:
//  1. Extracts profile name from flags or deduces default
//  2. Loads existing profile or creates new one if not found
//  3. Processes all changed flags and merges them into the profile
//  4. Iterates through authenticators based on work-with-* flags
//  5. Validates required fields (like username for credential-based auth methods)
//  6. Processes authenticator-specific flags and settings
//  7. Removes authenticator profiles that are no longer configured
//
// Parameters:
//   - cmd: The cobra command containing parsed flags and values
//   - args: Command line arguments (not currently used)
//
// Returns the configured ArkProfile and any error encountered during configuration.
//
// The function requires all necessary configuration to be provided via flags and
// will return errors for missing required fields or invalid configurations.
func (a *ArkConfigureAction) runSilentConfigureAction(cmd *cobra.Command, args []string) (*models.ArkProfile, error) <span class="cov3" title="4">{
        // Load the profile based on the CLI params and merge the rest of the params
        profileName, err := cmd.Flags().GetString("profile-name")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="4">if profileName == "" </span><span class="cov2" title="2">{
                profileName = profiles.DeduceProfileName("")
        }</span>
        <span class="cov3" title="4">profile, err := (*a.profilesLoader).LoadProfile(profileName)
        if err != nil || profile == nil </span><span class="cov2" title="3">{
                profile = &amp;models.ArkProfile{
                        ProfileName:  profileName,
                        AuthProfiles: make(map[string]*authmodels.ArkAuthProfile),
                }
        }</span>
        <span class="cov3" title="4">flags := map[string]interface{}{}
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov3" title="5">{
                if f.Changed </span><span class="cov2" title="3">{
                        flags[strings.Replace(f.Name, "-", "_", -1)] = f.Value.String()
                }</span>
        })
        <span class="cov3" title="4">err = mapstructure.Decode(flags, &amp;profile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Load the authenticators
        <span class="cov3" title="4">for _, authenticator := range auth.SupportedAuthenticatorsList </span><span class="cov3" title="4">{
                authProfile, ok := profile.AuthProfiles[authenticator.AuthenticatorName()]
                if !ok || authProfile == nil </span><span class="cov3" title="4">{
                        authProfile = &amp;authmodels.ArkAuthProfile{}
                }</span>
                <span class="cov3" title="4">workWithAuth, err := cmd.Flags().GetBool(fmt.Sprintf("work-with-%s", authenticator.AuthenticatorName()))
                if err != nil </span><span class="cov3" title="4">{
                        continue</span>
                }
                <span class="cov0" title="0">if workWithAuth </span><span class="cov0" title="0">{
                        var authMethod authmodels.ArkAuthMethod
                        if len(authenticator.SupportedAuthMethods()) &gt; 1 </span><span class="cov0" title="0">{
                                authMethodStr, err := cmd.Flags().GetString(fmt.Sprintf("%s-auth-method", authenticator.AuthenticatorName()))
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">authMethod = authmodels.ArkAuthMethod(authMethodStr)
                                if authMethod == authmodels.Default </span><span class="cov0" title="0">{
                                        authMethod, _ = authenticator.DefaultAuthMethod()
                                }</span> else<span class="cov0" title="0"> if !slices.Contains(authenticator.SupportedAuthMethods(), authMethod) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("auth method %s is not supported by %s", authMethod, authenticator.AuthenticatorHumanReadableName())
                                }</span>
                        } else<span class="cov0" title="0"> {
                                authMethod, _ = authenticator.DefaultAuthMethod()
                        }</span>
                        <span class="cov0" title="0">authSpecificFlags := map[string]interface{}{}
                        authPrefix := strings.Replace(authenticator.AuthenticatorName(), "_", "-", -1) + "-"
                        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov0" title="0">{
                                if f.Changed &amp;&amp; strings.HasPrefix(f.Name, authPrefix) </span><span class="cov0" title="0">{
                                        authSpecificFlags[strings.Replace(strings.TrimPrefix(f.Name, authPrefix), "-", "_", -1)] = f.Value.String()
                                }</span>
                        })
                        <span class="cov0" title="0">err = mapstructure.Decode(authSpecificFlags, &amp;authProfile)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if slices.Contains(authmodels.ArkAuthMethodsRequireCredentials, authMethod) &amp;&amp; authProfile.Username == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("missing username for authenticator [%s]", authenticator.AuthenticatorHumanReadableName())
                        }</span>

                        <span class="cov0" title="0">var methodSettings interface{}
                        if authMethod != authProfile.AuthMethod </span><span class="cov0" title="0">{
                                methodSettings = authmodels.ArkAuthMethodSettingsMap[authMethod]
                        }</span> else<span class="cov0" title="0"> {
                                methodSettings = authmodels.ArkAuthMethodSettingsMap[authMethod]
                                err = mapstructure.Decode(authProfile.AuthMethodSettings, methodSettings)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">err = mapstructure.Decode(authSpecificFlags, methodSettings)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">authProfile.AuthMethod = authMethod
                        authProfile.AuthMethodSettings = methodSettings
                        profile.AuthProfiles[authenticator.AuthenticatorName()] = authProfile</span>
                } else<span class="cov0" title="0"> if _, exists := profile.AuthProfiles[authenticator.AuthenticatorName()]; exists </span><span class="cov0" title="0">{
                        delete(profile.AuthProfiles, authenticator.AuthenticatorName())
                }</span>
        }
        <span class="cov3" title="4">return profile, nil</span>
}

// runConfigureAction is the main entry point for the configure command execution.
//
// runConfigureAction determines whether to run in interactive or silent mode based
// on the current CLI environment settings, executes the appropriate configuration
// method, saves the resulting profile, and displays the configuration results to
// the user.
//
// The function performs the following operations:
//  1. Checks if the CLI is running in interactive mode
//  2. Calls either runInteractiveConfigureAction or runSilentConfigureAction
//  3. Saves the configured profile using the profile loader
//  4. Marshals the profile to JSON for display
//  5. Prints success messages and profile location information
//
// Parameters:
//   - cmd: The cobra command containing configuration and flags
//   - configureArgs: Command line arguments passed to the configure command
//
// The function handles errors by logging them and panicking for critical failures
// like configuration errors, following the CLI pattern of failing fast for
// configuration issues that prevent proper operation.
//
// Example output:
//
//        {
//          "profile_name": "default",
//          "auth_profiles": {...}
//        }
//        Profile has been saved to /home/user/.ark-profiles
func (a *ArkConfigureAction) runConfigureAction(cmd *cobra.Command, configureArgs []string) <span class="cov0" title="0">{
        var profile *models.ArkProfile
        var err error
        if common.IsInteractive() </span><span class="cov0" title="0">{
                profile, err = a.runInteractiveConfigureAction(cmd, configureArgs)
        }</span> else<span class="cov0" title="0"> {
                profile, err = a.runSilentConfigureAction(cmd, configureArgs)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Error configuring ark profile %v", err)
                panic(err)</span>
        }
        <span class="cov0" title="0">err = (*a.profilesLoader).SaveProfile(profile)
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Error saving ark profile %v", err)
                return
        }</span>
        <span class="cov0" title="0">data, err := json.MarshalIndent(profile, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Error serializing ark profile %v", err)
                return
        }</span>
        <span class="cov0" title="0">args.PrintSuccess(string(data))
        args.PrintSuccessBright(fmt.Sprintf("Profile has been saved to %s", profiles.GetProfilesFolder()))</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package actions provides base implementation for CLI exec actions in the ARK SDK.
//
// This package contains the core functionality for defining and executing CLI commands
// that integrate with various authentication providers and profiles.
package actions

import (
        "fmt"
        "time"

        "github.com/cyberark/ark-sdk-golang/pkg/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/cli"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/common/args"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

// ArkExecAction defines the interface for executing CLI actions in the ARK SDK.
//
// Implementations of this interface provide the actual command definition and execution logic
// for specific ARK SDK operations. The interface enables pluggable action implementations
// while maintaining consistent command structure and behavior.
type ArkExecAction interface {
        // DefineExecAction configures the specific exec command structure and flags.
        //
        // This method is called during command initialization to set up the CLI command
        // structure, including any subcommands, flags, and help text specific to the action.
        //
        // Parameters:
        //   - cmd: The parent cobra command to which the exec action will be added
        //
        // Returns an error if the command definition fails.
        DefineExecAction(cmd *cobra.Command) error

        // RunExecAction executes the specific action logic with an authenticated API client.
        //
        // This method is called after authentication and profile loading are complete.
        // It receives a fully configured CLI API client and should implement the actual
        // business logic for the specific action.
        //
        // Parameters:
        //   - api: Authenticated ARK CLI API client
        //   - cmd: The root command being executed
        //   - execCmd: The specific exec command being run
        //   - args: Command line arguments passed to the action
        //
        // Returns an error if the action execution fails.
        RunExecAction(api *cli.ArkCLIAPI, cmd *cobra.Command, execCmd *cobra.Command, args []string) error
}

// ArkBaseExecAction provides a base implementation for ARK CLI exec actions.
//
// This struct serves as a foundation for implementing specific exec actions by combining
// the common ARK action functionality with exec-specific behavior. It handles profile
// loading, authentication, and action execution orchestration.
//
// The struct embeds ArkBaseAction to inherit common CLI functionality and adds
// exec-specific capabilities like profile management and action delegation.
type ArkBaseExecAction struct {
        *ArkBaseAction
        profilesLoader *profiles.ProfileLoader
        execAction     *ArkExecAction
        logger         *common.ArkLogger
}

// NewArkBaseExecAction creates a new instance of ArkBaseExecAction with the specified configuration.
//
// NewArkBaseExecAction initializes a base exec action with the provided action implementation,
// name for logging, and profile loader. The returned instance can be used to define
// and execute CLI commands that require profile-based authentication. The constructor
// sets up logging with the specified name and configures all necessary dependencies
// for command execution.
//
// Parameters:
//   - execAction: Implementation of the specific exec action behavior
//   - name: Identifier used for logging and error reporting
//   - profilesLoader: Service for loading and managing authentication profiles
//
// Returns a configured ArkBaseExecAction ready for command definition and execution.
//
// Example:
//
//        action := NewArkBaseExecAction(
//            &amp;myExecAction,
//            "my-action",
//            profileLoader,
//        )
//        action.DefineAction(rootCmd)
func NewArkBaseExecAction(execAction *ArkExecAction, name string, profilesLoader *profiles.ProfileLoader) *ArkBaseExecAction <span class="cov10" title="52">{
        return &amp;ArkBaseExecAction{
                ArkBaseAction:  NewArkBaseAction(),
                profilesLoader: profilesLoader,
                execAction:     execAction,
                logger:         common.GetLogger(name, common.Unknown),
        }
}</span>

// DefineAction defines the CLI `exec` command structure and configuration.
//
// DefineAction creates and configures the `exec` subcommand with all necessary flags
// and execution behavior. It sets up the command hierarchy, adds persistent flags
// for profile management and execution control, and delegates specific action
// definition to the embedded exec action implementation.
//
// The method configures the following persistent flags:
//   - profile-name: Specifies which authentication profile to use
//   - output-path: Optional file path for writing command output
//   - request-file: Optional file containing action parameters
//   - retry-count: Number of retry attempts for failed executions
//   - refresh-auth: Forces authentication token refresh
//
// Parameters:
//   - cmd: The parent cobra command to which the exec command will be added
//
// The method panics if the embedded exec action fails to define its specific behavior.
//
// Example:
//
//        baseAction := NewArkBaseExecAction(&amp;myAction, "test", loader)
//        baseAction.DefineAction(rootCmd)
func (a *ArkBaseExecAction) DefineAction(cmd *cobra.Command) <span class="cov5" title="7">{
        execCmd := &amp;cobra.Command{
                Use:   "exec",
                Short: "Exec an action",
        }
        execCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                a.CommonActionsExecution(cmd, args)
        }</span>
        <span class="cov5" title="7">a.CommonActionsConfiguration(execCmd)

        execCmd.PersistentFlags().String("profile-name", profiles.DefaultProfileName(), "Profile name to load")
        execCmd.PersistentFlags().String("output-path", "", "Output file to write data to")
        execCmd.PersistentFlags().String("request-file", "", "Request file containing the parameters for the exec action")
        execCmd.PersistentFlags().Int("retry-count", 1, "Retry count for execution")
        execCmd.PersistentFlags().Bool("refresh-auth", false, "If a cache exists, will also try to refresh it")
        err := (*a.execAction).DefineExecAction(execCmd)
        if err != nil </span><span class="cov1" title="1">{
                args.PrintFailure(fmt.Sprintf("Error defining exec action %v", err))
                panic(err)</span>
        }
        <span class="cov4" title="5">cmd.AddCommand(execCmd)</span>
}

// runExecAction executes the configured action with profile-based authentication.
//
// runExecAction orchestrates the complete execution flow including profile loading,
// authentication validation, API client creation, and action execution with retry logic.
// The method performs the following steps:
//  1. Locates the exec command in the command hierarchy
//  2. Loads the specified authentication profile
//  3. Validates and loads available authenticators
//  4. Creates an authenticated CLI API client
//  5. Executes the action with configured retry logic
//
// The method handles authentication token expiration and provides user feedback
// for authentication status. If not all authenticators are available, it warns
// the user that some functionality may be disabled.
//
// Parameters:
//   - cmd: The root command being executed
//   - execArgs: Command line arguments passed to the exec action
//
// The method prints failure messages and returns early if any critical step fails,
// including profile loading, authentication, or API client creation.
func (a *ArkBaseExecAction) runExecAction(cmd *cobra.Command, execArgs []string) <span class="cov5" title="7">{
        a.CommonActionsExecution(cmd, execArgs)
        var execCmd *cobra.Command
        currentCmd := cmd
        for currentCmd != nil </span><span class="cov5" title="7">{
                if currentCmd.Use == "exec" </span><span class="cov5" title="6">{
                        execCmd = currentCmd
                        break</span>
                }
                <span class="cov1" title="1">currentCmd = currentCmd.Parent()</span>
        }
        <span class="cov5" title="7">if execCmd == nil </span><span class="cov1" title="1">{
                args.PrintFailure("Failed to find exec command")
                return
        }</span>
        <span class="cov5" title="6">profileName, _ := execCmd.Flags().GetString("profile-name")
        profile, err := (*a.profilesLoader).LoadProfile(profiles.DeduceProfileName(profileName))
        if err != nil || profile == nil </span><span class="cov2" title="2">{
                args.PrintFailure("Please configure a profile before trying to login")
                return
        }</span>

        <span class="cov4" title="4">var authenticators []auth.ArkAuth
        for authenticatorName := range profile.AuthProfiles </span><span class="cov4" title="4">{
                authenticator := auth.SupportedAuthenticators[authenticatorName]
                refreshAuth, _ := cmd.Flags().GetBool("refresh-auth")
                token, err := authenticator.LoadAuthentication(profile, refreshAuth)
                if err != nil || token == nil </span><span class="cov4" title="4">{
                        continue</span>
                }
                <span class="cov0" title="0">if time.Now().After(time.Time(token.ExpiresIn)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">authenticators = append(authenticators, authenticator)</span>
        }

        <span class="cov4" title="4">if len(authenticators) == 0 </span><span class="cov4" title="4">{
                args.PrintFailure("Failed to load authenticators, tokens are either expired or authenticators are not logged in, please login first")
                return
        }</span>
        <span class="cov0" title="0">if len(authenticators) != len(profile.AuthProfiles) &amp;&amp; common.IsInteractive() </span><span class="cov0" title="0">{
                args.PrintColored("Not all authenticators are logged in, some of the functionality will be disabled", color.New())
        }</span>

        // Create the CLI API with the authenticators
        <span class="cov0" title="0">api, err := cli.NewArkCLIAPI(authenticators, profile)
        if err != nil </span><span class="cov0" title="0">{
                args.PrintFailure(fmt.Sprintf("Failed to create CLI API: %s", err))
                return
        }</span>

        // Run the actual exec fitting action with the api
        // Run it with retries as per defined by user
        <span class="cov0" title="0">retryCount, _ := execCmd.Flags().GetInt("retry-count")
        err = common.RetryCall(func() error </span><span class="cov0" title="0">{
                return (*a.execAction).RunExecAction(api, cmd, execCmd, execArgs)
        }</span>, retryCount, 1, nil, 1, 0, func(err error, delay int) <span class="cov0" title="0">{
                args.PrintFailure(fmt.Sprintf("Retrying in %d seconds", delay))
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                args.PrintFailure(fmt.Sprintf("Failed to execute action: %s", err))
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package actions

import (
        "encoding/json"
        "fmt"
        "slices"

        "github.com/cyberark/ark-sdk-golang/pkg/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/auth/identity"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/common/args"
        authmodels "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// ArkLoginAction is a struct that implements the ArkAction interface for login action.
//
// ArkLoginAction provides authentication functionality for the Ark SDK CLI.
// It handles user authentication across multiple authentication methods and
// manages token storage and retrieval. The action supports interactive and
// non-interactive modes, shared secrets between authenticators, token refresh,
// and forced re-authentication.
//
// Key features:
//   - Multi-authenticator support (e.g., ISP, identity providers)
//   - Interactive credential prompting with shared secrets
//   - Token caching and refresh capabilities
//   - Force login and token display options
//   - Profile-based configuration management
type ArkLoginAction struct {
        *ArkBaseAction
        profilesLoader *profiles.ProfileLoader
}

// NewArkLoginAction creates a new instance of ArkLoginAction.
//
// NewArkLoginAction initializes a new ArkLoginAction with the provided profile
// loader for managing authentication profiles. The action inherits common
// functionality from ArkBaseAction and configures profile-specific behavior.
//
// Parameters:
//   - profilesLoader: A ProfileLoader interface for loading and managing authentication profiles
//
// Returns a new ArkLoginAction instance ready for CLI integration.
//
// Example:
//
//        loader := profiles.DefaultProfilesLoader()
//        action := NewArkLoginAction(loader)
//        action.DefineAction(rootCmd)
func NewArkLoginAction(profilesLoader *profiles.ProfileLoader) *ArkLoginAction <span class="cov10" title="15">{
        return &amp;ArkLoginAction{
                ArkBaseAction:  NewArkBaseAction(),
                profilesLoader: profilesLoader,
        }
}</span>

// DefineAction defines the CLI `login` action, and adds the login function.
//
// DefineAction configures the login command with all necessary flags and
// behavior for authentication operations. The command supports various
// authentication options including profile selection, forced login,
// shared secrets management, token display, and refresh capabilities.
//
// Command flags added:
//   - profile-name: Specifies which profile to use for authentication
//   - force: Forces login even if valid tokens exist
//   - no-shared-secrets: Disables credential sharing between authenticators
//   - show-tokens: Displays authentication tokens in output
//   - refresh-auth: Attempts to refresh existing tokens from cache
//   - [authenticator]-username: Username for specific authenticators
//   - [authenticator]-secret: Secret/password for specific authenticators
//
// Parameters:
//   - cmd: The parent cobra command to attach the login command to
//
// The login command will be added as a subcommand with all configured flags
// and will execute the authentication workflow when invoked.
//
// Example:
//
//        action := NewArkLoginAction(loader)
//        action.DefineAction(rootCmd)
//        // Now 'ark login' command is available
func (a *ArkLoginAction) DefineAction(cmd *cobra.Command) <span class="cov6" title="5">{
        loginCmd := &amp;cobra.Command{
                Use:   "login",
                Short: "Login to the system",
                Run:   a.runLoginAction,
        }
        loginCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                a.CommonActionsExecution(cmd, args)
        }</span>
        <span class="cov6" title="5">a.CommonActionsConfiguration(loginCmd)

        loginCmd.Flags().String("profile-name", profiles.DefaultProfileName(), "Profile name to load")
        loginCmd.Flags().Bool("force", false, "Whether to force login even though token has not expired yet")
        loginCmd.Flags().Bool("no-shared-secrets", false, "Do not share secrets between different authenticators with the same username")
        loginCmd.Flags().Bool("show-tokens", false, "Print out tokens as well if not silent")
        loginCmd.Flags().Bool("refresh-auth", false, "If a cache exists, will also try to refresh it")

        for _, authenticator := range auth.SupportedAuthenticatorsList </span><span class="cov6" title="5">{
                loginCmd.Flags().String(fmt.Sprintf("%s-username", authenticator.AuthenticatorName()), "", fmt.Sprintf("Username to authenticate with to %s", authenticator.AuthenticatorHumanReadableName()))
                loginCmd.Flags().String(fmt.Sprintf("%s-secret", authenticator.AuthenticatorName()), "", fmt.Sprintf("Secret to authenticate with to %s", authenticator.AuthenticatorHumanReadableName()))
        }</span>

        <span class="cov6" title="5">cmd.AddCommand(loginCmd)</span>
}

// runLoginAction executes the authentication workflow for the login command.
//
// runLoginAction handles the complete authentication process including profile
// loading, credential gathering, authentication execution, and token management.
// It supports multiple authenticators simultaneously and manages shared secrets
// between compatible authentication methods.
//
// The function performs the following operations:
//  1. Loads the specified authentication profile
//  2. Iterates through configured authenticators
//  3. Checks existing authentication status and handles refresh/force options
//  4. Gathers credentials interactively or from command flags
//  5. Executes authentication for each configured authenticator
//  6. Manages shared secrets between compatible authenticators
//  7. Displays authentication results and tokens (if requested)
//
// Parameters:
//   - cmd: The cobra command containing parsed flags and configuration
//   - loginArgs: Command line arguments (currently unused)
//
// The function handles various authentication scenarios:
//   - Skip authentication if already authenticated (unless force=true)
//   - Refresh tokens if requested and possible
//   - Interactive credential prompting in interactive mode
//   - Shared secret reuse for compatible authentication methods
//   - Special handling for identity authentication without passwords
//   - Error handling and user feedback for failed authentication attempts
//
// Example:
//   Command: ark login --profile-name prod --force --show-tokens
//   Result: Authenticates to all configured authenticators and displays tokens

func (a *ArkLoginAction) runLoginAction(cmd *cobra.Command, loginArgs []string) <span class="cov7" title="7">{
        a.CommonActionsExecution(cmd, loginArgs)

        profileName, _ := cmd.Flags().GetString("profile-name")
        profile, err := (*a.profilesLoader).LoadProfile(profiles.DeduceProfileName(profileName))
        if err != nil || profile == nil </span><span class="cov3" title="2">{
                args.PrintFailure("Please configure a profile before trying to login")
                return
        }</span>

        <span class="cov6" title="5">sharedSecretsMap := make(map[authmodels.ArkAuthMethod][][2]string)
        tokensMap := make(map[string]*authmodels.ArkToken)

        for authenticatorName, authProfile := range profile.AuthProfiles </span><span class="cov5" title="4">{
                authenticator := auth.SupportedAuthenticators[authenticatorName]
                force, _ := cmd.Flags().GetBool("force")
                refreshAuth, _ := cmd.Flags().GetBool("refresh-auth")
                if authenticator.IsAuthenticated(profile) &amp;&amp; !force </span><span class="cov0" title="0">{
                        if refreshAuth </span><span class="cov0" title="0">{
                                _, err := authenticator.LoadAuthentication(profile, true)
                                if err == nil </span><span class="cov0" title="0">{
                                        args.PrintSuccess(fmt.Sprintf("%s Authentication Refreshed", authenticator.AuthenticatorHumanReadableName()))
                                        continue</span>
                                }
                                <span class="cov0" title="0">a.logger.Info("%s Failed to refresh token, performing normal login [%s]", authenticator.AuthenticatorHumanReadableName(), err.Error())</span>
                        } else<span class="cov0" title="0"> {
                                args.PrintSuccess(fmt.Sprintf("%s Already Authenticated", authenticator.AuthenticatorHumanReadableName()))
                                continue</span>
                        }
                }
                <span class="cov5" title="4">secretStr, _ := cmd.Flags().GetString(fmt.Sprintf("%s-secret", authenticatorName))
                secret := &amp;authmodels.ArkSecret{Secret: secretStr}
                userName, _ := cmd.Flags().GetString(fmt.Sprintf("%s-username", authenticatorName))
                if userName == "" </span><span class="cov5" title="4">{
                        userName = authProfile.Username
                }</span>
                <span class="cov5" title="4">if common.IsInteractive() &amp;&amp; slices.Contains(authmodels.ArkAuthMethodsRequireCredentials, authProfile.AuthMethod) </span><span class="cov5" title="4">{
                        authProfile.Username, err = args.GetArg(
                                cmd,
                                fmt.Sprintf("%s-username", authenticatorName),
                                fmt.Sprintf("%s Username", authenticator.AuthenticatorHumanReadableName()),
                                userName,
                                false,
                                true,
                                false,
                        )
                        if slices.Contains(authmodels.ArkAuthMethodSharableCredentials, authProfile.AuthMethod) &amp;&amp; len(sharedSecretsMap[authProfile.AuthMethod]) &gt; 0 &amp;&amp; !viper.GetBool("no-shared-secrets") </span><span class="cov0" title="0">{
                                for _, s := range sharedSecretsMap[authProfile.AuthMethod] </span><span class="cov0" title="0">{
                                        if s[0] == authProfile.Username </span><span class="cov0" title="0">{
                                                secret = &amp;authmodels.ArkSecret{Secret: s[1]}
                                                break</span>
                                        }
                                }
                        } else<span class="cov5" title="4"> {
                                if authenticatorName == "isp" &amp;&amp;
                                        authProfile.AuthMethod == authmodels.Identity &amp;&amp;
                                        !identity.IsPasswordRequired(authProfile.Username,
                                                authProfile.AuthMethodSettings.(*authmodels.IdentityArkAuthMethodSettings).IdentityURL,
                                                authProfile.AuthMethodSettings.(*authmodels.IdentityArkAuthMethodSettings).IdentityTenantSubdomain) </span><span class="cov0" title="0">{
                                        secret = &amp;authmodels.ArkSecret{Secret: ""}
                                }</span> else<span class="cov5" title="4"> {
                                        secretStr, err = args.GetArg(
                                                cmd,
                                                fmt.Sprintf("%s-secret", authenticatorName),
                                                fmt.Sprintf("%s Secret", authenticator.AuthenticatorHumanReadableName()),
                                                secretStr,
                                                true,
                                                false,
                                                false,
                                        )
                                        if err != nil </span><span class="cov5" title="4">{
                                                args.PrintFailure(fmt.Sprintf("Failed to get %s secret: %s", authenticatorName, err))
                                                return
                                        }</span>
                                        <span class="cov0" title="0">secret = &amp;authmodels.ArkSecret{Secret: secretStr}</span>
                                }
                        }
                } else<span class="cov0" title="0"> if !common.IsInteractive() &amp;&amp; slices.Contains(authmodels.ArkAuthMethodsRequireCredentials, authProfile.AuthMethod) &amp;&amp; secret.Secret == "" </span><span class="cov0" title="0">{
                        args.PrintFailure(fmt.Sprintf("%s-secret argument is required if authenticating to %s", authenticatorName, authenticator.AuthenticatorHumanReadableName()))
                        return
                }</span>

                <span class="cov0" title="0">token, err := authenticator.Authenticate(profile, nil, secret, force, refreshAuth)
                if err != nil </span><span class="cov0" title="0">{
                        args.PrintFailure(fmt.Sprintf("Failed to authenticate with %s: %s", authenticator.AuthenticatorHumanReadableName(), err))
                        return
                }</span>

                <span class="cov0" title="0">noSharedSecrets, _ := cmd.Flags().GetBool("no-shared-secrets")
                if !noSharedSecrets &amp;&amp; slices.Contains(authmodels.ArkAuthMethodSharableCredentials, authProfile.AuthMethod) </span><span class="cov0" title="0">{
                        sharedSecretsMap[authProfile.AuthMethod] = append(sharedSecretsMap[authProfile.AuthMethod], [2]string{authProfile.Username, secret.Secret})
                }</span>
                <span class="cov0" title="0">tokensMap[authenticator.AuthenticatorHumanReadableName()] = token</span>
        }
        <span class="cov1" title="1">showTokens, _ := cmd.Flags().GetBool("show-tokens")
        if !showTokens &amp;&amp; len(tokensMap) &gt; 0 </span><span class="cov0" title="0">{
                args.PrintSuccess("Login tokens are hidden")
        }</span>

        <span class="cov1" title="1">for k, v := range tokensMap </span><span class="cov0" title="0">{
                if v.Metadata != nil </span><span class="cov0" title="0">{
                        if _, ok := v.Metadata["cookies"]; ok </span><span class="cov0" title="0">{
                                delete(v.Metadata, "cookies")
                        }</span>
                }
                <span class="cov0" title="0">tokenMap := make(map[string]interface{})
                data, _ := json.Marshal(v)
                _ = json.Unmarshal(data, &amp;tokenMap)
                if !showTokens </span><span class="cov0" title="0">{
                        delete(tokenMap, "token")
                        delete(tokenMap, "refresh_token")
                }</span>
                <span class="cov0" title="0">jsonData, _ := json.MarshalIndent(tokenMap, "", "  ")
                args.PrintSuccess(fmt.Sprintf("%s Token\n%s", k, jsonData))</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package actions

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "regexp"

        "github.com/Iilun/survey/v2"

        "github.com/confluentinc/go-editor"
        commonargs "github.com/cyberark/ark-sdk-golang/pkg/common/args"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/spf13/cobra"
)

// ArkProfilesAction is a struct that implements the ArkAction interface for managing CLI profiles.
//
// ArkProfilesAction provides functionality for managing multiple CLI configuration profiles
// including listing, showing, deleting, clearing, cloning, adding, and editing profiles.
// It handles profile operations through a ProfileLoader and provides both interactive
// and non-interactive modes for various operations.
//
// The action supports comprehensive profile management operations:
//   - List profiles with optional filtering by name pattern or auth type
//   - Show detailed profile information
//   - Delete specific profiles with confirmation prompts
//   - Clear all profiles with confirmation
//   - Clone profiles with automatic or custom naming
//   - Add profiles from file paths
//   - Edit profiles interactively using an external editor
type ArkProfilesAction struct {
        // ArkBaseAction provides common action functionality
        *ArkBaseAction
        // profilesLoader handles loading and saving of profile configurations
        profilesLoader *profiles.ProfileLoader
}

// NewArkProfilesAction creates a new instance of ArkProfilesAction.
//
// NewArkProfilesAction initializes a new ArkProfilesAction with the provided
// profile loader and an embedded ArkBaseAction for common CLI functionality.
// The profile loader is used for all profile operations including loading,
// saving, deleting, and managing profile configurations.
//
// Parameters:
//   - profilesLoader: A pointer to a ProfileLoader for handling profile operations
//
// Returns a new ArkProfilesAction instance ready for defining profile management commands.
//
// Example:
//
//        loader := profiles.NewProfileLoader()
//        profilesAction := NewArkProfilesAction(loader)
//        profilesAction.DefineAction(rootCmd)
func NewArkProfilesAction(profilesLoader *profiles.ProfileLoader) *ArkProfilesAction <span class="cov10" title="28">{
        return &amp;ArkProfilesAction{
                ArkBaseAction:  NewArkBaseAction(),
                profilesLoader: profilesLoader,
        }
}</span>

// DefineAction defines the CLI profiles action and adds profile management commands.
//
// DefineAction creates a "profiles" command that provides comprehensive profile management
// functionality. The command includes multiple subcommands for different profile operations,
// each with their own flags and functionality.
//
// The function creates the following subcommands:
//   - list: Lists all profiles with optional filtering by name pattern or auth type
//   - show: Shows detailed information for a specific profile
//   - delete: Deletes a specific profile with confirmation
//   - clear: Clears all profiles with confirmation
//   - clone: Clones an existing profile with optional renaming
//   - add: Adds a profile from a file path
//   - edit: Opens a profile for interactive editing
//
// Parameters:
//   - cmd: The parent cobra command to which the profiles command will be added
//
// Each subcommand includes appropriate flags for configuration and supports both
// interactive and non-interactive modes where applicable.
//
// Example:
//
//        profilesAction := NewArkProfilesAction(loader)
//        profilesAction.DefineAction(rootCmd)
//        // This adds: myapp profiles [list|show|delete|clear|clone|add|edit] [flags]
func (a *ArkProfilesAction) DefineAction(cmd *cobra.Command) <span class="cov5" title="6">{
        profileCmd := &amp;cobra.Command{
                Use:   "profiles",
                Short: "Manage profiles",
        }
        profileCmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                a.CommonActionsExecution(cmd, args)
        }</span>
        <span class="cov5" title="6">a.CommonActionsConfiguration(profileCmd)

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List all profiles",
                Run:   a.runListAction,
        }
        listCmd.Flags().StringP("name", "", "", "Profile name to filter with by wildcard")
        listCmd.Flags().StringP("auth-profile", "", "", "Filter profiles by auth types")
        listCmd.Flags().BoolP("all", "", false, "Whether to show all profiles data as well and not only their names")

        showCmd := &amp;cobra.Command{
                Use:   "show",
                Short: "Show a profile",
                Run:   a.runShowAction,
        }
        showCmd.Flags().StringP("profile-name", "", "", "Profile name to show, if not given, shows the current one")

        deleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Delete a specific profile",
                Run:   a.runDeleteAction,
        }
        deleteCmd.Flags().StringP("profile-name", "", "", "Profile name to delete")
        deleteCmd.Flags().BoolP("yes", "", false, "Whether to approve deletion non interactively")

        clearCmd := &amp;cobra.Command{
                Use:   "clear",
                Short: "Clear all profiles",
                Run:   a.runClearAction,
        }
        clearCmd.Flags().BoolP("yes", "", false, "Whether to approve clear non interactively")

        cloneCmd := &amp;cobra.Command{
                Use:   "clone",
                Short: "Clone a profile",
                Run:   a.runCloneAction,
        }
        cloneCmd.Flags().StringP("profile-name", "", "", "Profile name to clone")
        cloneCmd.Flags().StringP("new-profile-name", "", "", "New cloned profile name, if not given, will add _clone as part of the name")
        cloneCmd.Flags().BoolP("yes", "", false, "Whether to override existing profile if exists")

        addCmd := &amp;cobra.Command{
                Use:   "add",
                Short: "Add a profile from a given path",
                Run:   a.runAddAction,
        }
        addCmd.Flags().StringP("profile-path", "", "", "Profile file path to be added")

        editCmd := &amp;cobra.Command{
                Use:   "edit",
                Short: "Edit a profile interactively",
                Run:   a.runEditAction,
        }
        editCmd.Flags().StringP("profile-name", "", "", "Profile name to edit, if not given, edits the current one")

        profileCmd.AddCommand(listCmd, showCmd, deleteCmd, clearCmd, cloneCmd, addCmd, editCmd)
        cmd.AddCommand(profileCmd)</span>
}

// runListAction handles the profiles list command execution.
//
// runListAction loads all available profiles and displays them based on the provided
// filtering criteria and output format options. It supports filtering by name pattern
// using regex matching and by authentication profile type.
//
// The function performs the following operations:
//  1. Loads all profiles using the profile loader
//  2. Applies name-based filtering using regex pattern matching
//  3. Applies auth-profile filtering by checking profile auth configurations
//  4. Outputs either profile names only or full profile data based on --all flag
//
// Parameters:
//   - cmd: The cobra command containing flag values for filtering and output options
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - name: Regex pattern to filter profile names
//   - auth-profile: Filter profiles by specific auth type
//   - all: Show full profile data instead of just names
//
// The function prints warnings if no profiles are found and outputs JSON-formatted
// results for successful operations.

func (a *ArkProfilesAction) runListAction(cmd *cobra.Command, args []string) <span class="cov5" title="6">{
        // Start by loading all the profiles
        loadedProfiles, err := (*a.profilesLoader).LoadAllProfiles()
        if err != nil || len(loadedProfiles) == 0 </span><span class="cov2" title="2">{
                commonargs.PrintWarning("No loadedProfiles were found")
                return
        }</span>

        // Filter profiles
        <span class="cov4" title="4">name, _ := cmd.Flags().GetString("name")
        if name != "" </span><span class="cov1" title="1">{
                var filtered []*models.ArkProfile
                for _, p := range loadedProfiles </span><span class="cov2" title="2">{
                        if matched, err := regexp.MatchString(name, p.ProfileName); err == nil &amp;&amp; matched </span><span class="cov1" title="1">{
                                filtered = append(filtered, p)
                        }</span>
                }
                <span class="cov1" title="1">loadedProfiles = filtered</span>
        }

        <span class="cov4" title="4">authProfile, _ := cmd.Flags().GetString("auth-profile")
        if authProfile != "" </span><span class="cov1" title="1">{
                var filtered []*models.ArkProfile
                for _, p := range loadedProfiles </span><span class="cov2" title="2">{
                        if _, ok := p.AuthProfiles[authProfile]; ok </span><span class="cov0" title="0">{
                                filtered = append(filtered, p)
                        }</span>
                }
                <span class="cov1" title="1">loadedProfiles = filtered</span>
        }

        // Print them based on request
        <span class="cov4" title="4">showAll, _ := cmd.Flags().GetBool("all")
        if showAll </span><span class="cov1" title="1">{
                data, _ := json.MarshalIndent(loadedProfiles, "", "  ")
                commonargs.PrintSuccess(string(data))
        }</span> else<span class="cov3" title="3"> {
                names := []string{}
                for _, p := range loadedProfiles </span><span class="cov3" title="3">{
                        names = append(names, p.ProfileName)
                }</span>
                <span class="cov3" title="3">data, _ := json.MarshalIndent(names, "", "  ")
                commonargs.PrintSuccess(string(data))</span>
        }
}

// runShowAction handles the profiles show command execution.
//
// runShowAction displays detailed information for a specific profile. If no profile
// name is provided, it uses the default profile name deduction logic to determine
// which profile to show.
//
// Parameters:
//   - cmd: The cobra command containing the profile-name flag
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - profile-name: Name of the profile to show (optional, defaults to current profile)
//
// The function prints a warning if the specified profile is not found, otherwise
// it outputs the profile data in JSON format.
func (a *ArkProfilesAction) runShowAction(cmd *cobra.Command, args []string) <span class="cov3" title="3">{
        profileName, _ := cmd.Flags().GetString("profile-name")
        if profileName == "" </span><span class="cov1" title="1">{
                profileName = profiles.DeduceProfileName("")
        }</span>

        <span class="cov3" title="3">profile, err := (*a.profilesLoader).LoadProfile(profileName)
        if err != nil </span><span class="cov1" title="1">{
                commonargs.PrintWarning(fmt.Sprintf("No profile was found for the name %s", profileName))
                return
        }</span>

        <span class="cov2" title="2">data, _ := json.MarshalIndent(profile, "", "  ")
        commonargs.PrintSuccess(string(data))</span>
}

// runDeleteAction handles the profiles delete command execution.
//
// runDeleteAction deletes a specific profile after loading it and optionally
// prompting for user confirmation. The function includes safety checks to
// ensure the profile exists before attempting deletion.
//
// Parameters:
//   - cmd: The cobra command containing the profile-name and yes flags
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - profile-name: Name of the profile to delete (required)
//   - yes: Skip confirmation prompt for non-interactive deletion
//
// The function prints warnings if the profile is not found and uses interactive
// confirmation unless the --yes flag is provided.
func (a *ArkProfilesAction) runDeleteAction(cmd *cobra.Command, args []string) <span class="cov3" title="3">{
        profileName, _ := cmd.Flags().GetString("profile-name")
        profile, err := (*a.profilesLoader).LoadProfile(profileName)
        if err != nil || profile == nil </span><span class="cov1" title="1">{
                commonargs.PrintWarning(fmt.Sprintf("No profile was found for the name %s", profileName))
                return
        }</span>

        <span class="cov2" title="2">yes, _ := cmd.Flags().GetBool("yes")
        if !yes </span><span class="cov0" title="0">{
                confirm := false
                prompt := &amp;survey.Confirm{
                        Message: fmt.Sprintf("Are you sure you want to delete profile %s?", profileName),
                }
                err := survey.AskOne(prompt, &amp;confirm)
                if err != nil || !confirm </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov2" title="2">err = (*a.profilesLoader).DeleteProfile(profileName)
        if err != nil </span><span class="cov1" title="1">{
                return
        }</span>
}

// runClearAction handles the profiles clear command execution.
//
// runClearAction clears all profiles after optionally prompting for user
// confirmation. This is a destructive operation that removes all stored
// profile configurations.
//
// Parameters:
//   - cmd: The cobra command containing the yes flag
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - yes: Skip confirmation prompt for non-interactive clearing
//
// The function uses interactive confirmation unless the --yes flag is provided
// to prevent accidental deletion of all profiles.
func (a *ArkProfilesAction) runClearAction(cmd *cobra.Command, args []string) <span class="cov2" title="2">{
        yes, _ := cmd.Flags().GetBool("yes")
        if !yes </span><span class="cov0" title="0">{
                confirm := false
                prompt := &amp;survey.Confirm{
                        Message: "Are you sure you want to clear all profiles?",
                }
                err := survey.AskOne(prompt, &amp;confirm)
                if err != nil || !confirm </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov2" title="2">err := (*a.profilesLoader).ClearAllProfiles()
        if err != nil </span><span class="cov1" title="1">{
                return
        }</span>
}

// runCloneAction handles the profiles clone command execution.
//
// runCloneAction creates a copy of an existing profile with a new name. If no
// new name is provided, it automatically appends "_clone" to the original name.
// The function includes logic to handle name conflicts with existing profiles.
//
// Parameters:
//   - cmd: The cobra command containing profile-name, new-profile-name, and yes flags
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - profile-name: Name of the profile to clone (required)
//   - new-profile-name: Name for the cloned profile (optional, defaults to original_clone)
//   - yes: Skip confirmation prompt when overwriting existing profiles
//
// The function prompts for confirmation if the target profile name already exists
// unless the --yes flag is provided.
func (a *ArkProfilesAction) runCloneAction(cmd *cobra.Command, args []string) <span class="cov4" title="4">{
        profileName, _ := cmd.Flags().GetString("profile-name")
        profile, err := (*a.profilesLoader).LoadProfile(profileName)
        if err != nil </span><span class="cov1" title="1">{
                commonargs.PrintWarning(fmt.Sprintf("No profile was found for the name %s", profileName))
                return
        }</span>

        <span class="cov3" title="3">newProfileName, _ := cmd.Flags().GetString("new-profile-name")
        if newProfileName == "" </span><span class="cov2" title="2">{
                newProfileName = profileName + "_clone"
        }</span>

        <span class="cov3" title="3">clonedProfile := profile
        clonedProfile.ProfileName = newProfileName

        if (*a.profilesLoader).ProfileExists(newProfileName) </span><span class="cov0" title="0">{
                yes, _ := cmd.Flags().GetBool("yes")
                if !yes </span><span class="cov0" title="0">{
                        confirm := false
                        prompt := &amp;survey.Confirm{
                                Message: fmt.Sprintf("Profile %s already exists, do you want to override it?", newProfileName),
                        }
                        err := survey.AskOne(prompt, &amp;confirm)
                        if err != nil || !confirm </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
        <span class="cov3" title="3">err = (*a.profilesLoader).SaveProfile(clonedProfile)
        if err != nil </span><span class="cov1" title="1">{
                return
        }</span>
}

// runAddAction handles the profiles add command execution.
//
// runAddAction adds a profile from a specified file path by reading and parsing
// the JSON profile data. The function includes validation to ensure the file
// exists and contains valid profile data.
//
// Parameters:
//   - cmd: The cobra command containing the profile-path flag
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - profile-path: File system path to the profile JSON file (required)
//
// The function validates file existence, reads the file content, unmarshals
// the JSON data into a profile structure, and saves it using the profile loader.
// It prints appropriate warnings and failures for various error conditions.
func (a *ArkProfilesAction) runAddAction(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        profilePath, _ := cmd.Flags().GetString("profile-path")
        if _, err := os.Stat(profilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                commonargs.PrintWarning(fmt.Sprintf("Profile path [%s] does not exist, ignoring", profilePath))
                return
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(profilePath); err == nil </span><span class="cov0" title="0">{
                data, err := os.ReadFile(profilePath)
                if err != nil </span><span class="cov0" title="0">{
                        commonargs.PrintFailure(fmt.Sprintf("Profile path [%s] failed to be read, aborting", profilePath))
                        return
                }</span>
                <span class="cov0" title="0">var profile *models.ArkProfile
                if err = json.Unmarshal(data, &amp;profile); err != nil </span><span class="cov0" title="0">{
                        commonargs.PrintFailure(fmt.Sprintf("Profile path [%s] failed to be parsed, aborting", profilePath))
                        return
                }</span>
                <span class="cov0" title="0">err = (*a.profilesLoader).SaveProfile(profile)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">commonargs.PrintFailure(fmt.Sprintf("Profile path [%s] does not exist", profilePath))</span>
}

// runEditAction handles the profiles edit command execution.
//
// runEditAction opens a profile for interactive editing using an external editor.
// The profile data is marshaled to JSON, opened in a temporary file for editing,
// and then parsed back and saved after the user completes editing.
//
// Parameters:
//   - cmd: The cobra command containing the profile-name flag
//   - args: Command line arguments (not currently used)
//
// Supported flags:
//   - profile-name: Name of the profile to edit (optional, defaults to current profile)
//
// The function creates a temporary JSON file, launches the configured editor,
// waits for the user to complete editing, parses the modified content, and
// saves the updated profile. It includes cleanup logic to remove temporary files
// and comprehensive error handling for various failure scenarios.
func (a *ArkProfilesAction) runEditAction(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        profileName, _ := cmd.Flags().GetString("profile-name")
        if profileName == "" </span><span class="cov0" title="0">{
                profileName = profiles.DeduceProfileName("")
        }</span>

        <span class="cov0" title="0">profile, err := (*a.profilesLoader).LoadProfile(profileName)
        if err != nil </span><span class="cov0" title="0">{
                commonargs.PrintWarning(fmt.Sprintf("No profile was found for the name %s", profileName))
                return
        }</span>
        <span class="cov0" title="0">edit := editor.NewEditor()
        data, err := json.Marshal(profile)
        if err != nil </span><span class="cov0" title="0">{
                commonargs.PrintFailure(fmt.Sprintf("Failed to marshal profile: %s", err))
                return
        }</span>
        <span class="cov0" title="0">edited, path, err := edit.LaunchTempFile(fmt.Sprintf("%s-temp.json", profile.ProfileName), bytes.NewBufferString(string(data)))
        defer func(name string) </span><span class="cov0" title="0">{
                err := os.Remove(name)
                if err != nil </span><span class="cov0" title="0">{
                        commonargs.PrintWarning(fmt.Sprintf("Failed to remove temp file: %s", err))
                }</span>
        }(path)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                commonargs.PrintFailure(fmt.Sprintf("Failed to launch editor: %s", err))
                return
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(edited, &amp;profile)
        if err != nil </span><span class="cov0" title="0">{
                commonargs.PrintFailure(fmt.Sprintf("Failed to unmarshal edited profile: %s", err))
                return
        }</span>
        <span class="cov0" title="0">err = (*a.profilesLoader).SaveProfile(profile)
        if err != nil </span><span class="cov0" title="0">{
                commonargs.PrintWarning(fmt.Sprintf("Failed to save edited profile: %s", err))
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package actions

import (
        "encoding/json"
        "fmt"
        "os"
        "reflect"
        "slices"
        "strings"

        "github.com/cyberark/ark-sdk-golang/pkg/common"

        "github.com/cyberark/ark-sdk-golang/pkg/cli"
        "github.com/cyberark/ark-sdk-golang/pkg/common/args"
        "github.com/cyberark/ark-sdk-golang/pkg/models/actions"
        "github.com/cyberark/ark-sdk-golang/pkg/models/actions/services"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/mitchellh/mapstructure"
        "github.com/octago/sflags"
        "github.com/octago/sflags/gen/gpflag"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

// ArkServiceExecAction is a struct that implements the ArkExecAction interface for executing service actions.
//
// ArkServiceExecAction provides functionality for dynamically executing service actions
// based on service action definitions. It handles the parsing of command-line flags,
// schema validation, method invocation, and output serialization for service operations.
//
// The action supports:
//   - Dynamic command generation from service action definitions
//   - Complex type parsing for JSON and array inputs
//   - Flag validation with choices and required field checking
//   - Method reflection and invocation on service APIs
//   - Multiple output format serialization (JSON, primitive types, channels)
//   - Request file input support for complex payloads
type ArkServiceExecAction struct {
        // ArkExecAction interface for execution capabilities
        ArkExecAction
        // ArkBaseExecAction provides common execution functionality
        *ArkBaseExecAction
}

// NewArkServiceExecAction creates a new instance of ArkServiceExecAction.
//
// NewArkServiceExecAction initializes a new ArkServiceExecAction with the provided
// profile loader and embedded ArkBaseExecAction for common execution functionality.
// The action is configured with reflection-based method invocation capabilities
// for dynamic service action execution.
//
// Parameters:
//   - profilesLoader: A pointer to a ProfileLoader for handling profile operations
//
// Returns a new ArkServiceExecAction instance ready for defining and executing
// service commands.
//
// Example:
//
//        loader := profiles.NewProfileLoader()
//        serviceExecAction := NewArkServiceExecAction(loader)
//        serviceExecAction.DefineExecAction(rootCmd)
func NewArkServiceExecAction(profilesLoader *profiles.ProfileLoader) *ArkServiceExecAction <span class="cov5" title="32">{
        action := &amp;ArkServiceExecAction{}
        var actionInterface ArkExecAction = action
        baseAction := NewArkBaseExecAction(&amp;actionInterface, "ArkServiceExecAction", profilesLoader)
        action.ArkBaseExecAction = baseAction
        return action
}</span>

// isComplexType determines if a struct field represents a complex type requiring JSON parsing.
//
// isComplexType checks if the field is a map[string]struct or slice/array of structs,
// which require special handling during flag parsing as they need to be parsed from
// JSON strings rather than simple flag values.
//
// Parameters:
//   - field: The reflect.StructField to check for complexity
//
// Returns true if the field is a complex type (map[string]struct or []struct),
// false otherwise.
func (s *ArkServiceExecAction) isComplexType(field reflect.StructField) bool <span class="cov8" title="643">{
        if field.Type.Kind() == reflect.Map &amp;&amp; field.Type.Key().Kind() == reflect.String &amp;&amp; field.Type.Elem().Kind() == reflect.Struct </span><span class="cov2" title="3">{
                return true
        }</span>
        <span class="cov8" title="640">if (field.Type.Kind() == reflect.Slice || field.Type.Kind() == reflect.Array) &amp;&amp; field.Type.Elem().Kind() == reflect.Struct </span><span class="cov4" title="20">{
                return true
        }</span>
        <span class="cov8" title="620">return false</span>
}

// fillRemainingSchema adds flags for complex types and squashed struct fields.
//
// fillRemainingSchema processes a schema struct and adds command-line flags for
// complex types (maps and slices of structs) that require JSON parsing, and
// recursively processes squashed struct fields to flatten their fields into
// the parent command's flag set.
//
// Parameters:
//   - schema: The schema interface to process for flag generation
//   - flags: The pflag.FlagSet to add the generated flags to
//
// The function handles:
//   - Complex types by adding string flags with JSON parsing hints
//   - Squashed struct fields by recursively processing embedded structs
//   - Flag naming from struct tags (flag, mapstructure, or field name)
//   - Description enhancement for complex types
func (s *ArkServiceExecAction) fillRemainingSchema(schema interface{}, flags *pflag.FlagSet) <span class="cov7" title="192">{
        schemaType := reflect.TypeOf(schema).Elem()
        for i := 0; i &lt; schemaType.NumField(); i++ </span><span class="cov8" title="631">{
                field := schemaType.Field(i)

                // Skip unexported fields
                if field.PkgPath != "" &amp;&amp; !field.Anonymous </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="631">if s.isComplexType(field) </span><span class="cov4" title="18">{
                        flagName := field.Tag.Get("flag")
                        if flagName == "" </span><span class="cov3" title="6">{
                                flagName = field.Tag.Get("mapstructure")
                        }</span>
                        <span class="cov4" title="18">if flagName == "" </span><span class="cov0" title="0">{
                                flagName = field.Name
                        }</span>
                        <span class="cov4" title="18">desc := field.Tag.Get("desc")
                        if desc != "" </span><span class="cov4" title="18">{
                                desc += " (This is a complex type and will be parsed as JSON or array of JSONs)"
                        }</span>
                        <span class="cov4" title="18">flags.String(flagName, field.Tag.Get("default"), desc)</span>
                }
                <span class="cov8" title="631">if field.Tag.Get("mapstructure") == ",squash" </span><span class="cov5" title="27">{
                        // If the field is a struct with the `squash` tag, we need to add its fields as flags
                        subSchema := reflect.New(field.Type).Interface()
                        s.fillRemainingSchema(subSchema, flags)
                }</span>
        }
}

// defineServiceExecAction creates a cobra command for a service action definition.
//
// defineServiceExecAction processes a service action definition and creates the
// corresponding cobra command with subcommands for each schema. It handles flag
// generation, validation, and default value assignment based on struct tags.
//
// Parameters:
//   - actionDef: The service action definition to process
//   - cmd: The parent cobra command to add the action command to
//   - parentActionsDef: Slice of parent action definitions for nested actions
//
// Returns the created action command and any error encountered during processing.
//
// The function handles:
//   - Command creation with proper naming from action definitions
//   - Schema-based subcommand generation
//   - Flag parsing using sflags library
//   - Required field marking based on validation tags
//   - Default value assignment from struct tags
func (s *ArkServiceExecAction) defineServiceExecAction(
        actionDef *actions.ArkServiceActionDefinition,
        cmd *cobra.Command,
        parentActionsDef []*actions.ArkServiceActionDefinition,
) (*cobra.Command, error) <span class="cov5" title="39">{
        actionCmd := &amp;cobra.Command{
                Use: actionDef.ActionName,
        }

        actionDest := actionDef.ActionName
        if len(parentActionsDef) &gt; 0 </span><span class="cov5" title="28">{
                for _, p := range parentActionsDef </span><span class="cov5" title="32">{
                        actionDest += "_" + p.ActionName
                }</span>
                <span class="cov5" title="28">actionDest += "_" + actionDef.ActionName</span>
        }

        <span class="cov5" title="39">if len(actionDef.Schemas) &gt; 0 </span><span class="cov5" title="32">{
                for actionName, schema := range actionDef.Schemas </span><span class="cov7" title="207">{
                        subCmd := &amp;cobra.Command{
                                Use: actionName,
                                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                                        if help, _ := cmd.Flags().GetBool("help"); help </span><span class="cov0" title="0">{
                                                _ = cmd.Help()
                                                return
                                        }</span>
                                        <span class="cov0" title="0">s.runExecAction(cmd, args)</span>
                                },
                        }
                        <span class="cov7" title="207">if schema != nil </span><span class="cov7" title="163">{
                                flags, err := sflags.ParseStruct(schema)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Error("Error parsing flags to ArkAuthMethod settings %v", err)
                                        return nil, err
                                }</span>
                                <span class="cov7" title="163">gpflag.GenerateTo(flags, subCmd.Flags())
                                s.fillRemainingSchema(schema, subCmd.Flags())
                                reflectedSchema := reflect.TypeOf(schema).Elem()
                                // We find the field by the flag name
                                // There might be a misalignment between the flag name and the field name case wise
                                // So we first try to find the field by the flag name
                                // And then try to find it with ignore case
                                for _, flag := range flags </span><span class="cov9" title="807">{
                                        flagNameTitled := strings.Replace(strings.Title(flag.Name), "-", "", -1)
                                        field, ok := reflectedSchema.FieldByName(flagNameTitled)
                                        if !ok </span><span class="cov8" title="399">{
                                                fieldFound := false
                                                for i := 0; i &lt; reflectedSchema.NumField(); i++ </span><span class="cov10" title="1496">{
                                                        possibleField := reflectedSchema.Field(i)
                                                        if strings.EqualFold(possibleField.Name, flagNameTitled) </span><span class="cov7" title="133">{
                                                                field = possibleField
                                                                fieldFound = true
                                                                break</span>
                                                        }
                                                }
                                                <span class="cov8" title="399">if !fieldFound </span><span class="cov7" title="266">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov8" title="541">if strings.Contains(field.Tag.Get("validate"), "required") </span><span class="cov6" title="91">{
                                                err = subCmd.MarkFlagRequired(flag.Name)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, err
                                                }</span>
                                        }
                                        <span class="cov8" title="541">if field.Tag.Get("default") != "" </span><span class="cov6" title="89">{
                                                subCmd.Flag(flag.Name).DefValue = field.Tag.Get("default")
                                                err = subCmd.Flag(flag.Name).Value.Set(field.Tag.Get("default"))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, err
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov7" title="207">actionCmd.AddCommand(subCmd)</span>
                }
        }

        <span class="cov5" title="39">cmd.AddCommand(actionCmd)
        return actionCmd, nil</span>
}

// defineServiceExecActions recursively defines service execution actions and their subactions.
//
// defineServiceExecActions processes a service action definition and its nested
// subactions, creating a hierarchy of cobra commands. It recursively processes
// subactions to build a complete command tree structure.
//
// Parameters:
//   - actionDef: The service action definition to process
//   - cmd: The parent cobra command to add actions to
//   - parentActionsDef: Slice of parent action definitions for context
//
// Returns an error if any action definition processing fails.
//
// The function handles:
//   - Primary action definition processing through defineServiceExecAction
//   - Recursive subaction processing for nested command structures
//   - Error propagation from nested action creation
func (s *ArkServiceExecAction) defineServiceExecActions(
        actionDef *actions.ArkServiceActionDefinition,
        cmd *cobra.Command,
        parentActionsDef []*actions.ArkServiceActionDefinition,
) error <span class="cov5" title="36">{
        actionSubparsers, err := s.defineServiceExecAction(actionDef, cmd, parentActionsDef)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="36">if len(actionDef.Subactions) &gt; 0 </span><span class="cov3" title="8">{
                for _, subaction := range actionDef.Subactions </span><span class="cov5" title="27">{
                        err = s.defineServiceExecActions(subaction, actionSubparsers, append(parentActionsDef, actionDef))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov5" title="36">return nil</span>
}

// fillParsedFlag processes complex flag values and validates choices for schema fields.
//
// fillParsedFlag handles the parsing of complex types (JSON objects and arrays)
// from string flag values and validates that field values match defined choices
// constraints. It processes mapstructure tags to find matching schema fields
// and applies appropriate transformations and validations.
//
// Parameters:
//   - schemaElem: The reflect.Type of the schema struct to process
//   - flags: Map of flag names to values being processed
//   - key: The specific flag key being processed
//   - f: The pflag.Flag being processed for error reporting
//
// Returns an error if JSON parsing fails or choice validation fails.
//
// The function handles:
//   - JSON unmarshaling for complex map and slice types
//   - Choice validation for string, string slice, and map types
//   - Recursive processing of squashed struct fields
//   - Error reporting with context about which flag failed
func (s *ArkServiceExecAction) fillParsedFlag(schemaElem reflect.Type, flags map[string]interface{}, key string, f *pflag.Flag) error <span class="cov3" title="6">{
        for i := 0; i &lt; schemaElem.NumField(); i++ </span><span class="cov5" title="35">{
                field := schemaElem.Field(i)
                if strings.HasPrefix(field.Tag.Get("mapstructure"), key) </span><span class="cov2" title="5">{
                        if s.isComplexType(field) </span><span class="cov1" title="2">{
                                if field.Type.Kind() == reflect.Map &amp;&amp; field.Type.Key().Kind() == reflect.String &amp;&amp; field.Type.Elem().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                        var mapJSON map[string]interface{}
                                        err := json.Unmarshal([]byte(flags[key].(string)), &amp;mapJSON)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">flags[key] = mapJSON</span>
                                } else<span class="cov1" title="2"> {
                                        var sliceJSON []map[string]interface{}
                                        err := json.Unmarshal([]byte(flags[key].(string)), &amp;sliceJSON)
                                        if err != nil </span><span class="cov1" title="1">{
                                                return err
                                        }</span>
                                        <span class="cov1" title="1">flags[key] = sliceJSON</span>
                                }
                        }
                        <span class="cov2" title="4">if field.Tag.Get("choices") != "" </span><span class="cov1" title="2">{
                                choices := strings.Split(field.Tag.Get("choices"), ",")
                                switch v := flags[key].(type) </span>{
                                case string:<span class="cov1" title="2">
                                        if !slices.Contains(choices, v) </span><span class="cov1" title="1">{
                                                return fmt.Errorf("invalid value for flag %s: %s, valid choices are: %s", f.Name, v, strings.Join(choices, ", "))
                                        }</span>
                                case []string:<span class="cov0" title="0">
                                        for _, item := range v </span><span class="cov0" title="0">{
                                                if !slices.Contains(choices, item) </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("invalid value for flag %s: %s, valid choices are: %s", f.Name, item, strings.Join(choices, ", "))
                                                }</span>
                                        }
                                case map[string]any:<span class="cov0" title="0">
                                        for fieldKey := range v </span><span class="cov0" title="0">{
                                                if !slices.Contains(choices, fieldKey) </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("invalid key for flag %s: %s, valid choices are: %s", f.Name, fieldKey, strings.Join(choices, ", "))
                                                }</span>
                                        }
                                default:<span class="cov0" title="0">
                                        return fmt.Errorf("unexpected type for flag %s: %T", f.Name, flags[key])</span>
                                }
                        }
                } else<span class="cov5" title="30"> if field.Tag.Get("mapstructure") == ",squash" </span><span class="cov0" title="0">{
                        err := s.fillParsedFlag(field.Type, flags, key, f)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
        }
        <span class="cov2" title="4">return nil</span>
}

// parseFlag extracts and converts flag values to appropriate types for schema processing.
//
// parseFlag handles the extraction of flag values from cobra commands and converts
// them to the appropriate Go types for later processing by mapstructure. It supports
// all common Go primitive types and collections, then applies complex type processing
// and choice validation through fillParsedFlag.
//
// Parameters:
//   - f: The pflag.Flag to process
//   - cmd: The cobra.Command containing the flag values
//   - flags: Map to store the parsed flag values
//   - schema: The schema interface for validation and complex type processing
//
// Returns an error if flag parsing or validation fails.
//
// The function handles:
//   - Type-specific flag value extraction (bool, int variants, float variants, slices, maps)
//   - Conversion of flag names from kebab-case to snake_case
//   - Delegation to fillParsedFlag for complex type processing and validation
//   - Skipping unchanged flags to avoid unnecessary processing
func (s *ArkServiceExecAction) parseFlag(f *pflag.Flag, cmd *cobra.Command, flags map[string]interface{}, schema interface{}) error <span class="cov2" title="3">{
        if !f.Changed </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="2">key := strings.ReplaceAll(f.Name, "-", "_")
        switch f.Value.Type() </span>{
        case "bool":<span class="cov0" title="0">
                val, err := cmd.Flags().GetBool(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "int":<span class="cov1" title="1">
                val, err := cmd.Flags().GetInt(f.Name)
                if err == nil </span><span class="cov1" title="1">{
                        flags[key] = val
                }</span>
        case "int8":<span class="cov0" title="0">
                val, err := cmd.Flags().GetInt8(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "int16":<span class="cov0" title="0">
                val, err := cmd.Flags().GetInt16(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "int32":<span class="cov0" title="0">
                val, err := cmd.Flags().GetInt32(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "int64":<span class="cov0" title="0">
                val, err := cmd.Flags().GetInt64(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "uint":<span class="cov0" title="0">
                val, err := cmd.Flags().GetUint(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "uint8":<span class="cov0" title="0">
                val, err := cmd.Flags().GetUint8(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "uint16":<span class="cov0" title="0">
                val, err := cmd.Flags().GetUint16(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "uint32":<span class="cov0" title="0">
                val, err := cmd.Flags().GetUint32(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "uint64":<span class="cov0" title="0">
                val, err := cmd.Flags().GetUint64(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "float32":<span class="cov0" title="0">
                val, err := cmd.Flags().GetFloat32(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "float64":<span class="cov0" title="0">
                val, err := cmd.Flags().GetFloat64(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "stringSlice":<span class="cov0" title="0"></span>
        case "[]string":<span class="cov0" title="0">
                val, err := cmd.Flags().GetStringSlice(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "stringArray":<span class="cov0" title="0">
                val, err := cmd.Flags().GetStringArray(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "intSlice":<span class="cov0" title="0"></span>
        case "[]int":<span class="cov0" title="0">
                val, err := cmd.Flags().GetIntSlice(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        case "stringToString":<span class="cov0" title="0"></span>
        case "map[string]string":<span class="cov0" title="0">
                val, err := cmd.Flags().GetStringToString(f.Name)
                if err == nil </span><span class="cov0" title="0">{
                        flags[key] = val
                }</span>
        default:<span class="cov1" title="1">
                flags[key] = f.Value.String()</span>
        }
        <span class="cov1" title="2">schemaElem := reflect.TypeOf(schema).Elem()
        return s.fillParsedFlag(schemaElem, flags, key, f)</span>
}

// serializeAndPrintOutput formats and displays the results of service action execution.
//
// serializeAndPrintOutput processes the reflection values returned from service
// method execution and formats them appropriately for console output. It handles
// various result types including structs, maps, arrays, channels, and primitive types.
//
// Parameters:
//   - result: Slice of reflect.Value containing the method execution results
//   - actionName: The name of the action being executed (for generic success messages)
//
// The function handles:
//   - JSON serialization for complex types (structs, maps, arrays, slices)
//   - Channel processing for paginated results with Items field extraction
//   - Integer formatting for numeric results
//   - Generic success messages when no specific output is available
//   - Error handling for JSON serialization failures with fallback output
func (s *ArkServiceExecAction) serializeAndPrintOutput(result []reflect.Value, actionName string) <span class="cov2" title="5">{
        shouldPrintGenericResult := true
        for _, res := range result </span><span class="cov2" title="4">{
                if res.Kind() == reflect.Ptr &amp;&amp; res.IsNil() </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov2" title="3">if res.Kind() == reflect.Interface &amp;&amp; res.Type().Implements(reflect.TypeOf((*error)(nil)).Elem()) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov2" title="3">if res.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        res = res.Elem()
                }</span>
                <span class="cov2" title="3">if res.Kind() == reflect.Struct || res.Kind() == reflect.Map || res.Kind() == reflect.Array || res.Kind() == reflect.Slice </span><span class="cov1" title="1">{
                        jsonData, err := json.MarshalIndent(res.Interface(), "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warning("error serializing result to JSON: %v", err)
                                args.PrintSuccess(res.Interface())
                        }</span> else<span class="cov1" title="1"> {
                                args.PrintSuccess(string(jsonData))
                        }</span>
                        <span class="cov1" title="1">shouldPrintGenericResult = false</span>
                } else<span class="cov1" title="2"> if res.Kind() == reflect.Chan </span><span class="cov0" title="0">{
                        items := make([]interface{}, 0)
                        for </span><span class="cov0" title="0">{
                                pageValue, ok := res.Recv()
                                if !ok </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if !pageValue.IsValid() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if pageValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                                        pageValue = pageValue.Elem()
                                }</span>
                                <span class="cov0" title="0">itemsField := pageValue.FieldByName("Items")
                                if !itemsField.IsValid() || itemsField.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                        items = append(items, pageValue.Interface())
                                        continue</span>
                                }
                                <span class="cov0" title="0">for i := 0; i &lt; itemsField.Len(); i++ </span><span class="cov0" title="0">{
                                        items = append(items, itemsField.Index(i).Interface())
                                }</span>
                        }
                        <span class="cov0" title="0">jsonData, err := json.MarshalIndent(items, "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warning("error serializing result to JSON: %v", err)
                                args.PrintSuccess(items)
                        }</span> else<span class="cov0" title="0"> {
                                args.PrintSuccess(string(jsonData))
                        }</span>
                        <span class="cov0" title="0">shouldPrintGenericResult = false</span>
                } else<span class="cov1" title="2"> if res.Kind() == reflect.Int </span><span class="cov1" title="1">{
                        args.PrintSuccess(fmt.Sprintf("%d", res.Int()))
                        shouldPrintGenericResult = false
                }</span> else<span class="cov1" title="1"> {
                        args.PrintSuccess(res.Interface())
                        shouldPrintGenericResult = false
                }</span>
        }
        <span class="cov2" title="5">if len(result) == 0 || shouldPrintGenericResult </span><span class="cov1" title="2">{
                args.PrintSuccess(fmt.Sprintf("%s finished successfully", strings.Replace(strings.Title(actionName), "-", " ", -1)))
        }</span>
}

// findMethodByName locates a method on a reflect.Value using case-insensitive matching.
//
// findMethodByName searches for a method by name on the provided reflection value,
// first attempting an exact match and then falling back to case-insensitive matching
// if the exact match fails. This provides flexibility for method name variations.
//
// Parameters:
//   - value: The reflect.Value to search for methods on
//   - methodName: The name of the method to find
//
// Returns a pointer to the reflect.Value representing the method and any error
// encountered during the search.
//
// The function handles:
//   - Exact method name matching first
//   - Case-insensitive fallback matching through all available methods
//   - Error reporting when no matching method is found
func (s *ArkServiceExecAction) findMethodByName(value reflect.Value, methodName string) (*reflect.Value, error) <span class="cov2" title="3">{
        actionMethod := value.MethodByName(methodName)
        if !actionMethod.IsValid() </span><span class="cov1" title="2">{
                for i := 0; i &lt; value.NumMethod(); i++ </span><span class="cov1" title="2">{
                        method := value.Type().Method(i)
                        if strings.EqualFold(method.Name, methodName) </span><span class="cov1" title="1">{
                                actionMethod = value.MethodByName(method.Name)
                                break</span>
                        }
                }
                <span class="cov1" title="2">if !actionMethod.IsValid() </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("method %s not found", methodName)
                }</span>
        }
        <span class="cov1" title="2">return &amp;actionMethod, nil</span>
}

// DefineExecAction defines the execution actions for all supported service operations.
//
// DefineExecAction processes all supported service action definitions and creates
// the corresponding cobra command hierarchy for service execution. It iterates through
// the available service actions and creates the complete command structure for
// dynamic service operation execution.
//
// Parameters:
//   - cmd: The parent cobra command to add service execution commands to
//
// Returns an error if any service action definition processing fails.
//
// The function handles:
//   - Processing all supported service actions from the services package
//   - Creating command hierarchies for each service action through defineServiceExecActions
//   - Error propagation from nested action processing
//
// Example:
//
//        err := serviceExecAction.DefineExecAction(rootCmd)
//        // This adds all supported service commands to rootCmd
func (s *ArkServiceExecAction) DefineExecAction(cmd *cobra.Command) error <span class="cov1" title="1">{
        for _, actionDef := range services.SupportedServiceActions </span><span class="cov3" title="7">{
                err := s.defineServiceExecActions(actionDef, cmd, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// RunExecAction executes a service action using reflection-based method invocation.
//
// RunExecAction processes the command hierarchy to determine the target service and action,
// then uses reflection to locate and invoke the appropriate method on the API service.
// It handles flag parsing, schema validation, method resolution, and output formatting
// for dynamic service action execution.
//
// Parameters:
//   - api: The ArkCLIAPI instance containing the service methods
//   - cmd: The cobra command being executed
//   - execCmd: The parent execution command for context
//   - execArgs: Command line arguments for the execution
//
// Returns an error if service resolution, method invocation, or parameter processing fails.
//
// The function handles:
//   - Service path resolution from command hierarchy
//   - Method name transformation and case-insensitive lookup
//   - Schema resolution from service action definitions
//   - Flag parsing and validation against schema constraints
//   - Request file input for complex payloads
//   - Method invocation with appropriate parameters
//   - Result serialization and output formatting
//
// Example:
//
//        err := serviceExecAction.RunExecAction(api, cmd, execCmd, args)
//        // Executes the service method and displays formatted output
func (s *ArkServiceExecAction) RunExecAction(api *cli.ArkCLIAPI, cmd *cobra.Command, execCmd *cobra.Command, execArgs []string) error <span class="cov0" title="0">{
        serviceParts := make([]string, 0)
        for currentCmd := cmd.Parent(); currentCmd != execCmd; currentCmd = currentCmd.Parent() </span><span class="cov0" title="0">{
                serviceParts = append([]string{currentCmd.Name()}, serviceParts...)
        }</span>
        <span class="cov0" title="0">actionName := cmd.Name()
        actionNameTitled := strings.Replace(strings.Title(actionName), "-", "", -1)
        serviceNameTitled := ""
        for _, part := range serviceParts </span><span class="cov0" title="0">{
                serviceNameTitled += strings.Title(part)
        }</span>
        <span class="cov0" title="0">serviceNameTitled = strings.Replace(strings.Title(serviceNameTitled), "-", "", -1)
        // First, resolve the action method
        serviceMethod, err := s.findMethodByName(reflect.ValueOf(api), serviceNameTitled)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">serviceErr := serviceMethod.Call(nil)
        service := serviceErr[0]
        if len(serviceErr) &gt; 1 </span><span class="cov0" title="0">{
                if err, ok := serviceErr[1].Interface().(error); ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">actionMethod, err := s.findMethodByName(reflect.ValueOf(service.Interface()), actionNameTitled)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Resolve the action schema
        <span class="cov0" title="0">var actionSchemaDef *actions.ArkServiceActionDefinition = nil
        for _, servicePart := range serviceParts </span><span class="cov0" title="0">{
                if actionSchemaDef != nil </span><span class="cov0" title="0">{
                        for _, actionDef := range actionSchemaDef.Subactions </span><span class="cov0" title="0">{
                                if actionDef.ActionName == servicePart </span><span class="cov0" title="0">{
                                        actionSchemaDef = actionDef
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        for _, actionDef := range services.SupportedServiceActions </span><span class="cov0" title="0">{
                                if actionDef.ActionName == servicePart </span><span class="cov0" title="0">{
                                        actionSchemaDef = actionDef
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if actionSchemaDef == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("action %s not found in service %s", actionName, serviceNameTitled)
                        }</span>
                }
        }
        <span class="cov0" title="0">actionSchema, ok := actionSchemaDef.Schemas[actionName]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("action %s not supported", actionName)
        }</span>
        <span class="cov0" title="0">var result []reflect.Value
        if actionSchema != nil </span><span class="cov0" title="0">{
                flags := map[string]interface{}{}
                if requestFile, err := execCmd.PersistentFlags().GetString("request-file"); err == nil &amp;&amp; requestFile != "" </span><span class="cov0" title="0">{
                        fileContent, err := os.ReadFile(requestFile)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">var data map[string]interface{}
                        err = json.Unmarshal(fileContent, &amp;data)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">schemaType := reflect.ValueOf(actionSchema).Type()
                        flags = common.ConvertToSnakeCase(data, &amp;schemaType).(map[string]interface{})</span>
                }
                <span class="cov0" title="0">err = nil
                cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov0" title="0">{
                        err = s.parseFlag(f, cmd, flags, actionSchema)
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = mapstructure.Decode(flags, actionSchema)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">actionArgs := []reflect.Value{reflect.ValueOf(actionSchema)}
                result = actionMethod.Call(actionArgs)</span>
        } else<span class="cov0" title="0"> {
                var actionArgs []reflect.Value
                result = actionMethod.Call(actionArgs)
        }</span>
        <span class="cov0" title="0">for _, res := range result </span><span class="cov0" title="0">{
                if err, ok := res.Interface().(error); ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">s.serializeAndPrintOutput(result, actionName)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package api provides the main ARK SDK API interface for accessing all ARK services
// in the ARK SDK Golang. This package serves as the central entry point for interacting
// with various ARK services including SIA, SecHub, PCloud, Identity, and other components.
//
// The ArkAPI struct acts as a service factory and registry, managing authenticators,
// service instances, and configuration profiles. It provides lazy loading of services,
// meaning services are only instantiated when first accessed, and subsequent calls
// return the cached instance.
//
// Key features:
//   - Centralized access to all ARK services
//   - Lazy loading and caching of service instances
//   - Authenticator management and distribution to services
//   - Profile-based configuration management
//   - Service dependency injection with authenticators
//   - Consistent error handling across all services
//
// The API supports multiple authenticators that are automatically distributed to
// services based on their configuration requirements. Each service specifies
// required and optional authenticators, and the API ensures the appropriate
// authenticators are provided during service initialization.
//
// Example:
//
//        // Create authenticators
//        ispAuth := &amp;auth.ArkISPAuth{...}
//        authenticators := []auth.ArkAuth{ispAuth}
//
//        // Create API instance
//        api, err := NewArkAPI(authenticators, nil) // nil uses default profile
//        if err != nil {
//                // handle error
//        }
//
//        // Access services (lazy loaded)
//        ssoService, err := api.SiaSso()
//        if err != nil {
//                // handle error
//        }
//
//        // Get specific authenticator
//        auth, err := api.Authenticator("isp")
//        if err != nil {
//                // handle error
//        }
package api

import (
        "fmt"

        "github.com/cyberark/ark-sdk-golang/pkg/services/uap"
        "github.com/cyberark/ark-sdk-golang/pkg/services/uap/sca"
        "github.com/cyberark/ark-sdk-golang/pkg/services/uap/sia/db"
        "github.com/cyberark/ark-sdk-golang/pkg/services/uap/sia/vm"

        "github.com/cyberark/ark-sdk-golang/pkg/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/profiles"
        "github.com/cyberark/ark-sdk-golang/pkg/services"
        "github.com/cyberark/ark-sdk-golang/pkg/services/cmgr"
        "github.com/cyberark/ark-sdk-golang/pkg/services/identity/directories"
        "github.com/cyberark/ark-sdk-golang/pkg/services/identity/roles"
        "github.com/cyberark/ark-sdk-golang/pkg/services/identity/users"
        "github.com/cyberark/ark-sdk-golang/pkg/services/pcloud/accounts"
        "github.com/cyberark/ark-sdk-golang/pkg/services/pcloud/safes"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/configuration"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/filters"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/scans"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/secrets"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/secretstores"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/serviceinfo"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sechub/syncpolicies"
        siaaccess "github.com/cyberark/ark-sdk-golang/pkg/services/sia/access"
        siadb "github.com/cyberark/ark-sdk-golang/pkg/services/sia/db"
        siak8s "github.com/cyberark/ark-sdk-golang/pkg/services/sia/k8s"
        siasecretsdb "github.com/cyberark/ark-sdk-golang/pkg/services/sia/secrets/db"
        siasecretsvm "github.com/cyberark/ark-sdk-golang/pkg/services/sia/secrets/vm"
        siasshca "github.com/cyberark/ark-sdk-golang/pkg/services/sia/sshca"
        siasso "github.com/cyberark/ark-sdk-golang/pkg/services/sia/sso"
        siaworkspacesdb "github.com/cyberark/ark-sdk-golang/pkg/services/sia/workspaces/db"
        siatargetsets "github.com/cyberark/ark-sdk-golang/pkg/services/sia/workspaces/targetsets"
        "github.com/cyberark/ark-sdk-golang/pkg/services/sm"
)

// ArkAPI wraps different API functionality of Ark Services.
//
// ArkAPI serves as the central entry point and service factory for all ARK services.
// It manages authenticators, service instances, and configuration profiles, providing
// a unified interface for accessing various ARK components including SIA, SecHub,
// PCloud, Identity, and other services.
//
// The struct implements lazy loading for services - each service is only instantiated
// when first accessed through its corresponding method. Subsequent calls return the
// cached instance, ensuring efficient resource usage and consistent service state.
//
// Service creation follows a dependency injection pattern where authenticators are
// automatically distributed to services based on their configuration requirements.
// Each service specifies required and optional authenticators, and ArkAPI ensures
// the appropriate authenticators are provided during initialization.
type ArkAPI struct {
        authenticators []auth.ArkAuth
        services       map[string]*services.ArkService
        profile        *models.ArkProfile
}

// NewArkAPI creates a new ArkAPI instance with the provided authenticators and profile.
//
// Initializes a new ArkAPI instance that serves as the central access point for all
// ARK services. The instance manages the provided authenticators and distributes them
// to services as needed. If no profile is provided (nil), the default profile is
// loaded automatically.
//
// The services map is initialized empty and services are created lazily when first
// accessed through their respective getter methods. This approach ensures optimal
// resource usage and faster startup times.
//
// Parameters:
//   - authenticators: Slice of authenticators to be used by services. Each service
//     will receive the authenticators it requires based on its configuration
//   - profile: Configuration profile to use. If nil, the default profile is loaded
//     automatically using the default profile loader
//
// Returns a pointer to the initialized ArkAPI instance, or an error if the default
// profile cannot be loaded when profile is nil.
//
// Example:
//
//        // With explicit profile
//        profile := &amp;models.ArkProfile{...}
//        api, err := NewArkAPI(authenticators, profile)
//
//        // With default profile (recommended)
//        api, err := NewArkAPI(authenticators, nil)
//        if err != nil {
//                // handle profile loading error
//        }
func NewArkAPI(authenticators []auth.ArkAuth, profile *models.ArkProfile) (*ArkAPI, error) <span class="cov6" title="3">{
        var err error
        if profile == nil </span><span class="cov1" title="1">{
                profile, err = (*profiles.DefaultProfilesLoader()).LoadDefaultProfile()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov6" title="3">return &amp;ArkAPI{
                authenticators: authenticators,
                services:       make(map[string]*services.ArkService),
                profile:        profile,
        }, nil</span>
}

// loadServiceAuthenticators filters and returns authenticators required by a service configuration.
//
// This internal method processes the API's authenticator collection and returns only
// those authenticators that are required or optional for the specified service.
// Required authenticators are processed first, followed by optional authenticators.
//
// The method ensures that services receive only the authenticators they need,
// following the dependency injection pattern. This approach provides better
// security isolation and cleaner service initialization.
//
// Parameters:
//   - config: Service configuration specifying required and optional authenticator names
//
// Returns a slice of authenticators that match the service's requirements.
// If no matching authenticators are found, returns an empty slice.
func (api *ArkAPI) loadServiceAuthenticators(config services.ArkServiceConfig) []auth.ArkAuth <span class="cov10" title="6">{
        var authenticators []auth.ArkAuth
        for _, authenticator := range api.authenticators </span><span class="cov0" title="0">{
                for _, name := range config.RequiredAuthenticatorNames </span><span class="cov0" title="0">{
                        if authenticator.AuthenticatorName() == name </span><span class="cov0" title="0">{
                                authenticators = append(authenticators, authenticator)
                        }</span>
                }
        }
        <span class="cov10" title="6">for _, authenticator := range api.authenticators </span><span class="cov0" title="0">{
                for _, name := range config.OptionalAuthenticatorNames </span><span class="cov0" title="0">{
                        if authenticator.AuthenticatorName() == name </span><span class="cov0" title="0">{
                                authenticators = append(authenticators, authenticator)
                        }</span>
                }
        }
        <span class="cov10" title="6">return authenticators</span>
}

// Authenticator returns the authenticator with the specified name from the ArkAPI instance.
//
// Searches through the API's authenticator collection and returns the first
// authenticator that matches the specified name. This method provides access
// to specific authenticators for custom operations or debugging purposes.
//
// The search is case-sensitive and matches the exact authenticator name as
// returned by the authenticator's AuthenticatorName() method.
//
// Parameters:
//   - authenticatorName: The exact name of the authenticator to retrieve
//
// Returns the matching authenticator, or an error if no authenticator with
// the specified name is found.
//
// Example:
//
//        ispAuth, err := api.Authenticator("isp")
//        if err != nil {
//                // handle authenticator not found
//        }
//        // use ispAuth for custom operations
func (api *ArkAPI) Authenticator(authenticatorName string) (auth.ArkAuth, error) <span class="cov6" title="3">{
        for _, authenticator := range api.authenticators </span><span class="cov0" title="0">{
                if authenticator.AuthenticatorName() == authenticatorName </span><span class="cov0" title="0">{
                        return authenticator, nil
                }</span>
        }
        <span class="cov6" title="3">return nil, fmt.Errorf("%s is not supported or not found", authenticatorName)</span>
}

// Profile returns the profile associated with the ArkAPI instance.
//
// Provides access to the configuration profile that was set during API initialization.
// The profile contains environment-specific settings, endpoints, and other configuration
// parameters used by the various ARK services.
//
// The returned profile is the same instance that was either explicitly provided to
// NewArkAPI or automatically loaded as the default profile when nil was passed.
//
// Returns a pointer to the ArkProfile instance. The profile is never nil for a
// properly initialized ArkAPI instance.
//
// Example:
//
//        profile := api.Profile()
//        fmt.Printf("Using profile: %s\n", profile.ProfileName)
func (api *ArkAPI) Profile() *models.ArkProfile <span class="cov6" title="3">{
        return api.profile
}</span>

// SiaSso returns the SiaSSO service from the ArkAPI instance. If the service is not already created, it creates a new one.
//
// Provides access to the SIA Single Sign-On service for authentication and user
// session management operations. The service is created using lazy loading - if
// this is the first call, a new service instance is created and cached. Subsequent
// calls return the cached instance.
//
// The service is initialized with authenticators that match its configuration
// requirements. If the service cannot be created due to missing authenticators
// or initialization errors, an error is returned.
//
// Returns a pointer to the ArkSIASSOService instance, or an error if the service
// cannot be created or initialized.
//
// Example:
//
//        ssoService, err := api.SiaSso()
//        if err != nil {
//                // handle service creation error
//        }
//        // use ssoService for SSO operations
func (api *ArkAPI) SiaSso() (*siasso.ArkSIASSOService, error) <span class="cov0" title="0">{
        if ssoServiceInterface, ok := api.services[siasso.SIASSOServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*ssoServiceInterface).(*siasso.ArkSIASSOService), nil
        }</span>
        <span class="cov0" title="0">ssoService, err := siasso.NewArkSIASSOService(api.loadServiceAuthenticators(siasso.SIASSOServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var ssoBaseService services.ArkService = ssoService
        api.services[siasso.SIASSOServiceConfig.ServiceName] = &amp;ssoBaseService
        return ssoService, nil</span>
}

// SiaK8s returns the SiaK8s service from the ArkAPI instance. If the service is not already created, it creates a new one.
//
// Provides access to the SIA Kubernetes service for managing Kubernetes cluster
// access and operations. The service is created using lazy loading - if this is
// the first call, a new service instance is created and cached. Subsequent calls
// return the cached instance.
//
// The service is initialized with authenticators that match its configuration
// requirements. If the service cannot be created due to missing authenticators
// or initialization errors, an error is returned.
//
// Returns a pointer to the ArkSIAK8SService instance, or an error if the service
// cannot be created or initialized.
//
// Example:
//
//        k8sService, err := api.SiaK8s()
//        if err != nil {
//                // handle service creation error
//        }
//        // use k8sService for Kubernetes operations
func (api *ArkAPI) SiaK8s() (*siak8s.ArkSIAK8SService, error) <span class="cov0" title="0">{
        if k8sServiceInterface, ok := api.services[siak8s.SIAK8SServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*k8sServiceInterface).(*siak8s.ArkSIAK8SService), nil
        }</span>
        <span class="cov0" title="0">k8sService, err := siak8s.NewArkSIAK8SService(api.loadServiceAuthenticators(siak8s.SIAK8SServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var k8sBaseService services.ArkService = k8sService
        api.services[siak8s.SIAK8SServiceConfig.ServiceName] = &amp;k8sBaseService
        return k8sService, nil</span>
}

// SiaWorkspacesTargetSets returns the SiaWorkspacesTargetSets service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaWorkspacesTargetSets() (*siatargetsets.ArkSIAWorkspacesTargetSetsService, error) <span class="cov0" title="0">{
        if targetSetsServiceInterface, ok := api.services[siatargetsets.SIATargetSetsWorkspaceServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*targetSetsServiceInterface).(*siatargetsets.ArkSIAWorkspacesTargetSetsService), nil
        }</span>
        <span class="cov0" title="0">targetSetsService, err := siatargetsets.NewArkSIAWorkspacesTargetSetsService(api.loadServiceAuthenticators(siatargetsets.SIATargetSetsWorkspaceServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var targetSetsBaseService services.ArkService = targetSetsService
        api.services[siatargetsets.SIATargetSetsWorkspaceServiceConfig.ServiceName] = &amp;targetSetsBaseService
        return targetSetsService, nil</span>
}

// SiaWorkspacesDB returns the Workspaces DB service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaWorkspacesDB() (*siaworkspacesdb.ArkSIAWorkspacesDBService, error) <span class="cov0" title="0">{
        if workspacesDBServiceInterface, ok := api.services[siaworkspacesdb.SIADBWorkspaceServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*workspacesDBServiceInterface).(*siaworkspacesdb.ArkSIAWorkspacesDBService), nil
        }</span>
        <span class="cov0" title="0">workspacesDBService, err := siaworkspacesdb.NewArkSIAWorkspacesDBService(api.loadServiceAuthenticators(siaworkspacesdb.SIADBWorkspaceServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var workspacesDBBaseService services.ArkService = workspacesDBService
        api.services[siaworkspacesdb.SIADBWorkspaceServiceConfig.ServiceName] = &amp;workspacesDBBaseService
        return workspacesDBService, nil</span>
}

// SiaSecretsVM returns the SiaSecretsVM service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaSecretsVM() (*siasecretsvm.ArkSIASecretsVMService, error) <span class="cov0" title="0">{
        if secretsVMServiceInterface, ok := api.services[siasecretsvm.SIASecretsVMServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*secretsVMServiceInterface).(*siasecretsvm.ArkSIASecretsVMService), nil
        }</span>
        <span class="cov0" title="0">secretsVMService, err := siasecretsvm.NewArkSIASecretsVMService(api.loadServiceAuthenticators(siasecretsvm.SIASecretsVMServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var secretsVMBaseService services.ArkService = secretsVMService
        api.services[siasecretsvm.SIASecretsVMServiceConfig.ServiceName] = &amp;secretsVMBaseService
        return secretsVMService, nil</span>
}

// SiaSecretsDB returns the SiaSecretsDB service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaSecretsDB() (*siasecretsdb.ArkSIASecretsDBService, error) <span class="cov0" title="0">{
        if secretsDBServiceInterface, ok := api.services[siasecretsdb.SIASecretsDBServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*secretsDBServiceInterface).(*siasecretsdb.ArkSIASecretsDBService), nil
        }</span>
        <span class="cov0" title="0">secretsDBService, err := siasecretsdb.NewArkSIASecretsDBService(api.loadServiceAuthenticators(siasecretsdb.SIASecretsDBServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var secretsDBBaseService services.ArkService = secretsDBService
        api.services[siasecretsdb.SIASecretsDBServiceConfig.ServiceName] = &amp;secretsDBBaseService
        return secretsDBService, nil</span>
}

// SiaAccess returns the SiaAccess service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaAccess() (*siaaccess.ArkSIAAccessService, error) <span class="cov0" title="0">{
        if accessServiceInterface, ok := api.services[siaaccess.SIAAccessServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*accessServiceInterface).(*siaaccess.ArkSIAAccessService), nil
        }</span>
        <span class="cov0" title="0">accessService, err := siaaccess.NewArkSIAAccessService(api.loadServiceAuthenticators(siaaccess.SIAAccessServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var accessBaseService services.ArkService = accessService
        api.services[siaaccess.SIAAccessServiceConfig.ServiceName] = &amp;accessBaseService
        return accessService, nil</span>
}

// SiaSSHCa returns the SiaSSHCa service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaSSHCa() (*siasshca.ArkSIASSHCAService, error) <span class="cov0" title="0">{
        if sshCaServiceInterface, ok := api.services[siasshca.SIASSHCAServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*sshCaServiceInterface).(*siasshca.ArkSIASSHCAService), nil
        }</span>
        <span class="cov0" title="0">sshCaService, err := siasshca.NewArkSIASSHCAService(api.loadServiceAuthenticators(siasshca.SIASSHCAServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var sshCaBaseService services.ArkService = sshCaService
        api.services[siasshca.SIASSHCAServiceConfig.ServiceName] = &amp;sshCaBaseService
        return sshCaService, nil</span>
}

// SiaDb returns the SiaDb service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SiaDb() (*siadb.ArkSIADBService, error) <span class="cov0" title="0">{
        if dbServiceInterface, ok := api.services[siadb.SIADBServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*dbServiceInterface).(*siadb.ArkSIADBService), nil
        }</span>
        <span class="cov0" title="0">dbService, err := siadb.NewArkSIADBService(api.loadServiceAuthenticators(siadb.SIADBServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var dbBaseService services.ArkService = dbService
        api.services[siadb.SIADBServiceConfig.ServiceName] = &amp;dbBaseService
        return dbService, nil</span>
}

// Cmgr returns the Cmgr service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) Cmgr() (*cmgr.ArkCmgrService, error) <span class="cov0" title="0">{
        if cmgrServiceInterface, ok := api.services[cmgr.CmgrServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*cmgrServiceInterface).(*cmgr.ArkCmgrService), nil
        }</span>
        <span class="cov0" title="0">cmgrService, err := cmgr.NewArkCmgrService(api.loadServiceAuthenticators(cmgr.CmgrServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var cmgrBaseService services.ArkService = cmgrService
        api.services[cmgr.CmgrServiceConfig.ServiceName] = &amp;cmgrBaseService
        return cmgrService, nil</span>
}

// PCloudSafes returns the PCloudSafes service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) PCloudSafes() (*safes.ArkPCloudSafesService, error) <span class="cov0" title="0">{
        if pcloudSafesServiceInterface, ok := api.services[safes.PCloudSafesServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*pcloudSafesServiceInterface).(*safes.ArkPCloudSafesService), nil
        }</span>
        <span class="cov0" title="0">pcloudSafesService, err := safes.NewArkPCloudSafesService(api.loadServiceAuthenticators(safes.PCloudSafesServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var pcloudSafesBaseService services.ArkService = pcloudSafesService
        api.services[safes.PCloudSafesServiceConfig.ServiceName] = &amp;pcloudSafesBaseService
        return pcloudSafesService, nil</span>
}

// PCloudAccounts returns the PCloudAccounts service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) PCloudAccounts() (*accounts.ArkPCloudAccountsService, error) <span class="cov0" title="0">{
        if pcloudAccountsServiceInterface, ok := api.services[accounts.PCloudAccountsServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*pcloudAccountsServiceInterface).(*accounts.ArkPCloudAccountsService), nil
        }</span>
        <span class="cov0" title="0">pcloudAccountsService, err := accounts.NewArkPCloudAccountsService(api.loadServiceAuthenticators(accounts.PCloudAccountsServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var pcloudAccountsBaseService services.ArkService = pcloudAccountsService
        api.services[accounts.PCloudAccountsServiceConfig.ServiceName] = &amp;pcloudAccountsBaseService
        return pcloudAccountsService, nil</span>
}

// IdentityDirectories returns the IdentityDirectories service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) IdentityDirectories() (*directories.ArkIdentityDirectoriesService, error) <span class="cov0" title="0">{
        if directoriesServiceInterface, ok := api.services[directories.IdentityDirectoriesServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*directoriesServiceInterface).(*directories.ArkIdentityDirectoriesService), nil
        }</span>
        <span class="cov0" title="0">directoriesService, err := directories.NewArkIdentityDirectoriesService(api.loadServiceAuthenticators(directories.IdentityDirectoriesServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var directoriesBaseService services.ArkService = directoriesService
        api.services[directories.IdentityDirectoriesServiceConfig.ServiceName] = &amp;directoriesBaseService
        return directoriesService, nil</span>
}

// IdentityRoles returns the IdentityRoles service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) IdentityRoles() (*roles.ArkIdentityRolesService, error) <span class="cov0" title="0">{
        if rolesServiceInterface, ok := api.services[roles.IdentityRolesServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*rolesServiceInterface).(*roles.ArkIdentityRolesService), nil
        }</span>
        <span class="cov0" title="0">rolesService, err := roles.NewArkIdentityRolesService(api.loadServiceAuthenticators(roles.IdentityRolesServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var rolesBaseService services.ArkService = rolesService
        api.services[roles.IdentityRolesServiceConfig.ServiceName] = &amp;rolesBaseService
        return rolesService, nil</span>
}

// IdentityUsers returns the IdentityUsers service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) IdentityUsers() (*users.ArkIdentityUsersService, error) <span class="cov0" title="0">{
        if usersServiceInterface, ok := api.services[users.IdentityUsersServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*usersServiceInterface).(*users.ArkIdentityUsersService), nil
        }</span>
        <span class="cov0" title="0">usersService, err := users.NewArkIdentityUsersService(api.loadServiceAuthenticators(users.IdentityUsersServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var usersBaseService services.ArkService = usersService
        api.services[users.IdentityUsersServiceConfig.ServiceName] = &amp;usersBaseService
        return usersService, nil</span>
}

// SecHubConfiguration returns the SecHub Configuration service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubConfiguration() (*configuration.ArkSecHubConfigurationService, error) <span class="cov0" title="0">{
        if configurationServiceInterface, ok := api.services[configuration.SecHubConfigurationServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*configurationServiceInterface).(*configuration.ArkSecHubConfigurationService), nil
        }</span>
        <span class="cov0" title="0">configurationService, err := configuration.NewArkSecHubConfigurationService(api.loadServiceAuthenticators(configuration.SecHubConfigurationServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var configurationBaseService services.ArkService = configurationService
        api.services[configuration.SecHubConfigurationServiceConfig.ServiceName] = &amp;configurationBaseService
        return configurationService, nil</span>
}

// SecHubScans returns the SecHub Scans service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubScans() (*scans.ArkSecHubScansService, error) <span class="cov0" title="0">{
        if serviceInfoServiceInterface, ok := api.services[scans.SecHubScansServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*serviceInfoServiceInterface).(*scans.ArkSecHubScansService), nil
        }</span>
        <span class="cov0" title="0">scansService, err := scans.NewArkSecHubScansService(api.loadServiceAuthenticators(scans.SecHubScansServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var scansBaseService services.ArkService = scansService
        api.services[scans.SecHubScansServiceConfig.ServiceName] = &amp;scansBaseService
        return scansService, nil</span>
}

// SecHubServiceInfo returns the SecHub Service Info service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubServiceInfo() (*serviceinfo.ArkSecHubServiceInfoService, error) <span class="cov0" title="0">{
        if serviceInfoServiceInterface, ok := api.services[serviceinfo.SecHubServiceInfoServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*serviceInfoServiceInterface).(*serviceinfo.ArkSecHubServiceInfoService), nil
        }</span>
        <span class="cov0" title="0">serviceinfoService, err := serviceinfo.NewArkSecHubServiceInfoService(api.loadServiceAuthenticators(serviceinfo.SecHubServiceInfoServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var serviceinfoBaseService services.ArkService = serviceinfoService
        api.services[serviceinfo.SecHubServiceInfoServiceConfig.ServiceName] = &amp;serviceinfoBaseService
        return serviceinfoService, nil</span>
}

// SecHubFilters returns the SecHub Filters service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubFilters() (*filters.ArkSecHubFiltersService, error) <span class="cov0" title="0">{
        if filtersServiceInterface, ok := api.services[filters.SecHubFiltersServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*filtersServiceInterface).(*filters.ArkSecHubFiltersService), nil
        }</span>
        <span class="cov0" title="0">filtersService, err := filters.NewArkSecHubFiltersService(api.loadServiceAuthenticators(filters.SecHubFiltersServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var filtersBaseService services.ArkService = filtersService
        api.services[filters.SecHubFiltersServiceConfig.ServiceName] = &amp;filtersBaseService
        return filtersService, nil</span>
}

// SecHubSecretStores returns the SecHub Secret Stores service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubSecretStores() (*secretstores.ArkSecHubSecretStoresService, error) <span class="cov0" title="0">{
        if secretStoresServiceInterface, ok := api.services[secretstores.SecHubSecretStoresServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*secretStoresServiceInterface).(*secretstores.ArkSecHubSecretStoresService), nil
        }</span>
        <span class="cov0" title="0">secretStoresService, err := secretstores.NewArkSecHubSecretStoresService(api.loadServiceAuthenticators(secretstores.SecHubSecretStoresServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var secretStoresBaseService services.ArkService = secretStoresService
        api.services[secretstores.SecHubSecretStoresServiceConfig.ServiceName] = &amp;secretStoresBaseService
        return secretStoresService, nil</span>
}

// SecHubSecrets returns the SecHub Secrets service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubSecrets() (*secrets.ArkSecHubSecretsService, error) <span class="cov0" title="0">{
        if secretsServiceInterface, ok := api.services[secrets.SecHubSecretsServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*secretsServiceInterface).(*secrets.ArkSecHubSecretsService), nil
        }</span>
        <span class="cov0" title="0">secretsService, err := secrets.NewArkSecHubSecretsService(api.loadServiceAuthenticators(secrets.SecHubSecretsServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var secretsBaseService services.ArkService = secretsService
        api.services[secrets.SecHubSecretsServiceConfig.ServiceName] = &amp;secretsBaseService
        return secretsService, nil</span>
}

// SecHubSyncPolicies returns the SecHub Sync Policies service from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) SecHubSyncPolicies() (*syncpolicies.ArkSecHubSyncPoliciesService, error) <span class="cov0" title="0">{
        if syncPoliciesServiceInterface, ok := api.services[syncpolicies.SecHubSyncPoliciesServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*syncPoliciesServiceInterface).(*syncpolicies.ArkSecHubSyncPoliciesService), nil
        }</span>
        <span class="cov0" title="0">syncPoliciesService, err := syncpolicies.NewArkSecHubSyncPoliciesService(api.loadServiceAuthenticators(syncpolicies.SecHubSyncPoliciesServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var syncPoliciesBaseService services.ArkService = syncPoliciesService
        api.services[syncpolicies.SecHubSyncPoliciesServiceConfig.ServiceName] = &amp;syncPoliciesBaseService
        return syncPoliciesService, nil</span>
}

// Sm returns the SMService from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) Sm() (*sm.ArkSMService, error) <span class="cov0" title="0">{
        if SMInterface, ok := api.services[sm.SMServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*SMInterface).(*sm.ArkSMService), nil
        }</span>
        <span class="cov0" title="0">SMService, err := sm.NewArkSMService(api.loadServiceAuthenticators(sm.SMServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var smBaseService services.ArkService = SMService
        api.services[sm.SMServiceConfig.ServiceName] = &amp;smBaseService
        return SMService, nil</span>
}

// Uap returns the UapService from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) Uap() (*uap.ArkUAPService, error) <span class="cov0" title="0">{
        if uapInterface, ok := api.services[uap.UapServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*uapInterface).(*uap.ArkUAPService), nil
        }</span>
        <span class="cov0" title="0">uapService, err := uap.NewArkUAPService(api.loadServiceAuthenticators(uap.UapServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var uapBaseService services.ArkService = uapService
        api.services[uap.UapServiceConfig.ServiceName] = &amp;uapBaseService
        return uapService, nil</span>
}

// UapSca returns the UapScaService from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) UapSca() (*sca.ArkUAPSCAService, error) <span class="cov0" title="0">{
        if uapScaInterface, ok := api.services[sca.ArkUAPSCAServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*uapScaInterface).(*sca.ArkUAPSCAService), nil
        }</span>
        <span class="cov0" title="0">uapScaService, err := sca.NewArkUAPSCAService(api.loadServiceAuthenticators(sca.ArkUAPSCAServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var uapScaBaseService services.ArkService = uapScaService
        api.services[sca.ArkUAPSCAServiceConfig.ServiceName] = &amp;uapScaBaseService
        return uapScaService, nil</span>
}

// UapDb returns the UapSiaDbService from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) UapDb() (*db.ArkUAPSIADBService, error) <span class="cov0" title="0">{
        if uapDbInterface, ok := api.services[db.ArkUAPSIADBServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*uapDbInterface).(*db.ArkUAPSIADBService), nil
        }</span>
        <span class="cov0" title="0">uapDbService, err := db.NewArkUAPSIADBService(api.loadServiceAuthenticators(db.ArkUAPSIADBServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var uapDbBaseService services.ArkService = uapDbService
        api.services[db.ArkUAPSIADBServiceConfig.ServiceName] = &amp;uapDbBaseService
        return uapDbService, nil</span>
}

// UapVM returns the UapSiaVmService from the ArkAPI instance. If the service is not already created, it creates a new one.
func (api *ArkAPI) UapVM() (*vm.ArkUAPSIAVMService, error) <span class="cov0" title="0">{
        if uapVMInterface, ok := api.services[vm.ArkUAPSIAVMServiceConfig.ServiceName]; ok </span><span class="cov0" title="0">{
                return (*uapVMInterface).(*vm.ArkUAPSIAVMService), nil
        }</span>
        <span class="cov0" title="0">uapVMService, err := vm.NewArkUAPSIAVMService(api.loadServiceAuthenticators(vm.ArkUAPSIAVMServiceConfig)...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var uapVMBaseService services.ArkService = uapVMService
        api.services[vm.ArkUAPSIAVMServiceConfig.ServiceName] = &amp;uapVMBaseService
        return uapVMService, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "errors"
        "net/url"
        "slices"
        "time"

        "github.com/cyberark/ark-sdk-golang/pkg/profiles"

        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
)

const (
        defaultExpirationGraceDeltaSeconds = 60
)

// ArkAuth is an interface that defines the methods for authentication in the Ark SDK.
type ArkAuth interface {
        // AuthenticatorName returns the name of the authenticator.
        AuthenticatorName() string
        // AuthenticatorHumanReadableName returns a human-readable name for the authenticator.
        AuthenticatorHumanReadableName() string
        // SupportedAuthMethods returns a list of supported authentication methods.
        SupportedAuthMethods() []auth.ArkAuthMethod
        // IsAuthenticated checks if the authentication is already loaded for the specified profile.
        IsAuthenticated(profile *models.ArkProfile) bool
        // DefaultAuthMethod returns the default authentication method and its settings.
        DefaultAuthMethod() (auth.ArkAuthMethod, auth.ArkAuthMethodSettings)
        // LoadAuthentication loads the authentication token for the specified profile and refreshes it if necessary.
        // It returns the authentication token and an error if any occurred.
        LoadAuthentication(profile *models.ArkProfile, refreshAuth bool) (*auth.ArkToken, error)
        // Authenticate performs authentication using the specified profile and authentication profile.
        // If profile is not passed (nil), will try to use the auth profile alone, but at least one of them needs to be passed
        // Secret may optionally be passed if needed for the authentication type
        // If force is true, it will force re-authentication even if a valid token is already present
        // If refreshAuth is true, it will attempt to refresh the token if it is expired
        // It returns the authentication token and an error if any occurred.
        Authenticate(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool, refreshAuth bool) (*auth.ArkToken, error)

        performAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool) (*auth.ArkToken, error)
        performRefreshAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, token *auth.ArkToken) (*auth.ArkToken, error)
}

// ArkAuthBase is a struct that implements the ArkAuth interface and provides common functionality for authentication.
type ArkAuthBase struct {
        Authenticator       ArkAuth
        Logger              *common.ArkLogger
        CacheAuthentication bool
        CacheKeyring        *common.ArkKeyring
        Token               *auth.ArkToken
        ActiveProfile       *models.ArkProfile
        ActiveAuthProfile   *auth.ArkAuthProfile
}

// NewArkAuthBase creates a new instance of ArkAuthBase.
func NewArkAuthBase(cacheAuthentication bool, name string, authenticator ArkAuth) *ArkAuthBase <span class="cov0" title="0">{
        logger := common.GetLogger(name, common.Unknown)
        var cacheKeyring *common.ArkKeyring
        if cacheAuthentication </span><span class="cov0" title="0">{
                cacheKeyring = common.NewArkKeyring(name)
        }</span>
        <span class="cov0" title="0">return &amp;ArkAuthBase{
                Authenticator:       authenticator,
                Logger:              logger,
                CacheAuthentication: cacheAuthentication,
                CacheKeyring:        cacheKeyring,
        }</span>
}

// ResolveCachePostfix resolves the cache postfix for the authentication profile.
func (a *ArkAuthBase) ResolveCachePostfix(authProfile *auth.ArkAuthProfile) string <span class="cov0" title="0">{
        postfix := authProfile.Username
        if authProfile.AuthMethod == auth.Direct &amp;&amp; authProfile.AuthMethodSettings != nil </span><span class="cov0" title="0">{
                directMethodSettings := authProfile.AuthMethodSettings.(auth.DirectArkAuthMethodSettings)
                if directMethodSettings.Endpoint != "" </span><span class="cov0" title="0">{
                        parsedURL, _ := url.Parse(directMethodSettings.Endpoint)
                        postfix = postfix + "_" + parsedURL.Host
                }</span>
        }
        <span class="cov0" title="0">return postfix</span>
}

// Authenticate performs authentication using the specified profile and authentication profile.
func (a *ArkAuthBase) Authenticate(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool, refreshAuth bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        if authProfile == nil &amp;&amp; profile == nil </span><span class="cov0" title="0">{
                return nil, errors.New("either a profile or a specific auth profile must be supplied")
        }</span>
        <span class="cov0" title="0">if authProfile == nil &amp;&amp; profile != nil </span><span class="cov0" title="0">{
                if ap, ok := profile.AuthProfiles[a.Authenticator.AuthenticatorName()]; ok </span><span class="cov0" title="0">{
                        authProfile = ap
                }</span> else<span class="cov0" title="0"> {
                        return nil, errors.New(a.Authenticator.AuthenticatorHumanReadableName() + " [" + a.Authenticator.AuthenticatorName() + "] is not defined within the authentication profiles")
                }</span>
        }
        <span class="cov0" title="0">if profile == nil </span><span class="cov0" title="0">{
                profilesLoader := profiles.DefaultProfilesLoader()
                profile, _ = (*profilesLoader).LoadDefaultProfile()
        }</span>
        <span class="cov0" title="0">if !slices.Contains(a.Authenticator.SupportedAuthMethods(), authProfile.AuthMethod) &amp;&amp; authProfile.AuthMethod != auth.Default </span><span class="cov0" title="0">{
                return nil, errors.New(a.Authenticator.AuthenticatorHumanReadableName() + " does not support authentication method " + string(authProfile.AuthMethod))
        }</span>
        <span class="cov0" title="0">if authProfile.AuthMethod == auth.Default </span><span class="cov0" title="0">{
                authProfile.AuthMethod, authProfile.AuthMethodSettings = a.Authenticator.DefaultAuthMethod()
        }</span>
        <span class="cov0" title="0">if slices.Contains(auth.ArkAuthMethodsRequireCredentials, authProfile.AuthMethod) &amp;&amp; authProfile.Username == "" </span><span class="cov0" title="0">{
                return nil, errors.New(a.Authenticator.AuthenticatorHumanReadableName() + " requires a username and optionally a secret")
        }</span>
        <span class="cov0" title="0">var token *auth.ArkToken
        var err error
        tokenRefreshed := false
        if a.CacheAuthentication &amp;&amp; a.CacheKeyring != nil &amp;&amp; !force </span><span class="cov0" title="0">{
                token, err = a.CacheKeyring.LoadToken(profile, a.ResolveCachePostfix(authProfile), false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if token != nil &amp;&amp; time.Time(token.ExpiresIn).Before(time.Now()) </span><span class="cov0" title="0">{
                        if refreshAuth &amp;&amp; token.RefreshToken != "" </span><span class="cov0" title="0">{
                                token, _ = a.Authenticator.performRefreshAuthentication(profile, authProfile, token)
                                if token != nil </span><span class="cov0" title="0">{
                                        tokenRefreshed = true
                                }</span> else<span class="cov0" title="0"> {
                                        token = nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                token = nil
                        }</span>
                }
        }
        <span class="cov0" title="0">if token == nil </span><span class="cov0" title="0">{
                token, err = a.Authenticator.performAuthentication(profile, authProfile, secret, force)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if token != nil &amp;&amp; a.CacheAuthentication &amp;&amp; a.CacheKeyring != nil </span><span class="cov0" title="0">{
                        err := a.CacheKeyring.SaveToken(profile, token, a.ResolveCachePostfix(authProfile), false)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        } else<span class="cov0" title="0"> if refreshAuth &amp;&amp; !tokenRefreshed </span><span class="cov0" title="0">{
                token, err = a.Authenticator.performRefreshAuthentication(profile, authProfile, token)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if token != nil &amp;&amp; a.CacheAuthentication &amp;&amp; a.CacheKeyring != nil </span><span class="cov0" title="0">{
                        err := a.CacheKeyring.SaveToken(profile, token, a.ResolveCachePostfix(authProfile), false)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }
        <span class="cov0" title="0">a.Token = token
        a.ActiveProfile = profile
        a.ActiveAuthProfile = authProfile
        return token, nil</span>
}

// IsAuthenticated checks if the authentication is already loaded for the specified profile.
func (a *ArkAuthBase) IsAuthenticated(profile *models.ArkProfile) bool <span class="cov0" title="0">{
        var err error
        a.Logger.Info("Checking if [%s] is authenticated", a.Authenticator.AuthenticatorName())
        if a.Token != nil </span><span class="cov0" title="0">{
                a.Logger.Info("Token is already loaded")
                return true
        }</span>
        <span class="cov0" title="0">if ap, ok := profile.AuthProfiles[a.Authenticator.AuthenticatorName()]; ok &amp;&amp; a.CacheKeyring != nil </span><span class="cov0" title="0">{
                a.Token, err = a.CacheKeyring.LoadToken(profile, ap.Username, false)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if a.Token != nil &amp;&amp; time.Time(a.Token.ExpiresIn).Before(time.Now()) </span><span class="cov0" title="0">{
                        a.Token = nil
                }</span> else<span class="cov0" title="0"> {
                        a.Logger.Info("Loaded token from cache successfully")
                }</span>
                <span class="cov0" title="0">return a.Token != nil</span>
        }
        <span class="cov0" title="0">return false</span>
}

// LoadAuthentication loads the authentication token for the specified profile and refreshes it if necessary.
func (a *ArkAuthBase) LoadAuthentication(profile *models.ArkProfile, refreshAuth bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        var err error
        a.Logger.Info("Trying to load [%s] authentication", a.Authenticator.AuthenticatorName())
        if profile == nil </span><span class="cov0" title="0">{
                if a.ActiveProfile != nil </span><span class="cov0" title="0">{
                        profile = a.ActiveProfile
                }</span> else<span class="cov0" title="0"> {
                        profilesLoader := profiles.DefaultProfilesLoader()
                        profile, _ = (*profilesLoader).LoadDefaultProfile()
                }</span>
        }
        <span class="cov0" title="0">authProfile := a.ActiveAuthProfile
        if authProfile == nil </span><span class="cov0" title="0">{
                if ap, ok := profile.AuthProfiles[a.Authenticator.AuthenticatorName()]; ok </span><span class="cov0" title="0">{
                        authProfile = ap
                }</span>
        }
        <span class="cov0" title="0">if authProfile != nil </span><span class="cov0" title="0">{
                a.Logger.Info("Loading authentication for profile [%s] and auth profile [%s] of type [%s]", profile.ProfileName, a.Authenticator.AuthenticatorName(), string(authProfile.AuthMethod))
                if a.CacheKeyring != nil </span><span class="cov0" title="0">{
                        a.Token, err = a.CacheKeyring.LoadToken(profile, a.ResolveCachePostfix(authProfile), false)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">if refreshAuth </span><span class="cov0" title="0">{
                        if a.Token != nil &amp;&amp; time.Time(a.Token.ExpiresIn).Add(-time.Duration(defaultExpirationGraceDeltaSeconds)*time.Second).After(time.Now()) </span><span class="cov0" title="0">{
                                a.Logger.Info("Token did not pass grace expiration, no need to refresh")
                        }</span> else<span class="cov0" title="0"> {
                                a.Logger.Info("Trying to refresh token authentication")
                                a.Token, _ = a.Authenticator.performRefreshAuthentication(profile, authProfile, a.Token)
                                if a.Token != nil &amp;&amp; time.Time(a.Token.ExpiresIn).After(time.Now()) </span><span class="cov0" title="0">{
                                        a.Logger.Info("Token refreshed")
                                }</span>
                                <span class="cov0" title="0">if a.Token != nil &amp;&amp; a.CacheAuthentication &amp;&amp; a.CacheKeyring != nil </span><span class="cov0" title="0">{
                                        err = a.CacheKeyring.SaveToken(profile, a.Token, a.ResolveCachePostfix(authProfile), false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if a.Token != nil &amp;&amp; time.Time(a.Token.ExpiresIn).Before(time.Now()) </span><span class="cov0" title="0">{
                        a.Token = nil
                }</span>
                <span class="cov0" title="0">if a.Token != nil </span><span class="cov0" title="0">{
                        a.ActiveProfile = profile
                        a.ActiveAuthProfile = authProfile
                }</span>
                <span class="cov0" title="0">return a.Token, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package auth

import (
        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
        "slices"
)

var (
        // SupportedAuthenticatorsList is a list of supported authenticators.
        SupportedAuthenticatorsList = []ArkAuth{
                NewArkISPAuth(true),
        }

        // SupportedAuthenticators is a map of supported authenticators.
        SupportedAuthenticators = func() map[string]ArkAuth <span class="cov0" title="0">{
                authenticators := make(map[string]ArkAuth)
                for _, auth := range SupportedAuthenticatorsList </span><span class="cov0" title="0">{
                        authenticators[auth.AuthenticatorName()] = auth
                }</span>
                <span class="cov0" title="0">return authenticators</span>
        }()

        // SupportedAuthMethods is a list of supported authentication methods.
        SupportedAuthMethods = func() []auth.ArkAuthMethod <span class="cov0" title="0">{
                authMethods := make([]auth.ArkAuthMethod, 0)
                for _, auth := range SupportedAuthenticatorsList </span><span class="cov0" title="0">{
                        for _, method := range auth.SupportedAuthMethods() </span><span class="cov0" title="0">{
                                if !slices.Contains(authMethods, method) </span><span class="cov0" title="0">{
                                        authMethods = append(authMethods, method)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return authMethods</span>
        }()
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package auth

import (
        "encoding/base64"
        "errors"
        "github.com/cyberark/ark-sdk-golang/pkg/auth/identity"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
        commonmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common"
        "time"
)

const (
        ispAuthName              = "isp"
        ispAuthHumanReadableName = "Identity Security Platform"
)

// DefaultTokenLifetime is the default token lifetime in seconds.
const (
        DefaultTokenLifetime = 3600
)

var (
        ispAuthMethods               = []auth.ArkAuthMethod{auth.Identity, auth.IdentityServiceUser}
        ispDefaultAuthMethod         = auth.Identity
        ispDefaultAuthMethodSettings = auth.IdentityArkAuthMethodSettings{}
)

// ArkISPAuth is a struct that implements the ArkAuth interface for the Identity Security Platform.
type ArkISPAuth struct {
        ArkAuth
        *ArkAuthBase
}

// NewArkISPAuth creates a new instance of ArkISPAuth.
func NewArkISPAuth(cacheAuthentication bool) ArkAuth <span class="cov0" title="0">{
        authenticator := &amp;ArkISPAuth{}
        var authInterface ArkAuth = authenticator
        baseAuth := NewArkAuthBase(cacheAuthentication, "ArkISPAuth", authInterface)
        authenticator.ArkAuthBase = baseAuth
        return authInterface
}</span>

func (a *ArkISPAuth) performIdentityAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        methodSettings := authProfile.AuthMethodSettings.(*auth.IdentityArkAuthMethodSettings)
        identityAuth, err := identity.NewArkIdentity(
                authProfile.Username,
                secret.Secret,
                methodSettings.IdentityURL,
                methodSettings.IdentityTenantSubdomain,
                methodSettings.IdentityMFAMethod,
                a.Logger,
                a.CacheAuthentication,
                a.CacheAuthentication,
                profile,
        )
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to create identity security platform object: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = identityAuth.AuthIdentity(profile, common.IsInteractive() &amp;&amp; methodSettings.IdentityMFAInteractive, force)
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to authenticate to identity security platform: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">env := commonmodels.GetDeployEnv()
        tokenLifetime := identityAuth.SessionDetails().TokenLifetime
        if tokenLifetime == 0 </span><span class="cov0" title="0">{
                tokenLifetime = DefaultTokenLifetime
        }</span>
        <span class="cov0" title="0">marshaledCookies, err := common.MarshalCookies(identityAuth.Session().GetCookieJar())
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to marshal cookies: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;auth.ArkToken{
                Token:        identityAuth.SessionToken(),
                Username:     authProfile.Username,
                Endpoint:     identityAuth.IdentityURL(),
                TokenType:    auth.JWT,
                AuthMethod:   auth.Identity,
                ExpiresIn:    commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(tokenLifetime) * time.Second)),
                RefreshToken: identityAuth.SessionDetails().RefreshToken,
                Metadata: map[string]interface{}{
                        "env":     env,
                        "cookies": base64.StdEncoding.EncodeToString(marshaledCookies),
                },
        }, nil</span>
}

func (a *ArkISPAuth) performIdentityRefreshAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, token *auth.ArkToken) (*auth.ArkToken, error) <span class="cov0" title="0">{
        methodSettings := authProfile.AuthMethodSettings.(*auth.IdentityArkAuthMethodSettings)
        identityAuth, err := identity.NewArkIdentity(
                authProfile.Username,
                "",
                methodSettings.IdentityURL,
                methodSettings.IdentityTenantSubdomain,
                methodSettings.IdentityMFAMethod,
                a.Logger,
                a.CacheAuthentication,
                a.CacheAuthentication,
                profile,
        )
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to create identity security platform object: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = identityAuth.RefreshAuthIdentity(profile, methodSettings.IdentityMFAInteractive, false)
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to refresh authentication to identity security platform: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">env := commonmodels.GetDeployEnv()
        tokenLifetime := identityAuth.SessionDetails().TokenLifetime
        if tokenLifetime == 0 </span><span class="cov0" title="0">{
                tokenLifetime = DefaultTokenLifetime
        }</span>
        <span class="cov0" title="0">marshaledCookies, err := common.MarshalCookies(identityAuth.Session().GetCookieJar())
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to marshal cookies: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;auth.ArkToken{
                Token:        identityAuth.SessionToken(),
                Username:     authProfile.Username,
                Endpoint:     identityAuth.IdentityURL(),
                TokenType:    auth.JWT,
                AuthMethod:   auth.Identity,
                ExpiresIn:    commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(tokenLifetime) * time.Second)),
                RefreshToken: identityAuth.SessionDetails().RefreshToken,
                Metadata: map[string]interface{}{
                        "env":     env,
                        "cookies": base64.StdEncoding.EncodeToString(marshaledCookies),
                },
        }, nil</span>
}

func (a *ArkISPAuth) performIdentityServiceUserAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        if secret == nil </span><span class="cov0" title="0">{
                return nil, errors.New("token secret is required for identity service user auth")
        }</span>
        <span class="cov0" title="0">methodSettings := authProfile.AuthMethodSettings.(auth.IdentityServiceUserArkAuthMethodSettings)
        identityAuth, err := identity.NewArkIdentityServiceUser(
                authProfile.Username,
                secret.Secret,
                methodSettings.IdentityAuthorizationApplication,
                methodSettings.IdentityURL,
                methodSettings.IdentityTenantSubdomain,
                a.Logger,
                a.CacheAuthentication,
                a.CacheAuthentication,
                profile,
        )
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to create identity security platform object with service user: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">err = identityAuth.AuthIdentity(profile, force)
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to authenticate to identity security platform with service user: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">env := commonmodels.GetDeployEnv()
        marshaledCookies, err := common.MarshalCookies(identityAuth.Session().GetCookieJar())
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("Failed to marshal cookies: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;auth.ArkToken{
                Token:      identityAuth.SessionToken(),
                Username:   authProfile.Username,
                Endpoint:   identityAuth.IdentityURL(),
                TokenType:  auth.JWT,
                AuthMethod: auth.Identity,
                ExpiresIn:  commonmodels.ArkRFC3339Time(time.Now().Add(4 * time.Hour)),
                Metadata: map[string]interface{}{
                        "env":     env,
                        "cookies": base64.StdEncoding.EncodeToString(marshaledCookies),
                },
        }, nil</span>
}

// performAuthentication performs authentication to the ISP using the specified auth method.
func (a *ArkISPAuth) performAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        a.Logger.Info("Performing authentication to ISP")
        switch authProfile.AuthMethod </span>{
        case auth.Identity, auth.Default:<span class="cov0" title="0">
                return a.performIdentityAuthentication(profile, authProfile, secret, force)</span>
        case auth.IdentityServiceUser:<span class="cov0" title="0">
                return a.performIdentityServiceUserAuthentication(profile, authProfile, secret, force)</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("given auth method is not supported")</span>
        }
}

// PerformRefreshAuthentication performs refresh authentication to the ISP.
func (a *ArkISPAuth) performRefreshAuthentication(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, token *auth.ArkToken) (*auth.ArkToken, error) <span class="cov0" title="0">{
        a.Logger.Info("Performing refresh authentication to ISP")
        if authProfile.AuthMethod == auth.Identity || authProfile.AuthMethod == auth.Default </span><span class="cov0" title="0">{
                return a.performIdentityRefreshAuthentication(profile, authProfile, token)
        }</span>
        <span class="cov0" title="0">return token, nil</span>
}

// LoadAuthentication loads the authentication token from the cache or performs authentication if not found.
func (a *ArkISPAuth) LoadAuthentication(profile *models.ArkProfile, refreshAuth bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        return a.ArkAuthBase.LoadAuthentication(profile, refreshAuth)
}</span>

// Authenticate performs authentication using the specified profile and authentication profile.
func (a *ArkISPAuth) Authenticate(profile *models.ArkProfile, authProfile *auth.ArkAuthProfile, secret *auth.ArkSecret, force bool, refreshAuth bool) (*auth.ArkToken, error) <span class="cov0" title="0">{
        return a.ArkAuthBase.Authenticate(profile, authProfile, secret, force, refreshAuth)
}</span>

// IsAuthenticated checks if the user is authenticated using the specified profile.
func (a *ArkISPAuth) IsAuthenticated(profile *models.ArkProfile) bool <span class="cov0" title="0">{
        return a.ArkAuthBase.IsAuthenticated(profile)
}</span>

// AuthenticatorName returns the name of the ISP authenticator.
func (a *ArkISPAuth) AuthenticatorName() string <span class="cov0" title="0">{
        return ispAuthName
}</span>

// AuthenticatorHumanReadableName returns the human-readable name of the ISP authenticator.
func (a *ArkISPAuth) AuthenticatorHumanReadableName() string <span class="cov0" title="0">{
        return ispAuthHumanReadableName
}</span>

// SupportedAuthMethods returns the supported authentication methods for the ISP authenticator.
func (a *ArkISPAuth) SupportedAuthMethods() []auth.ArkAuthMethod <span class="cov0" title="0">{
        return ispAuthMethods
}</span>

// DefaultAuthMethod returns the default authentication method and its settings for the ISP authenticator.
func (a *ArkISPAuth) DefaultAuthMethod() (auth.ArkAuthMethod, auth.ArkAuthMethodSettings) <span class="cov0" title="0">{
        return ispDefaultAuthMethod, ispDefaultAuthMethodSettings
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package identity

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "strings"
        "time"

        "github.com/Iilun/survey/v2"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
        commonmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models/common/identity"
        "github.com/golang-jwt/jwt/v5"
        "github.com/toqueteos/webbrowser"
)

const (
        recvRoutineInterval           = 3 * time.Second
        pollIntervalMs                = 500 * time.Millisecond
        pollTimeSeconds               = 360 * time.Second
        lastStartAuthRespDeltaSeconds = 30 * time.Second
        mechanismRetryCount           = 20
)

// DefaultTokenLifetimeSeconds is the default token lifetime in seconds.
const (
        DefaultTokenLifetimeSeconds = 3600
)

var factors = map[string]string{
        "otp":   "📲 Push / Code",
        "oath":  "🔐 OATH Code",
        "sms":   "📟 SMS",
        "email": "📧 Email",
        "pf":    "📞 Phone call",
        "up":    "🔑 User Password",
}

type lastStartAuthResponse struct {
        lastResponse *identity.StartAuthResponse
        timestamp    time.Time
        cookies      map[string]string
}

var lastStartAuthResponses = make(map[string]*lastStartAuthResponse)

var supportedIdentityMechanisms = []string{"pf", "sms", "email", "otp", "oath", "up"}

// ArkIdentity is a struct that represents an identity authentication session.
type ArkIdentity struct {
        username            string
        password            string
        mfaType             string
        logger              *common.ArkLogger
        cacheAuthentication bool
        session             *common.ArkClient
        sessionDetails      *identity.AdvanceAuthResult
        sessionExp          commonmodels.ArkRFC3339Time
        keyring             *common.ArkKeyring
        isPolling           bool
        interactionRoutine  chan string
}

// HasCacheRecord Checks if a cache record exists for the specified profile and username
func HasCacheRecord(profile *models.ArkProfile, username string, refreshAuthAllowed bool) (bool, error) <span class="cov0" title="0">{
        keyring := common.NewArkKeyring(strings.ToLower("ArkIdentity"))
        token, err := keyring.LoadToken(profile, username+"_identity", false)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">session, err := keyring.LoadToken(profile, username+"_identity_session", false)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if token != nil &amp;&amp; session != nil </span><span class="cov0" title="0">{
                if !time.Time(token.ExpiresIn).IsZero() &amp;&amp; time.Time(token.ExpiresIn).Before(time.Now()) </span><span class="cov0" title="0">{
                        if token.RefreshToken != "" &amp;&amp; refreshAuthAllowed </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>
                        <span class="cov0" title="0">return false, nil</span>
                }
                <span class="cov0" title="0">return true, nil</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

// IsIdpUser Checks whether or not the specified username is from an external IDP
func IsIdpUser(username string, identityURL *string, identityTenantSubdomain *string) (bool, error) <span class="cov0" title="0">{
        matched, err := regexp.MatchString(`.*@cyberark\.cloud\.\d+`, username)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if matched </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">ai, err := NewArkIdentity(username, "", *identityURL, *identityTenantSubdomain, "", common.GetLogger("IsIdpUser", common.Unknown), false, false, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">resp, err := ai.startAuthentication()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return resp.Result.IdpRedirectURL != "", nil</span>
}

// IsPasswordRequired Checks if a password is required for the specified username
func IsPasswordRequired(username string, identityURL string, identityTenantSubdomain string) bool <span class="cov0" title="0">{
        ai, err := NewArkIdentity(username, "", identityURL, identityTenantSubdomain, "", common.GetLogger("IsPasswordRequired", common.Unknown), false, false, nil)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">resp, err := ai.startAuthentication()
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">lastStartAuthResponses[fmt.Sprintf("%s_%s", ai.IdentityURL(), username)] = &amp;lastStartAuthResponse{
                lastResponse: resp,
                timestamp:    time.Now(),
                cookies:      ai.session.GetCookies(),
        }
        return resp.Result.IdpRedirectURL == "" &amp;&amp; len(resp.Result.Challenges) &gt; 0 &amp;&amp; resp.Result.Challenges[0].Mechanisms[0].Name == "UP"</span>
}

// NewArkIdentity creates a new ArkIdentity instance with the specified parameters.
func NewArkIdentity(username string, password string, identityURL string, identityTenantSubdomain string, mfaType string, logger *common.ArkLogger, cacheAuthentication bool, loadCache bool, cacheProfile *models.ArkProfile) (*ArkIdentity, error) <span class="cov0" title="0">{
        var err error
        if mfaType == "" </span><span class="cov0" title="0">{
                mfaType = "email"
        }</span>
        <span class="cov0" title="0">identityAuth := &amp;ArkIdentity{
                username:            username,
                password:            password,
                mfaType:             mfaType,
                logger:              logger,
                cacheAuthentication: cacheAuthentication,
                isPolling:           false,
        }

        if identityURL == "" </span><span class="cov0" title="0">{
                if identityTenantSubdomain != "" </span><span class="cov0" title="0">{
                        identityURL, err = ResolveTenantFqdnFromTenantSubdomain(identityTenantSubdomain, commonmodels.GetDeployEnv())
                }</span> else<span class="cov0" title="0"> {
                        tenantSuffix := username[strings.Index(username, "@"):]
                        identityURL, err = ResolveTenantFqdnFromTenantSuffix(tenantSuffix, commonmodels.IdentityEnvUrls[commonmodels.GetDeployEnv()])
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">identityAuth.session = common.NewSimpleArkClient(identityURL)
        identityAuth.session.SetHeaders(DefaultHeaders())

        if cacheAuthentication </span><span class="cov0" title="0">{
                identityAuth.keyring = common.NewArkKeyring(strings.ToLower("ArkIdentity"))
        }</span>

        <span class="cov0" title="0">if loadCache &amp;&amp; cacheAuthentication &amp;&amp; cacheProfile != nil </span><span class="cov0" title="0">{
                identityAuth.loadCache(cacheProfile)
        }</span>
        <span class="cov0" title="0">return identityAuth, nil</span>
}

func (ai *ArkIdentity) loadCache(profile *models.ArkProfile) bool <span class="cov0" title="0">{
        if ai.keyring != nil &amp;&amp; profile != nil </span><span class="cov0" title="0">{
                token, err := ai.keyring.LoadToken(profile, ai.username+"_identity", false)
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Error("Error loading token from cache: %v", err)
                        return false
                }</span>
                <span class="cov0" title="0">session, err := ai.keyring.LoadToken(profile, ai.username+"_identity_session", false)
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Error("Error loading session from cache: %v", err)
                        return false
                }</span>
                <span class="cov0" title="0">if token != nil &amp;&amp; session != nil </span><span class="cov0" title="0">{
                        err = json.Unmarshal([]byte(token.Token), &amp;ai.sessionDetails)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">ai.sessionExp = token.ExpiresIn
                        sessionInfo := map[string]interface{}{}
                        err = json.Unmarshal([]byte(session.Token), &amp;sessionInfo)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">ai.session = common.NewSimpleArkClient(session.Endpoint)
                        headers := make(map[string]string)
                        for k, v := range sessionInfo["headers"].(map[string]interface{}) </span><span class="cov0" title="0">{
                                headers[k] = v.(string)
                        }</span>
                        <span class="cov0" title="0">ai.session.SetHeaders(headers)

                        cookies := make(map[string]string)
                        for k, v := range sessionInfo["cookies"].(map[string]interface{}) </span><span class="cov0" title="0">{
                                cookies[k] = v.(string)
                        }</span>
                        <span class="cov0" title="0">ai.session.SetCookies(cookies)
                        ai.session.UpdateToken(ai.sessionDetails.Token, "Bearer")
                        return true</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (ai *ArkIdentity) saveCache(profile *models.ArkProfile) error <span class="cov0" title="0">{
        if ai.keyring != nil &amp;&amp; profile != nil &amp;&amp; ai.sessionDetails != nil </span><span class="cov0" title="0">{
                delta := ai.sessionDetails.TokenLifetime
                if delta == 0 </span><span class="cov0" title="0">{
                        delta = DefaultTokenLifetimeSeconds
                }</span>
                <span class="cov0" title="0">ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(delta) * time.Second))
                sessionDetailsBytes, err := json.Marshal(ai.sessionDetails)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = ai.keyring.SaveToken(profile, &amp;auth.ArkToken{
                        Token:      string(sessionDetailsBytes),
                        Username:   ai.username,
                        Endpoint:   ai.session.BaseURL,
                        TokenType:  auth.Internal,
                        AuthMethod: auth.Other,
                        ExpiresIn:  ai.sessionExp,
                }, ai.username+"_identity", false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sessionInfo := map[string]interface{}{
                        "headers": ai.session.GetHeaders(),
                        "cookies": ai.session.GetCookies(),
                }
                sessionInfoBytes, err := json.Marshal(sessionInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = ai.keyring.SaveToken(profile, &amp;auth.ArkToken{
                        Token:      string(sessionInfoBytes),
                        Username:   ai.username,
                        Endpoint:   ai.session.BaseURL,
                        TokenType:  auth.Internal,
                        AuthMethod: auth.Other,
                        ExpiresIn:  ai.sessionExp,
                }, ai.username+"_identity_session", false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ai *ArkIdentity) startAuthentication() (*identity.StartAuthResponse, error) <span class="cov0" title="0">{
        ai.logger.Info("Starting authentication with user %s and fqdn %s", ai.username, ai.session.BaseURL)
        response, err := ai.session.Post(
                context.Background(),
                "Security/StartAuthentication",
                map[string]interface{}{
                        "User":                  ai.username,
                        "Version":               "1.0",
                        "PlatformTokenResponse": true,
                        "AssociatedEntityType":  "API",
                        "MfaRequestor":          "DeviceAgent",
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)

        <span class="cov0" title="0">var parsedRes identity.StartAuthResponse
        if err = json.NewDecoder(response.Body).Decode(&amp;parsedRes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !parsedRes.Success </span><span class="cov0" title="0">{
                return nil, errors.New("failed to start authentication")
        }</span>
        <span class="cov0" title="0">if len(parsedRes.Result.Challenges) == 0 &amp;&amp; parsedRes.Result.IdpRedirectURL == "" </span><span class="cov0" title="0">{
                return nil, errors.New("no challenges or idp redirect url on start auth")
        }</span>

        <span class="cov0" title="0">return &amp;parsedRes, nil</span>
}

func (ai *ArkIdentity) advanceAuthentication(mechanismID string, sessionID string, answer string, action string, isIdpAuth bool) (interface{}, error) <span class="cov0" title="0">{
        ai.logger.Info("Advancing authentication with action %s", action)
        response, err := ai.session.Post(
                context.Background(),
                "Security/AdvanceAuthentication",
                map[string]interface{}{
                        "SessionId":   sessionID,
                        "MechanismId": mechanismID,
                        "Action":      action,
                        "Answer":      answer,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)
        <span class="cov0" title="0">bodyBytes, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if isIdpAuth </span><span class="cov0" title="0">{
                var finalRes identity.IdpAuthStatusResponse
                if err = json.Unmarshal(bodyBytes, &amp;finalRes); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;finalRes, nil</span>
        }
        <span class="cov0" title="0">var parsedRes identity.AdvanceAuthMidResponse
        if err = json.Unmarshal(bodyBytes, &amp;parsedRes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if parsedRes.Result.Summary == "LoginSuccess" </span><span class="cov0" title="0">{
                var finalRes identity.AdvanceAuthResponse
                if err = json.Unmarshal(bodyBytes, &amp;finalRes); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;finalRes, nil</span>
        }
        <span class="cov0" title="0">return &amp;parsedRes, nil</span>
}

func (ai *ArkIdentity) identityIdpAuthStatus(sessionID string) (*identity.IdpAuthStatusResponse, error) <span class="cov0" title="0">{
        ai.logger.Info("Checking identity idp authentication status with session %s", sessionID)
        response, err := ai.session.Post(
                context.Background(),
                "Security/OobAuthStatus",
                map[string]interface{}{
                        "SessionId": sessionID,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)
        <span class="cov0" title="0">bodyBytes, err := io.ReadAll(response.Body)
        var parsedRes identity.IdpAuthStatusResponse
        if err := json.Unmarshal(bodyBytes, &amp;parsedRes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;parsedRes, nil</span>
}

func (ai *ArkIdentity) performPinCodeIdpAuthentication(startAuthResponse *identity.StartAuthResponse, profile *models.ArkProfile, interactive bool) error <span class="cov0" title="0">{
        if !interactive </span><span class="cov0" title="0">{
                return errors.New("non-interactive mode is not supported for OOB PIN code authentication")
        }</span>
        <span class="cov0" title="0">var answer string
        prompt := &amp;survey.Password{
                Message: "Please enter the PIN code displayed after you logged in to your identity provider",
        }
        err := survey.AskOne(prompt, &amp;answer)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if answer == "" </span><span class="cov0" title="0">{
                return errors.New("PIN code cannot be empty")
        }</span>
        <span class="cov0" title="0">oobAdvanceResp, err := ai.advanceAuthentication("OOBAUTHPIN", startAuthResponse.Result.IdpLoginSessionID, answer, "Answer", true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !oobAdvanceResp.(*identity.IdpAuthStatusResponse).Success </span><span class="cov0" title="0">{
                return errors.New("failed to perform idp authentication with OOB PIN")
        }</span>
        <span class="cov0" title="0">if oobAdvanceResp.(*identity.IdpAuthStatusResponse).Result.Summary == "LoginSuccess" &amp;&amp; oobAdvanceResp.(*identity.IdpAuthStatusResponse).Result.Token != "" </span><span class="cov0" title="0">{
                ai.sessionDetails = &amp;identity.AdvanceAuthResult{
                        Token:         oobAdvanceResp.(*identity.IdpAuthStatusResponse).Result.Token,
                        TokenLifetime: oobAdvanceResp.(*identity.IdpAuthStatusResponse).Result.TokenLifetime,
                        RefreshToken:  oobAdvanceResp.(*identity.IdpAuthStatusResponse).Result.RefreshToken,
                }
                ai.session.UpdateToken(oobAdvanceResp.(*identity.IdpAuthStatusResponse).Result.Token, "Bearer")
                delta := ai.sessionDetails.TokenLifetime
                if delta == 0 </span><span class="cov0" title="0">{
                        delta = DefaultTokenLifetimeSeconds
                }</span>
                <span class="cov0" title="0">ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(delta) * time.Second))
                if ai.cacheAuthentication </span><span class="cov0" title="0">{
                        if err := ai.saveCache(profile); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return errors.New("failed to perform idp authentication with OOB PIN, please try again")</span>
}

func (ai *ArkIdentity) performIdpAuthentication(startAuthResponse *identity.StartAuthResponse, profile *models.ArkProfile, interactive bool) error <span class="cov0" title="0">{
        if ai.isPolling </span><span class="cov0" title="0">{
                return errors.New("MFA / IDP Polling is already in progress")
        }</span>
        <span class="cov0" title="0">if interactive </span><span class="cov0" title="0">{
                fmt.Printf("\nYou are now being redirected from your browser to your external identity provider for authentication\n"+
                        "If the browser did not open, you may also click the following URL to access your identity provider authentication\n\n"+
                        "%s\n", startAuthResponse.Result.IdpRedirectShortURL)
        }</span>

        // Error can be ignored
        <span class="cov0" title="0">_ = webbrowser.Open(startAuthResponse.Result.IdpRedirectShortURL)

        if startAuthResponse.Result.IdpOobAuthPinRequired </span><span class="cov0" title="0">{
                return ai.performPinCodeIdpAuthentication(startAuthResponse, profile, interactive)
        }</span>

        <span class="cov0" title="0">ai.isPolling = true
        startTime := time.Now()

        for ai.isPolling </span><span class="cov0" title="0">{
                currentTime := time.Now()
                if currentTime.Sub(startTime) &gt;= pollTimeSeconds </span><span class="cov0" title="0">{
                        ai.isPolling = false
                        return errors.New("timeout reached while polling for idp auth")
                }</span>

                <span class="cov0" title="0">idpAuthStatus, err := ai.identityIdpAuthStatus(startAuthResponse.Result.IdpLoginSessionID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !idpAuthStatus.Success </span><span class="cov0" title="0">{
                        return errors.New("failed to perform idp authentication")
                }</span>
                <span class="cov0" title="0">if idpAuthStatus.Result.State == "Success" &amp;&amp; idpAuthStatus.Result.Token != "" </span><span class="cov0" title="0">{
                        ai.sessionDetails = &amp;identity.AdvanceAuthResult{
                                Token:         idpAuthStatus.Result.Token,
                                TokenLifetime: idpAuthStatus.Result.TokenLifetime,
                                RefreshToken:  idpAuthStatus.Result.RefreshToken,
                        }
                        ai.session.UpdateToken(idpAuthStatus.Result.Token, "Bearer")
                        delta := ai.sessionDetails.TokenLifetime
                        if delta == 0 </span><span class="cov0" title="0">{
                                delta = DefaultTokenLifetimeSeconds
                        }</span>
                        <span class="cov0" title="0">ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(delta) * time.Second))
                        if ai.cacheAuthentication </span><span class="cov0" title="0">{
                                if err := ai.saveCache(profile); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">time.Sleep(pollIntervalMs)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ai *ArkIdentity) pickMechanism(challenge *identity.Challenge) (*identity.Mechanism, error) <span class="cov0" title="0">{
        var supportedMechanisms []*identity.Mechanism
        for _, m := range challenge.Mechanisms </span><span class="cov0" title="0">{
                for _, sm := range supportedIdentityMechanisms </span><span class="cov0" title="0">{
                        if strings.ToLower(m.Name) == sm </span><span class="cov0" title="0">{
                                supportedMechanisms = append(supportedMechanisms, &amp;m)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">options := make([]string, len(supportedMechanisms))
        for i, m := range supportedMechanisms </span><span class="cov0" title="0">{
                options[i] = factors[strings.ToLower(m.Name)]
        }</span>

        <span class="cov0" title="0">prompt := &amp;survey.Select{
                Message: "Please pick one of the following MFA methods",
                Options: options,
        }
        if ai.mfaType != "" </span><span class="cov0" title="0">{
                mfaTypeFactor := factors[strings.ToLower(ai.mfaType)]
                for _, option := range options </span><span class="cov0" title="0">{
                        if option == mfaTypeFactor </span><span class="cov0" title="0">{
                                prompt.Default = option
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">var selectedOption string
        err := survey.AskOne(prompt, &amp;selectedOption)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for name, value := range factors </span><span class="cov0" title="0">{
                if value == selectedOption </span><span class="cov0" title="0">{
                        selectedOption = name
                        break</span>
                }
        }
        <span class="cov0" title="0">ai.mfaType = selectedOption
        for _, m := range supportedMechanisms </span><span class="cov0" title="0">{
                if strings.ToLower(m.Name) == ai.mfaType </span><span class="cov0" title="0">{
                        return m, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New("selected MFA method not found in supported mechanisms")</span>
}

func (ai *ArkIdentity) inputRoutine(chanWrite chan string, chanRead chan string, mechanism *identity.Mechanism, oobAdvanceResp *identity.AdvanceAuthMidResponse) <span class="cov0" title="0">{
        currentTry := 0
        for </span><span class="cov0" title="0">{
                if currentTry == mechanismRetryCount </span><span class="cov0" title="0">{
                        chanWrite &lt;- "ERROR"
                        return
                }</span>
                <span class="cov0" title="0">var answer string
                if oobAdvanceResp.Result.GeneratedAuthValue != "" </span><span class="cov0" title="0">{
                        prompt := &amp;survey.Password{
                                Message: fmt.Sprintf("Sent Mobile Authenticator request to your device with a value of [%s]. Please follow the instructions to proceed with authentication or enter verification code here.", oobAdvanceResp.Result.GeneratedAuthValue),
                        }
                        err := survey.AskOne(prompt, &amp;answer)
                        if err != nil </span><span class="cov0" title="0">{
                                chanWrite &lt;- "ERROR"
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        prompt := &amp;survey.Password{
                                Message: mechanism.PromptMechChosen,
                        }
                        err := survey.AskOne(prompt, &amp;answer)
                        if err != nil </span><span class="cov0" title="0">{
                                chanWrite &lt;- "ERROR"
                                return
                        }</span>
                }
                <span class="cov0" title="0">if answer == "" </span><span class="cov0" title="0">{
                        chanWrite &lt;- "ERROR"
                        return
                }</span>
                <span class="cov0" title="0">chanWrite &lt;- answer
                time.Sleep(recvRoutineInterval)
                select </span>{
                case response := &lt;-chanRead:<span class="cov0" title="0">
                        if response == "CONTINUE" </span><span class="cov0" title="0">{
                                currentTry++
                                continue</span>
                        }
                        <span class="cov0" title="0">return</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }
        }
}

func (ai *ArkIdentity) startInputRoutine(pipeWrite chan string, pipeRead chan string, mechanism *identity.Mechanism, oobAdvanceResp *identity.AdvanceAuthMidResponse) error <span class="cov0" title="0">{
        if ai.interactionRoutine != nil </span><span class="cov0" title="0">{
                return errors.New("interaction thread is already in progress")
        }</span>
        <span class="cov0" title="0">ai.interactionRoutine = make(chan string)
        go ai.inputRoutine(pipeWrite, pipeRead, mechanism, oobAdvanceResp)
        return nil</span>
}

func (ai *ArkIdentity) stopInputRoutine(flush bool) <span class="cov0" title="0">{
        if ai.interactionRoutine != nil </span><span class="cov0" title="0">{
                close(ai.interactionRoutine)
                ai.interactionRoutine = nil
        }</span>
}

func (ai *ArkIdentity) pollAuthentication(profile *models.ArkProfile, mechanism *identity.Mechanism, startAuthResponse *identity.StartAuthResponse, oobAdvanceResp *identity.AdvanceAuthMidResponse, isInteractive bool) error <span class="cov0" title="0">{
        if ai.isPolling </span><span class="cov0" title="0">{
                return errors.New("MFA Polling is already in progress")
        }</span>
        <span class="cov0" title="0">ai.isPolling = true
        defer func() </span><span class="cov0" title="0">{ ai.isPolling = false }</span>()

        <span class="cov0" title="0">chanWrite := make(chan string)
        chanRead := make(chan string)

        if isInteractive </span><span class="cov0" title="0">{
                if err := ai.startInputRoutine(chanWrite, chanRead, mechanism, oobAdvanceResp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">startTime := time.Now()
        var advanceResp interface{} = nil
        var err error
        var flush = true
        for ai.isPolling </span><span class="cov0" title="0">{
                if time.Since(startTime) &gt;= pollTimeSeconds </span><span class="cov0" title="0">{
                        return errors.New("timeout reached while polling for user answer")
                }</span>

                <span class="cov0" title="0">select </span>{
                case mfaCode := &lt;-chanWrite:<span class="cov0" title="0">
                        if mfaCode == "ERROR" </span><span class="cov0" title="0">{
                                return errors.New("failed to get answer for MFA factor")
                        }</span>
                        <span class="cov0" title="0">advanceResp, err = ai.advanceAuthentication(mechanism.MechanismID, startAuthResponse.Result.SessionID, mfaCode, "Answer", false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if _, ok := advanceResp.(*identity.AdvanceAuthResponse); ok </span><span class="cov0" title="0">{
                                chanRead &lt;- "DONE"
                                flush = false
                                break</span>
                        } else<span class="cov0" title="0"> if midResp, ok := advanceResp.(*identity.AdvanceAuthMidResponse); ok </span><span class="cov0" title="0">{
                                if !midResp.Success </span><span class="cov0" title="0">{
                                        flush = false
                                        ai.isPolling = false
                                        if isInteractive </span><span class="cov0" title="0">{
                                                ai.stopInputRoutine(flush)
                                        }</span>
                                        <span class="cov0" title="0">return errors.New("failed to advance authentication")</span>
                                }
                                <span class="cov0" title="0">if midResp.Result.Summary == "NewPackage" </span><span class="cov0" title="0">{
                                        flush = false
                                        ai.isPolling = false
                                        if isInteractive </span><span class="cov0" title="0">{
                                                ai.stopInputRoutine(flush)
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }
                        } else<span class="cov0" title="0"> {
                                chanRead &lt;- "CONTINUE"
                        }</span>
                case &lt;-time.After(pollIntervalMs):<span class="cov0" title="0">
                        advanceResp, err = ai.advanceAuthentication(mechanism.MechanismID, startAuthResponse.Result.SessionID, "", "Poll", false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if advanceResp != nil </span><span class="cov0" title="0">{
                        if _, ok := advanceResp.(*identity.AdvanceAuthResponse); ok </span><span class="cov0" title="0">{
                                ai.isPolling = false
                                if isInteractive </span><span class="cov0" title="0">{
                                        ai.stopInputRoutine(flush)
                                }</span>
                                <span class="cov0" title="0">ai.sessionDetails = &amp;advanceResp.(*identity.AdvanceAuthResponse).Result
                                ai.session.UpdateToken(ai.sessionDetails.Token, "Bearer")
                                delta := ai.sessionDetails.TokenLifetime
                                if delta == 0 </span><span class="cov0" title="0">{
                                        delta = DefaultTokenLifetimeSeconds
                                }</span>
                                <span class="cov0" title="0">ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(delta) * time.Second))
                                if ai.cacheAuthentication </span><span class="cov0" title="0">{
                                        if err := ai.saveCache(profile); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        } else<span class="cov0" title="0"> if midResp, ok := advanceResp.(*identity.AdvanceAuthMidResponse); ok </span><span class="cov0" title="0">{
                                if midResp.Result.Summary == "NewPackage" </span><span class="cov0" title="0">{
                                        ai.isPolling = false
                                        if isInteractive </span><span class="cov0" title="0">{
                                                ai.stopInputRoutine(flush)
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ai *ArkIdentity) performUpAuthentication(
        profile *models.ArkProfile, mechanism *identity.Mechanism, interactive bool,
        startAuthResponse *identity.StartAuthResponse,
        currentChallengeIdx int) (string, int, error) <span class="cov0" title="0">{
        currentChallengeIdx++
        if ai.password == "" </span><span class="cov0" title="0">{
                if !interactive </span><span class="cov0" title="0">{
                        return "", -1, errors.New("no password and not interactive, cannot continue")
                }</span>
                <span class="cov0" title="0">var answer string
                prompt := &amp;survey.Password{
                        Message: "Identity Security Platform Secret",
                }
                err := survey.AskOne(prompt, &amp;answer)
                if err != nil </span><span class="cov0" title="0">{
                        return "", -1, err
                }</span>
                <span class="cov0" title="0">if answer == "" </span><span class="cov0" title="0">{
                        return "", -1, errors.New("empty response by user")
                }</span>
                <span class="cov0" title="0">ai.password = answer</span>
        }
        <span class="cov0" title="0">advanceResp, err := ai.advanceAuthentication(mechanism.MechanismID, startAuthResponse.Result.SessionID, ai.password, "Answer", false)
        if err != nil </span><span class="cov0" title="0">{
                return "", -1, err
        }</span>
        <span class="cov0" title="0">if _, ok := advanceResp.(*identity.AdvanceAuthResponse); ok &amp;&amp; len(startAuthResponse.Result.Challenges) == 1 </span><span class="cov0" title="0">{
                ai.sessionDetails = &amp;advanceResp.(*identity.AdvanceAuthResponse).Result
                ai.session.UpdateToken(ai.sessionDetails.Token, "Bearer")
                delta := ai.sessionDetails.TokenLifetime
                if delta == 0 </span><span class="cov0" title="0">{
                        delta = DefaultTokenLifetimeSeconds
                }</span>
                <span class="cov0" title="0">ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(delta) * time.Second))
                if ai.cacheAuthentication </span><span class="cov0" title="0">{
                        if err := ai.saveCache(profile); err != nil </span><span class="cov0" title="0">{
                                return "", -1, err
                        }</span>
                }
                <span class="cov0" title="0">return "DONE", currentChallengeIdx, nil</span>
        }
        <span class="cov0" title="0">if midResp, ok := advanceResp.(*identity.AdvanceAuthMidResponse); ok </span><span class="cov0" title="0">{
                if !midResp.Success </span><span class="cov0" title="0">{
                        return "ERROR", currentChallengeIdx, fmt.Errorf("failed to advance auth [%v]", midResp.Message)
                }</span>
        }
        <span class="cov0" title="0">return "CONTINUE", currentChallengeIdx, nil</span>
}

// GetApps Returns the applications to which the user is logged in.
func (ai *ArkIdentity) GetApps() (map[string]interface{}, error) <span class="cov0" title="0">{
        if ai.sessionDetails == nil </span><span class="cov0" title="0">{
                return nil, errors.New("identity authentication is required first")
        }</span>

        // Save the current cookies
        <span class="cov0" title="0">cookies := ai.session.GetCookies()
        response, err := ai.session.Post(
                context.Background(),
                "UPRest/GetUPData",
                nil,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)

        // Restore the cookies
        <span class="cov0" title="0">ai.session.SetCookies(cookies)

        // Parse the response
        var result map[string]interface{}
        if err := json.NewDecoder(response.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// AuthIdentity Authenticates to Identity with the information specified in the constructor.
// If MFA is configured and `interactive` is enabled, the user is prompted for the MFA secret.
// The auth token and other details are stored in the object for future use.
func (ai *ArkIdentity) AuthIdentity(profile *models.ArkProfile, interactive bool, force bool) error <span class="cov0" title="0">{
        ai.logger.Debug("Attempting to authenticate to Identity")
        ai.sessionDetails = nil
        if ai.cacheAuthentication &amp;&amp; !force &amp;&amp; ai.loadCache(profile) </span><span class="cov0" title="0">{
                if time.Time(ai.sessionExp).After(time.Now()) </span><span class="cov0" title="0">{
                        ai.logger.Info("Loaded identity details from cache")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">ai.session = common.NewSimpleArkClient(ai.session.BaseURL)
        ai.session.SetHeaders(DefaultHeaders())
        var startAuthResponse *identity.StartAuthResponse
        var err error
        cacheKey := fmt.Sprintf("%s_%s", ai.IdentityURL(), ai.username)
        if cachedResponse, exists := lastStartAuthResponses[cacheKey]; exists </span><span class="cov0" title="0">{
                if time.Since(cachedResponse.timestamp).Seconds() &lt; lastStartAuthRespDeltaSeconds.Seconds() </span><span class="cov0" title="0">{
                        startAuthResponse = cachedResponse.lastResponse
                        ai.session.SetCookies(cachedResponse.cookies)
                }</span>
                <span class="cov0" title="0">delete(lastStartAuthResponses, cacheKey)</span>
        }

        <span class="cov0" title="0">if startAuthResponse == nil </span><span class="cov0" title="0">{
                startAuthResponse, err = ai.startAuthentication()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if startAuthResponse.Result.IdpRedirectURL != "" </span><span class="cov0" title="0">{
                return ai.performIdpAuthentication(startAuthResponse, profile, interactive)
        }</span>

        <span class="cov0" title="0">currentChallengeIdx := 0
        var result string
        if len(startAuthResponse.Result.Challenges[currentChallengeIdx].Mechanisms) &gt; 1 &amp;&amp; interactive </span><span class="cov0" title="0">{
                mechanism, err := ai.pickMechanism(&amp;startAuthResponse.Result.Challenges[currentChallengeIdx])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if strings.ToLower(mechanism.Name) == "up" </span><span class="cov0" title="0">{
                        result, currentChallengeIdx, err = ai.performUpAuthentication(profile, mechanism, interactive, startAuthResponse, currentChallengeIdx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if result == "DONE" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        currentChallengeIdx++
                        oobAdvanceResp, err := ai.advanceAuthentication(mechanism.MechanismID, startAuthResponse.Result.SessionID, "", "StartOOB", false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">err = ai.pollAuthentication(profile, mechanism, startAuthResponse, oobAdvanceResp.(*identity.AdvanceAuthMidResponse), interactive)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if ai.sessionDetails != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                mechanism := &amp;startAuthResponse.Result.Challenges[currentChallengeIdx].Mechanisms[0]
                if strings.ToLower(mechanism.Name) == "up" </span><span class="cov0" title="0">{
                        result, currentChallengeIdx, err = ai.performUpAuthentication(profile, mechanism, interactive, startAuthResponse, currentChallengeIdx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if result == "DONE" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">if interactive </span><span class="cov0" title="0">{
                if _, err = ai.pickMechanism(&amp;startAuthResponse.Result.Challenges[currentChallengeIdx]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if ai.mfaType != "" &amp;&amp; currentChallengeIdx == 1 </span><span class="cov0" title="0">{
                for _, mechanism := range startAuthResponse.Result.Challenges[currentChallengeIdx].Mechanisms </span><span class="cov0" title="0">{
                        if strings.ToLower(mechanism.Name) == ai.mfaType </span><span class="cov0" title="0">{
                                oobAdvanceResp, err := ai.advanceAuthentication(mechanism.MechanismID, startAuthResponse.Result.SessionID, "", "StartOOB", false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return ai.pollAuthentication(profile, &amp;mechanism, startAuthResponse, oobAdvanceResp.(*identity.AdvanceAuthMidResponse), interactive)</span>
                        }
                }
        }

        <span class="cov0" title="0">if !interactive </span><span class="cov0" title="0">{
                return errors.New("user interaction is not supported while not interactive and mfa type given was not found")
        }</span>

        <span class="cov0" title="0">for _, challenge := range startAuthResponse.Result.Challenges[currentChallengeIdx:] </span><span class="cov0" title="0">{
                mechanism, err := ai.pickMechanism(&amp;challenge)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">oobAdvanceResp, err := ai.advanceAuthentication(mechanism.MechanismID, startAuthResponse.Result.SessionID, "", "StartOOB", false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := ai.pollAuthentication(profile, mechanism, startAuthResponse, oobAdvanceResp.(*identity.AdvanceAuthMidResponse), interactive); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RefreshAuthIdentity Performs a token refresh with the object's existing details.
func (ai *ArkIdentity) RefreshAuthIdentity(profile *models.ArkProfile, interactive bool, force bool) error <span class="cov0" title="0">{
        if ai.sessionDetails == nil || ai.sessionDetails.Token == "" </span><span class="cov0" title="0">{
                // We only refresh platform token at the moment, call the normal authentication instead
                return ai.AuthIdentity(profile, interactive, force)
        }</span>

        <span class="cov0" title="0">ai.logger.Debug("Attempting to refresh authenticate to Identity")
        var savedCookies map[string]string
        if ai.session != nil </span><span class="cov0" title="0">{
                savedCookies = ai.session.GetCookies()
        }</span>
        <span class="cov0" title="0">ai.session = common.NewSimpleArkClient(ai.session.BaseURL)
        ai.session.SetHeaders(DefaultHeaders())

        // Decode the token to get the tenant ID
        token, _, err := new(jwt.Parser).ParseUnverified(ai.sessionDetails.Token, jwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">claims := token.Claims.(jwt.MapClaims)
        platformTenantID := claims["tenant_id"].(string)

        refreshCookies := map[string]string{
                fmt.Sprintf("refreshToken-%s", platformTenantID): ai.sessionDetails.RefreshToken,
                fmt.Sprintf("idToken-%s", platformTenantID):      ai.sessionDetails.Token,
        }
        ai.session.SetCookies(refreshCookies)
        response, err := ai.session.Post(context.Background(), "OAuth2/RefreshPlatformToken", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)

        <span class="cov0" title="0">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return errors.New("failed to refresh token")
        }</span>

        <span class="cov0" title="0">var newToken, newRefreshToken string
        for _, cookie := range response.Cookies() </span><span class="cov0" title="0">{
                if cookie.Name == fmt.Sprintf("idToken-%s", platformTenantID) </span><span class="cov0" title="0">{
                        newToken = cookie.Value
                }</span>
                <span class="cov0" title="0">if cookie.Name == fmt.Sprintf("refreshToken-%s", platformTenantID) </span><span class="cov0" title="0">{
                        newRefreshToken = cookie.Value
                }</span>
        }

        <span class="cov0" title="0">if newToken == "" || newRefreshToken == "" </span><span class="cov0" title="0">{
                return errors.New("failed to retrieve refresh tokens cookies")
        }</span>

        <span class="cov0" title="0">if savedCookies != nil </span><span class="cov0" title="0">{
                ai.session.SetCookies(savedCookies)
        }</span>
        <span class="cov0" title="0">ai.session.UpdateToken(newToken, "Bearer")

        ai.sessionDetails.Token = newToken
        ai.sessionDetails.RefreshToken = newRefreshToken

        // Decode the new token to get the expiration time
        newTokenClaims, _, err := new(jwt.Parser).ParseUnverified(newToken, jwt.MapClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newClaims := newTokenClaims.Claims.(jwt.MapClaims)
        exp := int64(newClaims["exp"].(float64))
        iat := int64(newClaims["iat"].(float64))
        ai.sessionDetails.TokenLifetime = int(exp - iat)

        delta := ai.sessionDetails.TokenLifetime
        if delta == 0 </span><span class="cov0" title="0">{
                delta = DefaultTokenLifetimeSeconds
        }</span>
        <span class="cov0" title="0">ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(time.Duration(delta) * time.Second))

        if ai.cacheAuthentication </span><span class="cov0" title="0">{
                if err := ai.saveCache(profile); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Session returns the current identity session
func (ai *ArkIdentity) Session() *common.ArkClient <span class="cov0" title="0">{
        return ai.session
}</span>

// SessionToken returns the current identity session token if logged in
func (ai *ArkIdentity) SessionToken() string <span class="cov0" title="0">{
        if ai.sessionDetails != nil </span><span class="cov0" title="0">{
                if ai.sessionDetails.Token != "" </span><span class="cov0" title="0">{
                        return ai.sessionDetails.Token
                }</span>
                <span class="cov0" title="0">if ai.sessionDetails.Auth != "" </span><span class="cov0" title="0">{
                        return ai.sessionDetails.Auth
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// SessionDetails returns the current identity session details if logged in
func (ai *ArkIdentity) SessionDetails() *identity.AdvanceAuthResult <span class="cov0" title="0">{
        return ai.sessionDetails
}</span>

// IdentityURL returns the current identity URL
func (ai *ArkIdentity) IdentityURL() string <span class="cov0" title="0">{
        return ai.session.BaseURL
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package identity

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/cyberark/ark-sdk-golang/pkg/common"
        commonmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models/common/identity"
)

const (
        discoveryServiceDomainName = "platform-discovery"
        discoveryTimeout           = 30
)

// DefaultHeaders returns the default headers for HTTP requests to identity.
func DefaultHeaders() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "Content-Type":         "application/json",
                "X-IDAP-NATIVE-CLIENT": "true",
                "User-Agent":           common.UserAgent(),
                "OobIdPAuth":           "true",
        }
}</span>

// DefaultSystemHeaders returns the default system headers for HTTP requests to identity.
func DefaultSystemHeaders() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "X-IDAP-NATIVE-CLIENT": "true",
                "User-Agent":           common.UserAgent(),
        }
}</span>

// ResolveTenantFqdnFromTenantSubdomain resolves the tenant's FQDN URL from its subdomain.
// The resolved URL is based on the current working environment, which is provided in the `tenantSubdomain` argument.
func ResolveTenantFqdnFromTenantSubdomain(tenantSubdomain string, env commonmodels.AwsEnv) (string, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), discoveryTimeout*time.Second)
        defer cancel()
        client := common.NewSimpleArkClient(fmt.Sprintf("https://%s.%s", discoveryServiceDomainName, commonmodels.RootDomain[env]))
        client.SetHeaders(map[string]string{
                "Content-Type": "application/json",
        })
        response, err := client.Get(ctx, fmt.Sprintf("api/identity-endpoint/%s", tenantSubdomain), nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("getting tenant FQDN failed from platform discovery: %v", err)
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        common.GlobalLogger.Warning("Error closing response body")
                }</span>
        }(response.Body)
        <span class="cov0" title="0">if response.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                var parsedResponse identity.TenantEndpointResponse
                if err := json.NewDecoder(response.Body).Decode(&amp;parsedResponse); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("getting tenant FQDN failed from platform discovery to be parsed / validated")
                }</span>
                <span class="cov0" title="0">return parsedResponse.Endpoint, nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("getting tenant FQDN failed from platform discovery [%d] - [%s]", response.StatusCode, response.Status)</span>
}

// ResolveTenantFqdnFromTenantSuffix resolves the tenant's FQDN URL from its suffix.
func ResolveTenantFqdnFromTenantSuffix(tenantSuffix string, identityEnvURL string) (string, error) <span class="cov0" title="0">{
        if identityEnvURL == "" </span><span class="cov0" title="0">{
                identityEnvURL = commonmodels.IdentityEnvUrls[commonmodels.GetDeployEnv()]
        }</span>
        <span class="cov0" title="0">client := common.NewSimpleArkClient(fmt.Sprintf("https://pod0.%s", identityEnvURL))
        client.SetHeaders(map[string]string{
                "Content-Type":          "application/json",
                "X-IDAP-NATIVE-CLIENT'": "true",
        })
        body := map[string]interface{}{
                "User":                  tenantSuffix,
                "Version":               "1.0",
                "PlatformTokenResponse": true,
                "MfaRequestor":          "DeviceAgent",
        }
        response, err := client.Post(context.Background(), "Security/StartAuthentication", body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if response.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                var parsedResponse identity.TenantFqdnResponse
                if err := json.NewDecoder(response.Body).Decode(&amp;parsedResponse); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("getting tenant FQDN failed from identity to be parsed / validated")
                }</span>
                <span class="cov0" title="0">if !parsedResponse.Success || parsedResponse.Result.PodFqdn == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("getting tenant FQDN failed from identity: %s", parsedResponse.Message)
                }</span>
                <span class="cov0" title="0">fqdn := parsedResponse.Result.PodFqdn
                if !strings.HasPrefix(fqdn, "https://") </span><span class="cov0" title="0">{
                        fqdn = "https://" + fqdn
                }</span>
                <span class="cov0" title="0">return fqdn, nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("getting tenant FQDN failed from identity [%d] - [%s]", response.StatusCode, response.Status)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package identity

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
        commonmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common"
)

// ArkIdentityServiceUser is a struct that represents identity authentication with service user.
type ArkIdentityServiceUser struct {
        username            string
        token               string
        appName             string
        identityURL         string
        logger              *common.ArkLogger
        keyring             *common.ArkKeyring
        cacheAuthentication bool
        session             *common.ArkClient
        sessionToken        string
        sessionExp          commonmodels.ArkRFC3339Time
}

// NewArkIdentityServiceUser creates a new instance of ArkIdentityServiceUser.
func NewArkIdentityServiceUser(username string, token string, appName string, identityURL string, identityTenantSubdomain string, logger *common.ArkLogger, cacheAuthentication bool, loadCache bool, cacheProfile *models.ArkProfile) (*ArkIdentityServiceUser, error) <span class="cov0" title="0">{
        identityServiceAuth := &amp;ArkIdentityServiceUser{
                username:            username,
                token:               token,
                appName:             appName,
                identityURL:         identityURL,
                logger:              logger,
                cacheAuthentication: cacheAuthentication,
        }
        var err error
        if identityURL == "" </span><span class="cov0" title="0">{
                if identityTenantSubdomain != "" </span><span class="cov0" title="0">{
                        identityURL, err = ResolveTenantFqdnFromTenantSubdomain(identityTenantSubdomain, commonmodels.GetDeployEnv())
                }</span> else<span class="cov0" title="0"> {
                        tenantSuffix := username[strings.Index(username, "@"):]
                        identityURL, err = ResolveTenantFqdnFromTenantSuffix(tenantSuffix, commonmodels.IdentityEnvUrls[commonmodels.GetDeployEnv()])
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">identityServiceAuth.session = common.NewSimpleArkClient(identityURL)

        if cacheAuthentication </span><span class="cov0" title="0">{
                identityServiceAuth.keyring = common.NewArkKeyring(strings.ToLower("ArkIdentity"))
        }</span>
        <span class="cov0" title="0">if loadCache &amp;&amp; cacheAuthentication &amp;&amp; cacheProfile != nil </span><span class="cov0" title="0">{
                identityServiceAuth.loadCache(cacheProfile)
        }</span>
        <span class="cov0" title="0">return identityServiceAuth, nil</span>
}

func (ai *ArkIdentityServiceUser) loadCache(profile *models.ArkProfile) bool <span class="cov0" title="0">{
        if ai.keyring != nil &amp;&amp; profile != nil </span><span class="cov0" title="0">{
                token, err := ai.keyring.LoadToken(profile, ai.username+"_identity_service_user", false)
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Error("Error loading token from cache: %v", err.Error())
                        return false
                }</span>
                <span class="cov0" title="0">if token != nil &amp;&amp; token.Username == ai.username </span><span class="cov0" title="0">{
                        ai.sessionToken = token.Token
                        ai.sessionExp = token.ExpiresIn
                        ai.session.UpdateToken(ai.sessionToken, "Bearer")
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ai *ArkIdentityServiceUser) saveCache(profile *models.ArkProfile) error <span class="cov0" title="0">{
        if ai.keyring != nil &amp;&amp; profile != nil &amp;&amp; ai.sessionToken != "" </span><span class="cov0" title="0">{
                ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(4 * time.Hour))
                err := ai.keyring.SaveToken(profile, &amp;auth.ArkToken{
                        Token:      ai.sessionToken,
                        Username:   ai.username,
                        Endpoint:   ai.session.BaseURL,
                        TokenType:  auth.Internal,
                        AuthMethod: auth.Other,
                        ExpiresIn:  ai.sessionExp,
                }, ai.username+"_identity_service_user", false)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AuthIdentity Authenticates to Identity with a service user.
// This method creates an auth token and authorizes to the service.
func (ai *ArkIdentityServiceUser) AuthIdentity(profile *models.ArkProfile, force bool) error <span class="cov0" title="0">{
        ai.logger.Info("Authenticating to service user via endpoint [%s]", ai.identityURL)
        if ai.cacheAuthentication &amp;&amp; !force &amp;&amp; ai.loadCache(profile) </span><span class="cov0" title="0">{
                if time.Time(ai.sessionExp).After(time.Now()) </span><span class="cov0" title="0">{
                        ai.logger.Info("Loaded identity service user details from cache")
                        return nil
                }</span>
        }
        <span class="cov0" title="0">ai.session.UpdateToken(
                base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s", ai.username, ai.token))),
                "Basic",
        )
        response, err := ai.session.Post(
                context.Background(),
                fmt.Sprintf("Oauth2/Token/%s", ai.appName),
                map[string]interface{}{
                        "grant_type": "client_credentials",
                        "scope":      "api",
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)

        <span class="cov0" title="0">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed logging in to identity service user")
        }</span>

        <span class="cov0" title="0">var authResult map[string]interface{}
        if err := json.NewDecoder(response.Body).Decode(&amp;authResult); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">accessToken, ok := authResult["access_token"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed logging in to identity service user, access token not found")
        }</span>
        <span class="cov0" title="0">ai.session.UpdateToken(accessToken, "Bearer")
        response, err = ai.session.Get(
                context.Background(),
                fmt.Sprintf("OAuth2/Authorize/%s", ai.appName),
                map[string]string{
                        "client_id":     ai.appName,
                        "response_type": "id_token",
                        "scope":         "openid profile api",
                        "redirect_uri":  "https://cyberark.cloud/redirect",
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                err := Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        ai.logger.Warning("Error closing response body")
                }</span>
        }(response.Body)

        <span class="cov0" title="0">if response.StatusCode != http.StatusFound || response.Header.Get("Location") == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to authorize to application")
        }</span>

        <span class="cov0" title="0">locationHeader := response.Header.Get("Location")
        locationHeaderSplitted := strings.Split(locationHeader, "#")
        if len(locationHeaderSplitted) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse location header to retrieve token from")
        }</span>

        <span class="cov0" title="0">parsedQuery, err := url.ParseQuery(locationHeaderSplitted[1])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">idTokens, ok := parsedQuery["id_token"]
        if !ok || len(idTokens) != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse id token from location header")
        }</span>

        <span class="cov0" title="0">ai.sessionToken = idTokens[0]
        ai.session.UpdateToken(ai.sessionToken, "Bearer")
        ai.sessionExp = commonmodels.ArkRFC3339Time(time.Now().Add(4 * time.Hour))
        ai.logger.Info("Created a service user session via endpoint [%s] with user [%s] to platform", ai.identityURL, ai.username)

        if ai.cacheAuthentication </span><span class="cov0" title="0">{
                if err := ai.saveCache(profile); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Session returns the current identity session
func (ai *ArkIdentityServiceUser) Session() *common.ArkClient <span class="cov0" title="0">{
        return ai.session
}</span>

// SessionToken returns the current identity session token if logged in
func (ai *ArkIdentityServiceUser) SessionToken() string <span class="cov0" title="0">{
        return ai.sessionToken
}</span>

// IdentityURL returns the current identity URL
func (ai *ArkIdentityServiceUser) IdentityURL() string <span class="cov0" title="0">{
        return ai.session.BaseURL
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package cli

import (
        api "github.com/cyberark/ark-sdk-golang/pkg"
        "github.com/cyberark/ark-sdk-golang/pkg/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
)

// ArkCLIAPI is a struct that represents the Ark CLI API client.
type ArkCLIAPI struct {
        api.ArkAPI
}

// NewArkCLIAPI creates a new instance of ArkCLIAPI.
func NewArkCLIAPI(authenticators []auth.ArkAuth, profile *models.ArkProfile) (*ArkCLIAPI, error) <span class="cov0" title="0">{
        arkAPI, err := api.NewArkAPI(authenticators, profile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ArkCLIAPI{
                ArkAPI: *arkAPI,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package args provides command-line argument handling utilities for the ARK SDK.
//
// This package contains functions for formatting colored output, retrieving command-line
// arguments with interactive prompts, and handling various input types including strings,
// booleans, switches, and checkbox selections.
package args

import (
        "fmt"
        "os"

        "github.com/Iilun/survey/v2"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/fatih/color"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
)

// ColorText colors the given text using the specified color.
//
// This function applies color formatting to text when coloring is enabled in the
// common package configuration. If coloring is disabled, it returns the original
// text unchanged.
//
// Parameters:
//   - text: The text string to be colored
//   - color: The color configuration to apply to the text
//
// Returns the colored text string, or the original text if coloring is disabled.
//
// Example:
//
//        red := color.New(color.FgRed)
//        coloredText := ColorText("Error message", red)
func ColorText(text string, color *color.Color) string <span class="cov0" title="0">{
        if !common.IsColoring() </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">return color.Sprintf("%s", text)</span>
}

// PrintColored prints the given text in the specified color to stdout.
//
// This function outputs colored text to stdout when interactive mode is enabled
// or output is allowed. The text will be colored only if coloring is enabled,
// otherwise it prints plain text.
//
// Parameters:
//   - text: The text content to print (can be any type that can be formatted)
//   - color: The color configuration to apply when printing
//
// The function respects the interactive and output settings from the common package
// and will not print anything if both interactive mode and output allowance are disabled.
//
// Example:
//
//        red := color.New(color.FgRed)
//        PrintColored("Error occurred", red)
func PrintColored(text any, color *color.Color) <span class="cov0" title="0">{
        if common.IsInteractive() || common.IsAllowingOutput() </span><span class="cov0" title="0">{
                if common.IsColoring() </span><span class="cov0" title="0">{
                        _, _ = color.Fprintf(os.Stdout, "%s\n", text)
                }</span> else<span class="cov0" title="0"> {
                        _, _ = fmt.Fprintf(os.Stdout, "%s\n", text)
                }</span>
        }
}

// PrintSuccess prints the given text in green color to stdout.
//
// This is a convenience function that prints text using green color formatting
// to indicate successful operations or positive messages.
//
// Parameters:
//   - text: The success message to print (can be any type that can be formatted)
//
// Example:
//
//        PrintSuccess("Operation completed successfully")
func PrintSuccess(text any) <span class="cov0" title="0">{
        PrintColored(text, color.New(color.FgGreen))
}</span>

// PrintSuccessBright prints the given text in bright green color to stdout.
//
// This is a convenience function that prints text using bold bright green color
// formatting to emphasize important successful operations or highlight positive outcomes.
//
// Parameters:
//   - text: The success message to print with emphasis (can be any type that can be formatted)
//
// Example:
//
//        PrintSuccessBright("DEPLOYMENT SUCCESSFUL")
func PrintSuccessBright(text any) <span class="cov0" title="0">{
        PrintColored(text, color.New(color.FgGreen, color.Bold))
}</span>

// PrintFailure prints the given text in red color to stdout.
//
// This is a convenience function that prints text using red color formatting
// to indicate errors, failures, or critical issues.
//
// Parameters:
//   - text: The failure or error message to print (can be any type that can be formatted)
//
// Example:
//
//        PrintFailure("Authentication failed")
func PrintFailure(text any) <span class="cov0" title="0">{
        PrintColored(text, color.New(color.FgRed))
}</span>

// PrintWarning prints the given text in yellow color to stdout.
//
// This is a convenience function that prints text using yellow color formatting
// to indicate warnings, cautions, or non-critical issues that require attention.
//
// Parameters:
//   - text: The warning message to print (can be any type that can be formatted)
//
// Example:
//
//        PrintWarning("Configuration file not found, using defaults")
func PrintWarning(text any) <span class="cov0" title="0">{
        PrintColored(text, color.New(color.FgYellow))
}</span>

// PrintNormal prints the given text in default color to stdout.
//
// This is a convenience function that prints text using the default terminal color.
// It's useful for maintaining consistency with other Print functions while using
// standard formatting.
//
// Parameters:
//   - text: The message to print in normal formatting (can be any type that can be formatted)
//
// Example:
//
//        PrintNormal("Processing complete")
func PrintNormal(text any) <span class="cov0" title="0">{
        PrintColored(text, color.New())
}</span>

// PrintNormalBright prints the given text in bright color to stdout.
//
// This is a convenience function that prints text using bold formatting with
// the default terminal color to emphasize normal messages.
//
// Parameters:
//   - text: The message to print with bold emphasis (can be any type that can be formatted)
//
// Example:
//
//        PrintNormalBright("IMPORTANT: Review the following changes")
func PrintNormalBright(text any) <span class="cov0" title="0">{
        PrintColored(text, color.New(color.Bold))
}</span>

// GetArg retrieves the value of a command-line argument from the command flags or prompts the user for input if not provided.
//
// This function first checks if the argument is provided via command-line flags. If not found
// or if prioritizeExistingVal is true and existingVal is not empty, it uses the existing value.
// When no value is available, it prompts the user interactively for input. The function supports
// both regular text input and hidden password input.
//
// Parameters:
//   - cmd: The cobra command containing the flags to check
//   - key: The name of the flag/argument to retrieve
//   - prompt: The message to display when prompting the user for input
//   - existingVal: An existing value that may be used as default or priority
//   - hidden: Whether the input should be hidden (password-style input)
//   - prioritizeExistingVal: Whether to use existingVal over command-line flags
//   - emptyValueAllowed: Whether empty values are acceptable as valid input
//
// Returns the retrieved or inputted value and any error that occurred during the process.
// If emptyValueAllowed is false and the final value is empty, returns an error.
//
// Example:
//
//        password, err := GetArg(
//            cmd,
//            "password",
//            "Enter your password:",
//            "",
//            true,  // hidden input
//            false, // don't prioritize existing
//            false, // empty not allowed
//        )
func GetArg(cmd *cobra.Command, key string, prompt string, existingVal string, hidden bool, prioritizeExistingVal bool, emptyValueAllowed bool) (string, error) <span class="cov0" title="0">{
        val := ""
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov0" title="0">{
                if f.Name == key </span><span class="cov0" title="0">{
                        val = f.Value.String()
                }</span>
        })
        <span class="cov0" title="0">if prioritizeExistingVal &amp;&amp; existingVal != "" </span><span class="cov0" title="0">{
                val = existingVal
        }</span>
        <span class="cov0" title="0">var answer string
        if hidden </span><span class="cov0" title="0">{
                prompt := &amp;survey.Password{
                        Message: prompt,
                }
                err := survey.AskOne(prompt, &amp;answer)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        } else<span class="cov0" title="0"> {
                prompt := &amp;survey.Input{
                        Message: prompt,
                        Default: val,
                }
                err := survey.AskOne(prompt, &amp;answer)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">if answer != "" </span><span class="cov0" title="0">{
                val = answer
        }</span>
        <span class="cov0" title="0">if val == "" &amp;&amp; !emptyValueAllowed </span><span class="cov0" title="0">{
                PrintFailure("Value cannot be empty")
                return "", fmt.Errorf("value cannot be empty")
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// GetBoolArg retrieves a boolean argument from the command flags or prompts the user for input if not provided.
//
// This function first attempts to retrieve a boolean flag from the command. If prioritizeExistingVal
// is true and existingVal is not nil, it uses the existing value. When no value is determined,
// it prompts the user with a Yes/No selection interface.
//
// Parameters:
//   - cmd: The cobra command containing the boolean flags to check
//   - key: The name of the boolean flag to retrieve
//   - prompt: The message to display when prompting the user for Yes/No selection
//   - existingVal: An existing boolean value that may be used as default or priority
//   - prioritizeExistingVal: Whether to use existingVal over command-line flags
//
// Returns the boolean value (true for "Yes", false for "No") and any error that occurred
// during flag retrieval or user interaction.
//
// Example:
//
//        confirmed, err := GetBoolArg(
//            cmd,
//            "confirm",
//            "Do you want to proceed?",
//            nil,
//            false,
//        )
func GetBoolArg(cmd *cobra.Command, key, prompt string, existingVal *bool, prioritizeExistingVal bool) (bool, error) <span class="cov0" title="0">{
        val := false
        if newVal, err := cmd.Flags().GetBool(key); err == nil </span><span class="cov0" title="0">{
                val = newVal
        }</span>
        <span class="cov0" title="0">if prioritizeExistingVal &amp;&amp; existingVal != nil </span><span class="cov0" title="0">{
                val = *existingVal
        }</span>
        <span class="cov0" title="0">options := []string{"Yes", "No"}
        defaultOption := "No"
        if val </span><span class="cov0" title="0">{
                defaultOption = "Yes"
        }</span>

        <span class="cov0" title="0">var answer string
        promptSelect := &amp;survey.Select{
                Message: prompt,
                Options: options,
                Default: defaultOption,
        }

        err := survey.AskOne(promptSelect, &amp;answer)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">val = (answer == "Yes")
        return val, nil</span>
}

// GetSwitchArg retrieves a switch argument from the command flags or prompts the user for input if not provided.
//
// This function first checks if the switch argument is provided via command-line flags. If
// prioritizeExistingVal is true and existingVal is not empty, it uses the existing value.
// When no value is available, it prompts the user with a selection interface containing
// the provided possible values.
//
// Parameters:
//   - cmd: The cobra command containing the flags to check
//   - key: The name of the flag/argument to retrieve
//   - prompt: The message to display when prompting the user for selection
//   - possibleVals: A slice of valid options that the user can choose from
//   - existingVal: An existing value that may be used as default or priority
//   - prioritizeExistingVal: Whether to use existingVal over command-line flags
//
// Returns the selected value from the possible options and any error that occurred
// during flag retrieval or user interaction.
//
// Example:
//
//        environment, err := GetSwitchArg(
//            cmd,
//            "env",
//            "Select environment:",
//            []string{"development", "staging", "production"},
//            "development",
//            false,
//        )
func GetSwitchArg(cmd *cobra.Command, key, prompt string, possibleVals []string, existingVal string, prioritizeExistingVal bool) (string, error) <span class="cov0" title="0">{
        val := ""
        cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov0" title="0">{
                if f.Name == key </span><span class="cov0" title="0">{
                        val = f.Value.String()
                }</span>
        })
        <span class="cov0" title="0">if prioritizeExistingVal &amp;&amp; existingVal != "" </span><span class="cov0" title="0">{
                val = existingVal
        }</span>
        <span class="cov0" title="0">var answer string
        promptSelect := &amp;survey.Select{
                Message: prompt,
                Options: possibleVals,
                Default: val,
        }

        err := survey.AskOne(promptSelect, &amp;answer)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return answer, nil</span>
}

// GetCheckboxArgs retrieves checkbox arguments from the command flags or prompts the user for input if not provided.
//
// This function collects values from multiple command-line flags specified in the keys slice.
// If prioritizeExistingVal is true, it also includes values from the existingVals map.
// When additional selection is needed, it prompts the user with a multi-select interface
// containing the provided possible values.
//
// Parameters:
//   - cmd: The cobra command containing the flags to check
//   - keys: A slice of flag names to collect values from
//   - prompt: The message to display when prompting the user for multi-selection
//   - possibleVals: A slice of valid options that the user can choose from
//   - existingVals: A map of existing key-value pairs that may be used as defaults
//   - prioritizeExistingVal: Whether to include values from existingVals map
//
// Returns a slice of selected values and any error that occurred during flag retrieval
// or user interaction.
//
// Example:
//
//        features, err := GetCheckboxArgs(
//            cmd,
//            []string{"feature1", "feature2"},
//            "Select features to enable:",
//            []string{"auth", "logging", "metrics", "tracing"},
//            map[string]string{"feature1": "auth"},
//            true,
//        )
func GetCheckboxArgs(cmd *cobra.Command, keys []string, prompt string, possibleVals []string, existingVals map[string]string, prioritizeExistingVal bool) ([]string, error) <span class="cov0" title="0">{
        vals := []string{}
        for _, key := range keys </span><span class="cov0" title="0">{
                cmd.Flags().VisitAll(func(f *pflag.Flag) </span><span class="cov0" title="0">{
                        if f.Name == key </span><span class="cov0" title="0">{
                                vals = append(vals, f.Value.String())
                        }</span>
                })
                <span class="cov0" title="0">if prioritizeExistingVal </span><span class="cov0" title="0">{
                        if v, ok := existingVals[key]; ok </span><span class="cov0" title="0">{
                                vals = append(vals, v)
                        }</span>
                }
        }

        <span class="cov0" title="0">selectedVals := []string{}
        promptMultiSelect := &amp;survey.MultiSelect{
                Message: prompt,
                Options: possibleVals,
                Default: vals,
        }

        err := survey.AskOne(promptMultiSelect, &amp;selectedVals)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return selectedVals, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package common provides shared utilities and types for the ARK SDK.
//
// This package implements a comprehensive HTTP client with features like:
// - Authentication support (token-based, basic auth)
// - Cookie management with persistent storage
// - Automatic token refresh capabilities
// - Request/response logging
// - TLS configuration options
//
// The ArkClient is the primary interface for making HTTP requests to Ark services,
// providing a consistent and feature-rich HTTP client implementation.
package common

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        cookiejar "github.com/juju/persistent-cookiejar"
)

// Number of retry attempts for token refresh operations.
const (
        refreshRetryCount = 3
)

// cookieJSON represents the JSON serializable format of an HTTP cookie.
//
// This structure is used for marshaling and unmarshaling HTTP cookies
// to and from JSON format, enabling persistent cookie storage and
// session management across client instances.
type cookieJSON struct {
        Name        string        `json:"name"`
        Value       string        `json:"value"`
        Quoted      bool          `json:"quoted"`
        Path        string        `json:"path,omitempty"`
        Domain      string        `json:"domain,omitempty"`
        Expires     time.Time     `json:"expires,omitempty"`
        RawExpires  string        `json:"raw_expires,omitempty"`
        MaxAge      int           `json:"max_age,omitempty"`
        Secure      bool          `json:"secure,omitempty"`
        HTTPOnly    bool          `json:"http_only,omitempty"`
        SameSite    http.SameSite `json:"same_site,omitempty"`
        Partitioned bool          `json:"partitioned,omitempty"`
        Raw         string        `json:"raw,omitempty"`
        Unparsed    []string      `json:"unparsed,omitempty"`
}

// ArkClient provides a comprehensive HTTP client for interacting with Ark services.
//
// ArkClient wraps the standard Go HTTP client with additional features specifically
// designed for Ark service interactions. It handles authentication, cookie management,
// request logging, and automatic token refresh capabilities.
//
// Key features:
// - Token-based and basic authentication support
// - Persistent cookie storage with JSON serialization
// - Automatic retry with token refresh on 401 responses
// - Configurable headers for all requests
// - Request/response logging with timing information
// - TLS configuration support
//
// The client maintains state including authentication tokens, custom headers,
// and cookie storage, making it suitable for session-based interactions
// with Ark services.
type ArkClient struct {
        BaseURL                   string
        token                     string
        tokenType                 string
        authHeaderName            string
        client                    *http.Client
        headers                   map[string]string
        cookieJar                 *cookiejar.Jar
        refreshConnectionCallback func(*ArkClient) error
        logger                    *ArkLogger
}

// MarshalCookies serializes a cookie jar into a JSON byte array.
//
// This function converts all cookies from a cookiejar.Jar into a JSON-serializable
// format, enabling persistent storage of cookie state. The resulting byte array
// can be stored to disk or transmitted over networks for session persistence.
//
// Note: This implementation uses the AllCookies() method from persistent-cookiejar
// which provides direct access to all stored cookies.
//
// Parameters:
//   - cookieJar: The cookie jar containing cookies to be marshaled
//
// Returns the JSON byte array representation of all cookies, or an error
// if JSON marshaling fails.
//
// Example:
//
//        cookieData, err := MarshalCookies(client.GetCookieJar())
//        if err != nil {
//            // handle error
//        }
//        // Save cookieData to file or database
func MarshalCookies(cookieJar *cookiejar.Jar) ([]byte, error) <span class="cov0" title="0">{
        jsonCookies := make([]cookieJSON, len(cookieJar.AllCookies()))
        for i, c := range cookieJar.AllCookies() </span><span class="cov0" title="0">{
                jsonCookies[i] = cookieJSON{
                        Name:        c.Name,
                        Value:       c.Value,
                        Quoted:      c.Quoted,
                        Path:        c.Path,
                        Domain:      c.Domain,
                        Expires:     c.Expires,
                        RawExpires:  c.RawExpires,
                        MaxAge:      c.MaxAge,
                        Secure:      c.Secure,
                        HTTPOnly:    c.HttpOnly,
                        SameSite:    c.SameSite,
                        Partitioned: c.Partitioned,
                        Raw:         c.Raw,
                        Unparsed:    c.Unparsed,
                }
        }</span>
        <span class="cov0" title="0">cookiesBytes, err := json.Marshal(jsonCookies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cookiesBytes, nil</span>
}

// UnmarshalCookies deserializes a JSON byte array into a cookie jar.
//
// This function takes a JSON byte array (typically created by MarshalCookies)
// and populates the provided cookie jar with the deserialized cookies.
// The cookies are organized by URL and properly set in the jar for use
// in subsequent HTTP requests.
//
// Parameters:
//   - cookies: JSON byte array containing serialized cookie data
//   - cookieJar: The cookie jar to populate with deserialized cookies
//
// Returns an error if JSON unmarshaling fails or if URL parsing encounters
// invalid cookie data.
//
// Example:
//
//        err := UnmarshalCookies(savedCookieData, client.GetCookieJar())
//        if err != nil {
//            // handle error
//        }
//        // Cookie jar now contains restored cookies
func UnmarshalCookies(cookies []byte, cookieJar *cookiejar.Jar) error <span class="cov0" title="0">{
        var jsonCookies []cookieJSON
        if err := json.Unmarshal(cookies, &amp;jsonCookies); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">allCookies := make([]*http.Cookie, len(jsonCookies))
        for i, c := range jsonCookies </span><span class="cov0" title="0">{
                allCookies[i] = &amp;http.Cookie{
                        Name:        c.Name,
                        Value:       c.Value,
                        Quoted:      c.Quoted,
                        Path:        c.Path,
                        Domain:      c.Domain,
                        Expires:     c.Expires,
                        RawExpires:  c.RawExpires,
                        MaxAge:      c.MaxAge,
                        Secure:      c.Secure,
                        HttpOnly:    c.HTTPOnly,
                        SameSite:    c.SameSite,
                        Partitioned: c.Partitioned,
                        Raw:         c.Raw,
                        Unparsed:    c.Unparsed,
                }
        }</span>
        <span class="cov0" title="0">cookieGroups := make(map[string][]*http.Cookie)
        for _, cookie := range allCookies </span><span class="cov0" title="0">{
                urlKey := fmt.Sprintf("https://%s%s", cookie.Domain, cookie.Path)
                cookieGroups[urlKey] = append(cookieGroups[urlKey], cookie)
        }</span>
        <span class="cov0" title="0">for urlKey, cookiesGroup := range cookieGroups </span><span class="cov0" title="0">{
                parsedURL, err := url.Parse(urlKey)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse URL %s: %w", urlKey, err)
                }</span>
                <span class="cov0" title="0">cookieJar.SetCookies(parsedURL, cookiesGroup)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// NewSimpleArkClient creates a basic ArkClient instance with minimal configuration.
//
// This is a convenience constructor for creating an ArkClient with only a base URL.
// It uses default values for all other parameters (no authentication, new cookie jar,
// no refresh callback). This is suitable for simple use cases or as a starting point
// for further configuration.
//
// Parameters:
//   - baseURL: The base URL for the Ark service (HTTPS prefix will be added if missing)
//
// Returns a configured ArkClient instance ready for basic HTTP operations.
//
// Example:
//
//        client := NewSimpleArkClient("api.example.com")
//        response, err := client.Get(ctx, "/users", nil)
func NewSimpleArkClient(baseURL string) *ArkClient <span class="cov0" title="0">{
        return NewArkClient(baseURL, "", "", "", nil, nil)
}</span>

// NewArkClient creates a new ArkClient instance with comprehensive configuration options.
//
// This is the primary constructor for ArkClient, allowing full customization of
// authentication, cookie management, and refresh behavior. The client will automatically
// add HTTPS prefix to the base URL if not present and initialize a new cookie jar
// if none is provided.
//
// Parameters:
//   - baseURL: The base URL for the Ark service
//   - token: Authentication token (empty string for no authentication)
//   - tokenType: Type of token ("Bearer", "Basic", etc.)
//   - authHeaderName: Name of the authorization header (e.g., "Authorization")
//   - cookieJar: Cookie jar for session management (nil for new jar)
//   - refreshCallback: Function to call for token refresh on 401 responses (nil to disable)
//
// Returns a fully configured ArkClient instance.
//
// Example:
//
//        jar, _ := cookiejar.New(nil)
//        client := NewArkClient(
//            "https://api.example.com",
//            "abc123",
//            "Bearer",
//            "Authorization",
//            jar,
//            func(c *ArkClient) error {
//                // Token refresh logic
//                return nil
//            },
//        )
func NewArkClient(baseURL string, token string, tokenType string, authHeaderName string, cookieJar *cookiejar.Jar, refreshCallback func(*ArkClient) error) *ArkClient <span class="cov0" title="0">{
        if baseURL != "" &amp;&amp; !strings.HasPrefix(baseURL, "https://") </span><span class="cov0" title="0">{
                baseURL = "https://" + baseURL
        }</span>
        <span class="cov0" title="0">if cookieJar == nil </span><span class="cov0" title="0">{
                cookieJar, _ = cookiejar.New(nil)
        }</span>
        <span class="cov0" title="0">client := &amp;ArkClient{
                BaseURL:        baseURL,
                authHeaderName: authHeaderName,
                cookieJar:      cookieJar,
                client: &amp;http.Client{
                        Jar: cookieJar,
                },
                headers:                   make(map[string]string),
                refreshConnectionCallback: refreshCallback,
                logger:                    GetLogger("ArkClient", Unknown),
        }
        client.UpdateToken(token, tokenType)
        client.headers["User-Agent"] = UserAgent()
        return client</span>
}

// SetHeader sets a single HTTP header for the ArkClient.
//
// This method adds or updates a single header in the client's header map.
// The header will be included in all subsequent HTTP requests made by this client.
// If a header with the same key already exists, it will be overwritten.
//
// Parameters:
//   - key: The header name (e.g., "Content-Type", "Accept")
//   - value: The header value (e.g., "application/json", "text/plain")
//
// Example:
//
//        client.SetHeader("Content-Type", "application/json")
//        client.SetHeader("Accept", "application/json")
func (ac *ArkClient) SetHeader(key string, value string) <span class="cov0" title="0">{
        ac.headers[key] = value
}</span>

// SetHeaders replaces all existing headers with the provided header map.
//
// This method completely replaces the client's header map with the new headers.
// Any previously set headers will be lost. Use UpdateHeaders() if you want to
// preserve existing headers while adding new ones.
//
// Parameters:
//   - headers: Map of header names to values that will replace all existing headers
//
// Example:
//
//        headers := map[string]string{
//            "Content-Type": "application/json",
//            "Accept": "application/json",
//        }
//        client.SetHeaders(headers)
func (ac *ArkClient) SetHeaders(headers map[string]string) <span class="cov0" title="0">{
        ac.headers = headers
}</span>

// UpdateHeaders merges the provided headers into the existing header map.
//
// This method adds new headers or updates existing ones while preserving
// headers that are not specified in the input map. If a header key already
// exists, its value will be overwritten.
//
// Parameters:
//   - headers: Map of header names to values to add or update
//
// Example:
//
//        newHeaders := map[string]string{
//            "X-Custom-Header": "custom-value",
//            "Authorization": "Bearer new-token",
//        }
//        client.UpdateHeaders(newHeaders)
func (ac *ArkClient) UpdateHeaders(headers map[string]string) <span class="cov0" title="0">{
        for key, value := range headers </span><span class="cov0" title="0">{
                ac.headers[key] = value
        }</span>
}

// GetHeaders returns a copy of the current header map.
//
// This method returns the client's current headers. Note that modifying
// the returned map will not affect the client's headers - use SetHeader()
// or UpdateHeaders() to modify headers.
//
// Returns a map containing all current headers.
//
// Example:
//
//        currentHeaders := client.GetHeaders()
//        fmt.Printf("Content-Type: %s\n", currentHeaders["Content-Type"])
func (ac *ArkClient) GetHeaders() map[string]string <span class="cov0" title="0">{
        return ac.headers
}</span>

// SetCookie sets a single cookie in the client's cookie jar.
//
// This method adds a new cookie to the client's cookie jar, which will be
// included in subsequent requests to the appropriate domain. The cookie
// is associated with the client's base URL.
//
// Parameters:
//   - key: The cookie name
//   - value: The cookie value
//
// Example:
//
//        client.SetCookie("session_id", "abc123")
//        client.SetCookie("user_pref", "dark_mode")
func (ac *ArkClient) SetCookie(key string, value string) <span class="cov0" title="0">{
        parsedURL, err := url.Parse(ac.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                ac.logger.Error("Fail to parse url %s: %v", ac.BaseURL, err)
                parsedURL = &amp;url.URL{
                        Scheme: "https",
                        Host:   ac.BaseURL,
                }
        }</span>
        <span class="cov0" title="0">ac.cookieJar.SetCookies(
                parsedURL,
                []*http.Cookie{
                        {
                                Name:  key,
                                Value: value,
                        },
                },
        )</span>
}

// SetCookies replaces all existing cookies with the provided cookie map.
//
// This method removes all existing cookies from the cookie jar and replaces
// them with the new cookies. Use UpdateCookies() if you want to preserve
// existing cookies while adding new ones.
//
// Parameters:
//   - cookies: Map of cookie names to values that will replace all existing cookies
//
// Example:
//
//        cookies := map[string]string{
//            "session_id": "abc123",
//            "csrf_token": "xyz789",
//        }
//        client.SetCookies(cookies)
func (ac *ArkClient) SetCookies(cookies map[string]string) <span class="cov0" title="0">{
        ac.cookieJar.RemoveAll()
        for key, value := range cookies </span><span class="cov0" title="0">{
                ac.SetCookie(key, value)
        }</span>
}

// UpdateCookies adds or updates cookies in the existing cookie jar.
//
// This method adds new cookies or updates existing ones while preserving
// cookies that are not specified in the input map.
//
// Parameters:
//   - cookies: Map of cookie names to values to add or update
//
// Example:
//
//        newCookies := map[string]string{
//            "new_session": "def456",
//            "updated_pref": "light_mode",
//        }
//        client.UpdateCookies(newCookies)
func (ac *ArkClient) UpdateCookies(cookies map[string]string) <span class="cov0" title="0">{
        for key, value := range cookies </span><span class="cov0" title="0">{
                ac.SetCookie(key, value)
        }</span>
}

// GetCookies returns a map of all current cookies.
//
// This method extracts all cookies from the cookie jar and returns them
// as a simple map of names to values. This is useful for inspecting
// current cookie state or for serialization purposes.
//
// Note: This implementation uses the AllCookies() method from persistent-cookiejar
// which provides direct access to all stored cookies.
//
// Returns a map containing all current cookie names and values.
//
// Example:
//
//        cookies := client.GetCookies()
//        sessionID := cookies["session_id"]
func (ac *ArkClient) GetCookies() map[string]string <span class="cov0" title="0">{
        cookies := make(map[string]string)
        for _, cookie := range ac.cookieJar.AllCookies() </span><span class="cov0" title="0">{
                cookies[cookie.Name] = cookie.Value
        }</span>
        <span class="cov0" title="0">return cookies</span>
}

// GetCookieJar returns the underlying cookie jar instance.
//
// This method provides direct access to the cookiejar.Jar for advanced
// cookie management operations that are not covered by the convenience
// methods. Use this when you need full control over cookie behavior.
//
// Returns the cookie jar instance used by this client.
//
// Example:
//
//        jar := client.GetCookieJar()
//        // Perform advanced cookie operations
//        cookieData, err := MarshalCookies(jar)
func (ac *ArkClient) GetCookieJar() *cookiejar.Jar <span class="cov0" title="0">{
        return ac.cookieJar
}</span>

// doRequest is the internal method that handles the actual HTTP request execution.
//
// This method constructs and executes HTTP requests with comprehensive functionality
// including URL construction, JSON serialization, header application, query parameter
// handling, TLS configuration, request logging, and automatic token refresh on
// authentication failures.
//
// The method performs several key operations:
// - URL construction with proper path escaping
// - JSON marshaling of request body
// - Header and query parameter application
// - TLS configuration based on certificate verification settings
// - Request timing and logging
// - Automatic retry with token refresh on 401 responses
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - method: HTTP method (GET, POST, PUT, DELETE, etc.)
//   - route: API route/path to append to the base URL
//   - body: Request body to be JSON-serialized (can be nil for methods like GET)
//   - params: Query parameters to include in the request URL (can be nil)
//   - refreshRetryCount: Number of retry attempts remaining for token refresh
//
// Returns the HTTP response or an error if the request fails or retry attempts
// are exhausted.
//
// The method automatically handles:
// - HTTPS URL construction with proper path segment escaping
// - JSON serialization of request bodies
// - Application of all configured headers
// - Query parameter encoding
// - TLS certificate verification based on global settings
// - Request/response timing logging
// - Token refresh retry logic on 401 Unauthorized responses
func (ac *ArkClient) doRequest(ctx context.Context, method string, route string, body interface{}, params map[string]string, refreshRetryCount int) (*http.Response, error) <span class="cov0" title="0">{
        fullURL := ac.BaseURL
        if route != "" </span><span class="cov0" title="0">{
                segments := strings.Split(route, "/")
                for i, segment := range segments </span><span class="cov0" title="0">{
                        segments[i] = url.PathEscape(segment)
                }</span>
                <span class="cov0" title="0">route = strings.Join(segments, "/")
                if fullURL[len(fullURL)-1] != '/' &amp;&amp; route[0] != '/' </span><span class="cov0" title="0">{
                        fullURL += "/"
                }</span>
                <span class="cov0" title="0">fullURL += route</span>
        }
        <span class="cov0" title="0">bodyBytes, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, fullURL, bytes.NewBuffer(bodyBytes))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for key, value := range ac.headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>
        <span class="cov0" title="0">if params != nil </span><span class="cov0" title="0">{
                urlParams := url.Values{}
                for key, value := range params </span><span class="cov0" title="0">{
                        urlParams.Add(key, value)
                }</span>
                <span class="cov0" title="0">req.URL.RawQuery = urlParams.Encode()</span>
        }
        <span class="cov0" title="0">if !IsVerifyingCertificates() </span><span class="cov0" title="0">{
                ac.client.Transport = &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
                }
        }</span> else<span class="cov0" title="0"> {
                ac.client.Transport = &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: false},
                }
        }</span>
        <span class="cov0" title="0">ac.logger.Info("Running request to %s", fullURL)
        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(startTime)
                ac.logger.Info("Request to %s took %dms", fullURL, duration.Milliseconds())
        }</span>()
        <span class="cov0" title="0">resp, err := ac.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized &amp;&amp; ac.refreshConnectionCallback != nil &amp;&amp; refreshRetryCount &gt; 0 </span><span class="cov0" title="0">{
                err = ac.refreshConnectionCallback(ac)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return ac.doRequest(ctx, method, route, body, params, refreshRetryCount-1)</span>
        }
        <span class="cov0" title="0">return resp, nil</span>
}

// Get performs an HTTP GET request to the specified route.
//
// This method constructs and executes a GET request using the client's base URL,
// headers, and authentication. Query parameters can be provided via the params map.
// The method handles automatic token refresh on 401 responses if a refresh callback
// is configured.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - route: API route/path to append to the base URL
//   - params: Query parameters to include in the request (nil for no parameters)
//
// Returns the HTTP response or an error if the request fails.
//
// Example:
//
//        params := map[string]string{"limit": "10", "offset": "0"}
//        response, err := client.Get(ctx, "/users", params)
//        if err != nil {
//            // handle error
//        }
//        defer response.Body.Close()
func (ac *ArkClient) Get(ctx context.Context, route string, params map[string]string) (*http.Response, error) <span class="cov0" title="0">{
        return ac.doRequest(ctx, http.MethodGet, route, map[string]string{}, params, refreshRetryCount)
}</span>

// Post performs an HTTP POST request to the specified route.
//
// This method constructs and executes a POST request with the provided body
// serialized as JSON. The request includes all configured headers and
// authentication. Automatic token refresh is handled on 401 responses.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - route: API route/path to append to the base URL
//   - body: Request body data to be JSON-serialized
//
// Returns the HTTP response or an error if the request fails.
//
// Example:
//
//        userData := map[string]string{"name": "John", "email": "john@example.com"}
//        response, err := client.Post(ctx, "/users", userData)
//        if err != nil {
//            // handle error
//        }
//        defer response.Body.Close()
func (ac *ArkClient) Post(ctx context.Context, route string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        return ac.doRequest(ctx, http.MethodPost, route, body, nil, refreshRetryCount)
}</span>

// Put performs an HTTP PUT request to the specified route.
//
// This method constructs and executes a PUT request with the provided body
// serialized as JSON. PUT requests are typically used for updating or
// replacing existing resources.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - route: API route/path to append to the base URL
//   - body: Request body data to be JSON-serialized
//
// Returns the HTTP response or an error if the request fails.
//
// Example:
//
//        updatedUser := map[string]string{"name": "John Doe", "email": "john.doe@example.com"}
//        response, err := client.Put(ctx, "/users/123", updatedUser)
func (ac *ArkClient) Put(ctx context.Context, route string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        return ac.doRequest(ctx, http.MethodPut, route, body, nil, refreshRetryCount)
}</span>

// Delete performs an HTTP DELETE request to the specified route.
//
// This method constructs and executes a DELETE request. An optional body
// can be provided for DELETE requests that require additional data.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - route: API route/path to append to the base URL
//   - body: Optional request body data to be JSON-serialized (can be nil)
//
// Returns the HTTP response or an error if the request fails.
//
// Example:
//
//        response, err := client.Delete(ctx, "/users/123", nil)
//        // Or with body:
//        deleteOptions := map[string]bool{"force": true}
//        response, err := client.Delete(ctx, "/users/123", deleteOptions)
func (ac *ArkClient) Delete(ctx context.Context, route string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        return ac.doRequest(ctx, http.MethodDelete, route, body, nil, refreshRetryCount)
}</span>

// Patch performs an HTTP PATCH request to the specified route.
//
// This method constructs and executes a PATCH request with the provided body
// serialized as JSON. PATCH requests are typically used for partial updates
// of existing resources.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - route: API route/path to append to the base URL
//   - body: Request body data to be JSON-serialized
//
// Returns the HTTP response or an error if the request fails.
//
// Example:
//
//        partialUpdate := map[string]string{"email": "newemail@example.com"}
//        response, err := client.Patch(ctx, "/users/123", partialUpdate)
func (ac *ArkClient) Patch(ctx context.Context, route string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        return ac.doRequest(ctx, http.MethodPatch, route, body, nil, refreshRetryCount)
}</span>

// Options performs an HTTP OPTIONS request to the specified route.
//
// This method constructs and executes an OPTIONS request, typically used
// to retrieve information about the communication options available for
// the target resource or server.
//
// Parameters:
//   - ctx: Context for request cancellation and timeout control
//   - route: API route/path to append to the base URL
//
// Returns the HTTP response or an error if the request fails.
//
// Example:
//
//        response, err := client.Options(ctx, "/users")
//        // Check response headers for allowed methods, CORS info, etc.
func (ac *ArkClient) Options(ctx context.Context, route string) (*http.Response, error) <span class="cov0" title="0">{
        return ac.doRequest(ctx, http.MethodOptions, route, nil, nil, refreshRetryCount)
}</span>

// UpdateToken updates the authentication token and token type for the client.
//
// This method updates the client's authentication credentials and automatically
// configures the appropriate authorization header. It supports both standard
// token-based authentication and basic authentication. For basic auth, the token
// should be a base64-encoded "username:password" string.
//
// Parameters:
//   - token: The authentication token or base64-encoded credentials
//   - tokenType: The type of token ("Bearer", "Basic", "API-Key", etc.)
//
// The method will automatically set the Authorization header based on the token type:
// - For "Basic" type: Decodes the token and sets "Authorization: Basic &lt;credentials&gt;"
// - For other types: Sets the configured auth header with format "&lt;tokenType&gt; &lt;token&gt;"
//
// Example:
//
//        // Bearer token
//        client.UpdateToken("abc123xyz", "Bearer")
//
//        // Basic auth (token should be base64 encoded "user:pass")
//        client.UpdateToken("dXNlcjpwYXNz", "Basic")
//
//        // API key
//        client.UpdateToken("api-key-value", "API-Key")
func (ac *ArkClient) UpdateToken(token string, tokenType string) <span class="cov0" title="0">{
        ac.token = token
        ac.tokenType = tokenType
        if token != "" </span><span class="cov0" title="0">{
                if tokenType == "Basic" </span><span class="cov0" title="0">{
                        decoded, err := base64.StdEncoding.DecodeString(token)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">userPass := string(decoded)
                        ac.headers["Authorization"] = "Basic " + userPass</span>
                } else<span class="cov0" title="0"> {
                        ac.headers[ac.authHeaderName] = fmt.Sprintf("%s %s", tokenType, token)
                }</span>
        }
}

// GetToken returns the current authentication token.
//
// This method returns the raw token string that was set via UpdateToken().
// For basic authentication, this will be the base64-encoded credentials.
//
// Returns the current authentication token string.
//
// Example:
//
//        currentToken := client.GetToken()
//        if currentToken == "" {
//            // No authentication token is set
//        }
func (ac *ArkClient) GetToken() string <span class="cov0" title="0">{
        return ac.token
}</span>

// GetTokenType returns the current token type.
//
// This method returns the token type that was set via UpdateToken(),
// such as "Bearer", "Basic", "API-Key", etc.
//
// Returns the current token type string.
//
// Example:
//
//        tokenType := client.GetTokenType()
//        fmt.Printf("Using %s authentication\n", tokenType)
func (ac *ArkClient) GetTokenType() string <span class="cov0" title="0">{
        return ac.tokenType
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package common

import (
        "errors"
        "net"
        "os"
        "syscall"
)

// IsConnectionRefused checks if the error is a connection refused error.
//
// This function examines an error to determine if it represents a connection
// refused condition. It handles nested error types including net.OpError and
// os.SyscallError to properly detect ECONNREFUSED errors at any level.
//
// Parameters:
//   - err: The error to examine (can be nil)
//
// Returns true if the error represents a connection refused condition, false otherwise.
//
// Example:
//
//        conn, err := net.Dial("tcp", "localhost:8080")
//        if err != nil &amp;&amp; IsConnectionRefused(err) {
//            log.Println("Service is not running")
//        }
func IsConnectionRefused(err error) bool <span class="cov10" title="14">{
        var opErr *net.OpError
        if errors.As(err, &amp;opErr) </span><span class="cov7" title="7">{
                var syscallErr *os.SyscallError
                if errors.As(opErr.Err, &amp;syscallErr) </span><span class="cov4" title="3">{
                        return errors.Is(syscallErr.Err, syscall.ECONNREFUSED)
                }</span>
                <span class="cov5" title="4">return errors.Is(opErr.Err, syscall.ECONNREFUSED)</span>
        }
        <span class="cov7" title="7">return errors.Is(err, syscall.ECONNREFUSED)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package common

import (
        "os"
        "os/user"
        "path/filepath"
        "strings"
)

// ExpandFolder expands the given folder path by replacing environment variables and user home directory.
//
// This function performs path expansion by handling environment variables ($VAR || ${VAR}) and tilde (~)
// expansion for user home directories. It ensures the returned path ends with a trailing
// slash for consistency. If the path starts with ~/ or is exactly ~/, it replaces the
// tilde portion with the current user's home directory.
//
// The function processes the input in the following order:
// 1. Expands environment variables using os.ExpandEnv
// 2. Adds trailing slash if not present
// 3. Performs tilde expansion if path starts with ~/ or is exactly ~
//
// Note: The function has some quirks in its current implementation:
// - Returns empty string if user lookup fails during tilde expansion
//
// Parameters:
//   - folder: The folder path to expand (can contain environment variables and ~/)
//
// Returns the expanded folder path with trailing slash, or empty string if user lookup fails.
//
// Example:
//
//        expanded := ExpandFolder("~/Documents")        // Returns "/Users/username/Documents" (no trailing slash due to filepath.Join)
//        expanded := ExpandFolder("$HOME/config")       // Returns "/Users/username/config/"
//        expanded := ExpandFolder("/absolute/path")     // Returns "/absolute/path/"
//        expanded := ExpandFolder("~")                  // Returns "/Users/username/"
func ExpandFolder(folder string) string <span class="cov10" title="27">{
        folderPath := os.ExpandEnv(folder)
        if folderPath == "~" || strings.HasPrefix(folderPath, "~/") </span><span class="cov7" title="10">{
                usr, err := user.Current()
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov7" title="10">folderPath = filepath.Join(usr.HomeDir, folderPath[1:])</span>
        }
        <span class="cov10" title="27">if !strings.HasSuffix(folderPath, "/") </span><span class="cov9" title="25">{
                folderPath += "/"
        }</span>
        <span class="cov10" title="27">return folderPath</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package common provides shared utilities and types for the ARK SDK.
//
// This package implements cross-platform keyring support with automatic fallback mechanisms
// for different environments including Docker containers, WSL, and various operating systems.
// The keyring handles token expiration, automatic cleanup, and secure storage of authentication
// credentials for ARK SDK applications.
package common

import (
        "encoding/json"
        "os"
        "runtime"
        "strings"
        "time"

        "github.com/cyberark/ark-sdk-golang/internal/common"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
)

// Env vars and definitions
const (
        ArkBasicKeyringOverrideEnvVar      = "ARK_BASIC_KEYRING"
        DBusSessionEnvVar                  = "DBUS_SESSION_BUS_ADDRESS"
        DefaultExpirationGraceDeltaSeconds = 60
        MaxKeyringRecordTimeHours          = 12
)

// ArkKeyring represents a keyring for storing and retrieving authentication tokens.
//
// ArkKeyring provides a secure storage mechanism for authentication tokens with
// automatic fallback to basic keyring when system keyrings are unavailable. It
// supports different keyring backends based on the operating system and environment,
// including Docker containers and WSL environments.
//
// The keyring handles token expiration, refresh token management, and automatic
// cleanup of expired tokens based on configurable time limits.
type ArkKeyring struct {
        serviceName string
        logger      *ArkLogger
}

// NewArkKeyring creates a new instance of ArkKeyring with the specified service name.
//
// The service name is used as a namespace for storing tokens in the keyring,
// allowing multiple applications or services to use the same keyring without
// conflicts.
//
// Parameters:
//   - serviceName: The name used to identify this service's tokens in the keyring
//
// Returns a new ArkKeyring instance configured with the provided service name
// and a logger for keyring operations.
//
// Example:
//
//        keyring := NewArkKeyring("myapp")
func NewArkKeyring(serviceName string) *ArkKeyring <span class="cov10" title="25">{
        return &amp;ArkKeyring{
                serviceName: serviceName,
                logger:      GetLogger("ArkKeyring", Unknown),
        }
}</span>

func (a *ArkKeyring) isDocker() bool <span class="cov9" title="24">{
        if _, err := os.Stat("/.dockerenv"); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov9" title="24">if data, err := os.ReadFile("/proc/self/cgroup"); err == nil </span><span class="cov0" title="0">{
                return strings.Contains(string(data), "docker")
        }</span>
        <span class="cov9" title="24">return false</span>
}

func (a *ArkKeyring) isWSL() bool <span class="cov9" title="23">{
        if data, err := os.ReadFile("/proc/version"); err == nil </span><span class="cov0" title="0">{
                return strings.Contains(string(data), "Microsoft")
        }</span>
        <span class="cov9" title="23">return false</span>
}

// GetKeyring returns a keyring instance based on the operating system and environment.
//
// GetKeyring automatically selects the most appropriate keyring backend based on
// the current environment. It falls back to basic keyring in Docker containers,
// WSL environments, when the ARK_BASIC_KEYRING environment variable is set, or
// when enforceBasicKeyring is true. For Windows, macOS, and Linux systems with
// proper D-Bus session, it attempts to use system-specific secure storage.
//
// Parameters:
//   - enforceBasicKeyring: When true, forces the use of basic keyring regardless of environment
//
// Returns a BasicKeyring instance configured for the current environment, or an
// error if keyring initialization fails.
//
// Example:
//
//        keyring, err := arkKeyring.GetKeyring(false)
//        if err != nil {
//            // handle error
//        }
func (a *ArkKeyring) GetKeyring(enforceBasicKeyring bool) (*common.BasicKeyring, error) <span class="cov9" title="21">{
        if a.isDocker() || a.isWSL() || os.Getenv(ArkBasicKeyringOverrideEnvVar) != "" || enforceBasicKeyring </span><span class="cov9" title="18">{
                return common.NewBasicKeyring(), nil
        }</span>
        <span class="cov4" title="3">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // TODO - Implement Windows-specific keyring logic here
                return common.NewBasicKeyring(), nil
        }</span>
        <span class="cov4" title="3">if os.Getenv(DBusSessionEnvVar) == "" </span><span class="cov1" title="1">{
                return common.NewBasicKeyring(), nil
        }</span>
        <span class="cov2" title="2">if runtime.GOOS == "darwin" || runtime.GOOS == "linux" </span><span class="cov2" title="2">{
                // TODO - Implement SecretService keyring logic here
                return common.NewBasicKeyring(), nil
        }</span>
        <span class="cov0" title="0">return common.NewBasicKeyring(), nil</span>
}

// SaveToken saves an authentication token to the keyring for the specified profile and postfix.
//
// SaveToken stores the provided token in the keyring using a composite key format
// of "serviceName-postfix" and the profile name. The token is serialized to JSON
// before storage. If the initial save fails and enforceBasicKeyring is false,
// it automatically falls back to basic keyring storage.
//
// Parameters:
//   - profile: The ARK profile containing the profile name used as the keyring username
//   - token: The authentication token to store in the keyring
//   - postfix: A suffix added to the service name to create unique keys for different token types
//   - enforceBasicKeyring: When true, uses basic keyring without attempting system keyring first
//
// Returns an error if the token cannot be saved to any available keyring backend.
//
// Example:
//
//        err := keyring.SaveToken(profile, token, "access", false)
//        if err != nil {
//            // handle save error
//        }
func (a *ArkKeyring) SaveToken(profile *models.ArkProfile, token *auth.ArkToken, postfix string, enforceBasicKeyring bool) error <span class="cov6" title="8">{
        a.logger.Info("Trying to save token [%s-%s] of profile [%s]", a.serviceName, postfix, profile.ProfileName)
        kr, err := a.GetKeyring(enforceBasicKeyring)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="8">tokenData, err := json.Marshal(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="8">if err := kr.SetPassword(a.serviceName+"-"+postfix, profile.ProfileName, string(tokenData)); err != nil </span><span class="cov0" title="0">{
                if !enforceBasicKeyring </span><span class="cov0" title="0">{
                        a.logger.Warning("Falling back to basic keyring as we failed to save token with keyring [%v]", kr)
                        return a.SaveToken(profile, token, postfix, true)
                }</span>
                <span class="cov0" title="0">a.logger.Warning("Failed to save token [%v]", err)
                return err</span>
        }
        <span class="cov6" title="8">a.logger.Info("Saved token successfully")
        return nil</span>
}

// LoadToken loads an authentication token from the keyring for the specified profile and postfix.
//
// LoadToken retrieves and validates a stored authentication token from the keyring.
// It performs automatic token expiration checking and cleanup. For tokens without
// refresh capability that are expired beyond the grace period, the token is removed
// and nil is returned. For tokens with refresh capability that have been cached
// too long, they are also removed and nil is returned. If the initial load fails
// and enforceBasicKeyring is false, it automatically falls back to basic keyring.
//
// Parameters:
//   - profile: The ARK profile containing the profile name used as the keyring username
//   - postfix: A suffix added to the service name to match the key used during SaveToken
//   - enforceBasicKeyring: When true, uses basic keyring without attempting system keyring first
//
// Returns the loaded token if found and valid, nil if no token exists or token
// is expired, or an error if the keyring operation fails.
//
// Example:
//
//        token, err := keyring.LoadToken(profile, "access", false)
//        if err != nil {
//            // handle load error
//        }
//        if token == nil {
//            // no valid token found, need to authenticate
//        }
func (a *ArkKeyring) LoadToken(profile *models.ArkProfile, postfix string, enforceBasicKeyring bool) (*auth.ArkToken, error) <span class="cov6" title="6">{
        a.logger.Info("Trying to load token [%s-%s] of profile [%s]", a.serviceName, postfix, profile.ProfileName)
        kr, err := a.GetKeyring(enforceBasicKeyring)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="6">tokenData, err := kr.GetPassword(a.serviceName+"-"+postfix, profile.ProfileName)
        if err != nil </span><span class="cov0" title="0">{
                if !enforceBasicKeyring </span><span class="cov0" title="0">{
                        a.logger.Warning("Falling back to basic keyring as we failed to load token with keyring [%v]", kr)
                        return a.LoadToken(profile, postfix, true)
                }</span>
                <span class="cov0" title="0">a.logger.Warning("Failed to load cached token [%v]", err)
                return nil, err</span>
        }
        <span class="cov6" title="6">if tokenData == "" </span><span class="cov1" title="1">{
                a.logger.Info("No token found")
                return nil, nil
        }</span>
        <span class="cov5" title="5">var token auth.ArkToken
        if err := json.Unmarshal([]byte(tokenData), &amp;token); err != nil </span><span class="cov1" title="1">{
                a.logger.Info("Token failed to be parsed [%v]", err)
                return nil, err
        }</span>
        <span class="cov4" title="4">if !time.Time(token.ExpiresIn).IsZero() </span><span class="cov4" title="3">{
                if token.RefreshToken == "" &amp;&amp; token.TokenType != auth.Internal &amp;&amp; time.Time(token.ExpiresIn).Before(time.Now().Add(-DefaultExpirationGraceDeltaSeconds*time.Second)) </span><span class="cov1" title="1">{
                        a.logger.Info("Token is expired and no refresh token exists")
                        err := kr.DeletePassword(a.serviceName+"-"+postfix, profile.ProfileName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov1" title="1">return nil, nil</span>
                }
                <span class="cov2" title="2">if token.RefreshToken != "" &amp;&amp; time.Time(token.ExpiresIn).Add(MaxKeyringRecordTimeHours*time.Hour).Before(time.Now()) </span><span class="cov1" title="1">{
                        a.logger.Info("Token is expired and has been in the cache for too long before another usage")
                        err := kr.DeletePassword(a.serviceName+"-"+postfix, profile.ProfileName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov1" title="1">return nil, nil</span>
                }
        }
        <span class="cov2" title="2">a.logger.Info("Loaded token successfully")
        return &amp;token, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package common provides shared utilities and types for the ARK SDK.
//
// This package implements a custom logger with configurable log levels,
// color-coded output, and environment variable support for configuration.
package common

import (
        "fmt"
        "log"
        "os"
        "strings"
)

// Log level constants for ArkLogger.
//
// These constants define the severity levels used by the logging system.
// Higher numbers indicate more verbose output (Debug=4 is most verbose,
// Critical=0 is least verbose).
const (
        Debug    = 4
        Info     = 3
        Warning  = 2
        Error    = 1
        Critical = 0
        Unknown  = -1
)

// Environment variable names for logger configuration.
//
// These constants define the environment variables that can be used
// to configure the logger behavior at runtime.
const (
        LoggerStyle        = "LOGGER_STYLE"
        LogLevel           = "LOG_LEVEL"
        LoggerStyleDefault = "default"
)

// ArkLogger provides structured logging with configurable levels and output formatting.
//
// ArkLogger wraps the standard log.Logger and adds features like:
// - Configurable log levels (Debug, Info, Warning, Error, Critical)
// - Color-coded console output
// - Environment variable configuration
// - Verbose mode control
//
// The logger supports both static configuration and dynamic environment-based
// configuration for flexible deployment scenarios.
type ArkLogger struct {
        *log.Logger
        verbose                bool
        logLevel               int
        name                   string
        resolveLogLevelFromEnv bool
}

// NewArkLogger creates a new instance of ArkLogger with the specified configuration.
//
// This function initializes a new logger with the provided settings. The logger
// will output to stdout with timestamp formatting and can be configured for
// different verbosity levels and environment-based configuration.
//
// Parameters:
//   - name: The name/prefix for log messages
//   - level: The minimum log level (0=Critical, 1=Error, 2=Warning, 3=Info, 4=Debug)
//   - verbose: Whether to enable verbose output (false disables all logging)
//   - resolveLogLevelFromEnv: Whether to dynamically resolve log level from LOG_LEVEL env var
//
// Returns a configured ArkLogger instance ready for use.
//
// Example:
//
//        logger := NewArkLogger("myapp", Info, true, false)
//        logger.Info("Application started")
func NewArkLogger(name string, level int, verbose bool, resolveLogLevelFromEnv bool) *ArkLogger <span class="cov9" title="60">{
        return &amp;ArkLogger{
                Logger:                 log.New(os.Stdout, name, log.LstdFlags),
                name:                   name,
                verbose:                verbose,
                logLevel:               level,
                resolveLogLevelFromEnv: resolveLogLevelFromEnv,
        }
}</span>

// LogLevelFromEnv retrieves the log level from the LOG_LEVEL environment variable.
//
// This function reads the LOG_LEVEL environment variable and converts it to
// the corresponding integer log level. If the environment variable is not set
// or empty, it defaults to Critical level.
//
// Returns the integer log level corresponding to the environment variable value,
// or Critical (0) if the variable is not set or contains an invalid value.
//
// Example:
//
//        os.Setenv("LOG_LEVEL", "DEBUG")
//        level := LogLevelFromEnv() // Returns 4 (Debug)
func LogLevelFromEnv() int <span class="cov10" title="67">{
        logLevelStr := os.Getenv(LogLevel)
        if logLevelStr == "" </span><span class="cov9" title="58">{
                return Critical
        }</span>
        <span class="cov5" title="9">return StrToLogLevel(logLevelStr)</span>
}

// StrToLogLevel converts a string representation of a log level to its integer value.
//
// This function parses string log level names (case-insensitive) and returns
// the corresponding integer constant. Supported values are DEBUG, INFO, WARNING,
// ERROR, and CRITICAL. Any unrecognized value defaults to Critical.
//
// Parameters:
//   - logLevelStr: String representation of the log level (e.g., "DEBUG", "info", "Warning")
//
// Returns the integer constant corresponding to the log level, or Critical (0)
// for unrecognized input.
//
// Example:
//
//        level := StrToLogLevel("DEBUG")    // Returns 4
//        level := StrToLogLevel("invalid")  // Returns 0 (Critical)
func StrToLogLevel(logLevelStr string) int <span class="cov7" title="19">{
        switch strings.ToUpper(logLevelStr) </span>{
        case "DEBUG":<span class="cov3" title="4">
                return Debug</span>
        case "INFO":<span class="cov3" title="3">
                return Info</span>
        case "WARNING":<span class="cov2" title="2">
                return Warning</span>
        case "ERROR":<span class="cov2" title="2">
                return Error</span>
        case "CRITICAL":<span class="cov3" title="3">
                return Critical</span>
        default:<span class="cov4" title="5">
                return Critical</span>
        }
}

// LogLevel returns the current effective log level of the logger.
//
// This method returns the log level that will be used for filtering log messages.
// If the logger is configured to resolve the level from environment variables,
// it will dynamically read the LOG_LEVEL environment variable. Otherwise,
// it returns the static log level set during logger creation.
//
// Returns the current log level as an integer (0=Critical, 1=Error, 2=Warning, 3=Info, 4=Debug).
func (l *ArkLogger) LogLevel() int <span class="cov9" title="46">{
        if l.resolveLogLevelFromEnv </span><span class="cov8" title="32">{
                return LogLevelFromEnv()
        }</span>
        <span class="cov6" title="14">return l.logLevel</span>
}

// SetVerbose sets the verbosity mode of the logger.
//
// When verbose is false, the logger will not output any messages regardless
// of the log level. This provides a master switch to disable all logging
// output from the logger instance.
//
// Parameters:
//   - value: true to enable verbose output, false to disable all output
func (l *ArkLogger) SetVerbose(value bool) <span class="cov3" title="4">{
        l.verbose = value
}</span>

// Debug logs a debug message with green color formatting.
//
// Debug messages are only output when the logger is in verbose mode and
// the current log level is set to Debug (4) or higher. Debug messages
// are typically used for detailed diagnostic information.
//
// Parameters:
//   - msg: Format string for the log message
//   - v: Optional format arguments for the message string
//
// Example:
//
//        logger.Debug("Processing user %s with ID %d", username, userID)
func (l *ArkLogger) Debug(msg string, v ...interface{}) <span class="cov4" title="5">{
        if !l.verbose </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov3" title="4">if l.LogLevel() &lt; Debug </span><span class="cov2" title="2">{
                return
        }</span>
        <span class="cov2" title="2">colorMsg := fmt.Sprintf("| DEBUG | \033[1;32m%s\033[0m", fmt.Sprintf(msg, v...))
        l.Logger.Println(colorMsg)</span>
}

// Info logs an informational message with green color formatting.
//
// Info messages are output when the logger is in verbose mode and
// the current log level is set to Info (3) or higher. Info messages
// are used for general application flow information.
//
// Parameters:
//   - msg: Format string for the log message
//   - v: Optional format arguments for the message string
//
// Example:
//
//        logger.Info("User %s logged in successfully", username)
func (l *ArkLogger) Info(msg string, v ...interface{}) <span class="cov8" title="32">{
        if !l.verbose </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov8" title="31">if l.LogLevel() &lt; Info </span><span class="cov8" title="29">{
                return
        }</span>
        <span class="cov2" title="2">colorMsg := fmt.Sprintf("| INFO | \033[32m%s\033[0m", fmt.Sprintf(msg, v...))
        l.Logger.Println(colorMsg)</span>
}

// Warning logs a warning message with yellow color formatting.
//
// Warning messages are output when the logger is in verbose mode and
// the current log level is set to Warning (2) or higher. Warning messages
// indicate potentially problematic situations that don't prevent operation.
//
// Parameters:
//   - msg: Format string for the log message
//   - v: Optional format arguments for the message string
//
// Example:
//
//        logger.Warning("Rate limit approaching for user %s", username)
func (l *ArkLogger) Warning(msg string, v ...interface{}) <span class="cov3" title="4">{
        if !l.verbose </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov3" title="3">if l.LogLevel() &lt; Warning </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">colorMsg := fmt.Sprintf("| WARNING | \033[33m%s\033[0m", fmt.Sprintf(msg, v...))
        l.Logger.Println(colorMsg)</span>
}

// Error logs an error message with red color formatting.
//
// Error messages are output when the logger is in verbose mode and
// the current log level is set to Error (1) or higher. Error messages
// indicate error conditions that should be investigated.
//
// Parameters:
//   - msg: Format string for the log message
//   - v: Optional format arguments for the message string
//
// Example:
//
//        logger.Error("Failed to connect to database: %v", err)
func (l *ArkLogger) Error(msg string, v ...interface{}) <span class="cov3" title="4">{
        if !l.verbose </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov3" title="3">if l.LogLevel() &lt; Error </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov2" title="2">colorMsg := fmt.Sprintf("| ERROR | \033[31m%s\033[0m", fmt.Sprintf(msg, v...))
        l.Logger.Println(colorMsg)</span>
}

// Fatal logs a fatal error message with bright red color formatting and exits the program.
//
// Fatal messages are output when the logger is in verbose mode and
// the current log level is set to Critical (0) or higher. After logging
// the message, this method calls os.Exit(-1) to terminate the program.
// This should only be used for unrecoverable error conditions.
//
// Parameters:
//   - msg: Format string for the log message
//   - v: Optional format arguments for the message string
//
// Example:
//
//        logger.Fatal("Cannot start application: %v", err)
//        // Program terminates after this call
func (l *ArkLogger) Fatal(msg string, v ...interface{}) <span class="cov0" title="0">{
        if !l.verbose </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if l.LogLevel() &lt; Critical </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">colorMsg := fmt.Sprintf("| FATAL | \033[1;31m%s\033[0m", fmt.Sprintf(msg, v...))
        l.Logger.Println(colorMsg)
        os.Exit(-1)</span>
}

// GetLogger creates a new instance of ArkLogger with application-specific configuration.
//
// This is the primary factory function for creating logger instances. It handles
// environment variable resolution, logger style configuration, and sets up
// appropriate formatting. If logLevel is -1, the logger will dynamically
// resolve the log level from the LOG_LEVEL environment variable.
//
// Parameters:
//   - app: Application name used as the logger prefix
//   - logLevel: Static log level (0-4), or -1 to resolve from environment
//
// Returns a configured ArkLogger instance, or nil if an unsupported logger
// style is specified in the LOGGER_STYLE environment variable.
//
// Example:
//
//        logger := GetLogger("myapp", Info)        // Static Info level
//        envLogger := GetLogger("myapp", -1)       // Dynamic level from env
func GetLogger(app string, logLevel int) *ArkLogger <span class="cov8" title="31">{
        resolveLogLevelFromEnv := false
        if logLevel == -1 </span><span class="cov8" title="27">{
                resolveLogLevelFromEnv = true
                logLevel = LogLevelFromEnv()
        }</span>
        <span class="cov8" title="31">envLoggerStyle := os.Getenv(LoggerStyle)
        if envLoggerStyle == "" </span><span class="cov8" title="29">{
                envLoggerStyle = LoggerStyleDefault
        }</span>
        <span class="cov8" title="31">loggerStyle := strings.ToLower(envLoggerStyle)
        if loggerStyle == LoggerStyleDefault </span><span class="cov8" title="30">{
                logFormat := "%s | "
                logger := NewArkLogger(app, logLevel, true, resolveLogLevelFromEnv)
                logger.SetFlags(log.LstdFlags)
                logger.SetPrefix(fmt.Sprintf(logFormat, app))
                return logger
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// GlobalLogger is the global logger instance for the Ark SDK.
//
// This variable provides a package-level logger that can be used throughout
// the Ark SDK. It is configured to resolve its log level from the LOG_LEVEL
// environment variable and uses "ark-sdk" as its prefix.
//
// Example:
//
//        common.GlobalLogger.Info("SDK operation completed")
var GlobalLogger = GetLogger("ark-sdk", -1)
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package common provides random utility functions for generating secure passwords,
// random strings, IP addresses, and other randomized data used throughout the ARK SDK.
//
// This package includes both cryptographically secure random generation using crypto/rand
// and pseudo-random generation using math/rand for different use cases.
package common

import (
        "crypto/rand"
        "math/big"
        mathrand "math/rand"
        "net"
)

// RandomIPAddress generates a random IPv4 address using pseudo-random number generation.
//
// RandomIPAddress creates a random IPv4 address by generating a random 32-bit unsigned
// integer and converting it to IPv4 format. This function uses math/rand for generation,
// making it suitable for testing and non-cryptographic purposes.
//
// Returns a string representation of a random IPv4 address in dotted decimal notation.
//
// Example:
//
//        ip := RandomIPAddress()
//        // ip might be "192.168.1.100" or any other valid IPv4 address
func RandomIPAddress() string <span class="cov3" title="5">{
        ip := mathrand.Uint32()
        return net.IPv4(byte(ip&gt;&gt;24), byte(ip&gt;&gt;16), byte(ip&gt;&gt;8), byte(ip)).String()
}</span>

// RandomString generates a random string of specified length using alphanumeric characters.
//
// RandomString creates a random string containing uppercase letters, lowercase letters,
// and digits. This function uses math/rand for generation, making it suitable for
// testing and non-cryptographic purposes where predictable randomness is acceptable.
//
// Parameters:
//   - n: The desired length of the generated string (must be &gt;= 0)
//
// Returns a random string of length n containing characters from [a-zA-Z0-9].
//
// Example:
//
//        str := RandomString(10)
//        // str might be "aBc123XyZ9" or any other 10-character alphanumeric string
func RandomString(n int) string <span class="cov5" title="16">{
        const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, n)
        for i := range b </span><span class="cov10" title="281">{
                b[i] = letters[mathrand.Intn(len(letters))]
        }</span>
        <span class="cov5" title="16">return string(b)</span>
}

// RandomNumberString generates a random string of digits of specified length.
//
// RandomNumberString creates a random string containing only numeric digits (0-9).
// This function uses math/rand for generation, making it suitable for testing
// and non-cryptographic purposes where predictable randomness is acceptable.
//
// Parameters:
//   - n: The desired length of the generated numeric string (must be &gt;= 0)
//
// Returns a random string of length n containing only digits from [0-9].
//
// Example:
//
//        numStr := RandomNumberString(6)
//        // numStr might be "123456" or any other 6-digit numeric string
func RandomNumberString(n int) string <span class="cov4" title="7">{
        const numbers = "0123456789"
        b := make([]byte, n)
        for i := range b </span><span class="cov8" title="102">{
                b[i] = numbers[mathrand.Intn(len(numbers))]
        }</span>
        <span class="cov4" title="7">return string(b)</span>
}

func randomChar(charset string) byte <span class="cov9" title="157">{
        index, _ := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
        return charset[index.Int64()]
}</span>

func shuffle(data []byte) <span class="cov5" title="20">{
        for i := len(data) - 1; i &gt; 0; i-- </span><span class="cov9" title="158">{
                j, _ := rand.Int(rand.Reader, big.NewInt(int64(i+1)))
                data[i], data[j.Int64()] = data[j.Int64()], data[i]
        }</span>
}

// RandomPassword generates a cryptographically secure random password of specified length.
//
// RandomPassword creates a password that contains at least one digit, one lowercase
// letter, and one uppercase letter. The remaining characters are randomly selected
// from the full character set. The password is then shuffled to randomize character
// positions. This function uses crypto/rand for secure random generation.
//
// Parameters:
//   - n: The desired length of the generated password (must be &gt;= 3)
//
// Returns a random password of length n that meets complexity requirements.
// Panics if n &lt; 3 since a secure password requires at least one character from
// each required character class.
//
// Example:
//
//        password := RandomPassword(12)
//        // password might be "A7b9X2mN5qP1" with guaranteed character diversity
func RandomPassword(n int) string <span class="cov5" title="18">{
        if n &lt; 3 </span><span class="cov2" title="3">{
                panic("Password length must be at least 3")</span>
        }
        <span class="cov5" title="15">const (
                digits    = "0123456789"
                lowercase = "abcdefghijklmnopqrstuvwxyz"
                uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                allChars  = digits + lowercase + uppercase
        )

        // Ensure the password contains at least one digit, one lowercase, and one uppercase character
        password := []byte{
                randomChar(digits),
                randomChar(lowercase),
                randomChar(uppercase),
        }

        // Fill the rest of the password with random characters from allChars
        for i := 3; i &lt; n; i++ </span><span class="cov8" title="107">{
                password = append(password, randomChar(allChars))
        }</span>

        // Shuffle the password to randomize character positions
        <span class="cov5" title="15">shuffle(password)

        return string(password)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package common

import (
        "fmt"
        "math/rand"
        "time"
)

// RetryCall executes a function with retry logic using exponential backoff.
//
// The function will be retried up to 'tries' times with an initial delay of 'delay' seconds.
// After each failed attempt, the delay is multiplied by 'backoff' and optional jitter is added.
// If maxDelay is specified, the delay will not exceed this value.
//
// Parameters:
//   - fn: The function to execute and retry on failure
//   - tries: Maximum number of attempts (must be &gt; 0)
//   - delay: Initial delay between retries in seconds
//   - maxDelay: Optional maximum delay cap in seconds (nil for no limit)
//   - backoff: Multiplier applied to delay after each attempt
//   - jitter: Additional delay randomization - either fixed int or [2]int range
//   - logger: Optional callback to log retry attempts (receives error and current delay)
//
// Returns nil on success, or the last error encountered if all retries are exhausted.
//
// Example:
//
//        err := RetryCall(
//            func() error { return someOperation() },
//            3,     // max 3 attempts
//            1,     // start with 1 second delay
//            &amp;10,   // cap at 10 seconds
//            2,     // double delay each time
//            [2]int{0, 500}, // add 0-500ms jitter
//            func(err error, delay int) { log.Printf("Retry in %ds: %v", delay, err) },
//        )
func RetryCall(
        fn func() error,
        tries int,
        delay int,
        maxDelay *int,
        backoff int,
        jitter interface{},
        logger func(error, int),
) error <span class="cov8" title="9">{
        _tries, _delay := tries, delay
        for _tries != 0 </span><span class="cov10" title="16">{
                err := fn()
                if err == nil </span><span class="cov6" title="6">{
                        return nil
                }</span>

                <span class="cov8" title="10">_tries--
                if _tries == 0 </span><span class="cov3" title="2">{
                        return err
                }</span>

                <span class="cov7" title="8">if logger != nil </span><span class="cov3" title="2">{
                        logger(err, _delay)
                }</span>

                <span class="cov7" title="8">time.Sleep(time.Duration(_delay) * time.Second)
                _delay *= backoff

                switch j := jitter.(type) </span>{
                case int:<span class="cov7" title="7">
                        _delay += j</span>
                case [2]int:<span class="cov1" title="1">
                        _delay += rand.Intn(j[1]-j[0]) + j[0]</span>
                }

                <span class="cov7" title="8">if maxDelay != nil &amp;&amp; _delay &gt; *maxDelay </span><span class="cov1" title="1">{
                        _delay = *maxDelay
                }</span>
        }
        <span class="cov1" title="1">return fmt.Errorf("retries exhausted")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package common provides JSON serialization and deserialization utilities for the ARK SDK.
//
// This package handles conversion between different JSON key naming conventions (camelCase
// and snake_case) and provides utilities for serializing/deserializing JSON data with
// optional schema validation. It supports both simple conversions and schema-aware
// transformations that preserve specific field mappings based on struct tags.
package common

import (
        "encoding/json"
        "io"
        "reflect"
        "strings"

        "github.com/iancoleman/strcase"
)

func resolveFieldsSquashed(schema reflect.Type) []reflect.StructField <span class="cov6" title="8">{
        var fields []reflect.StructField
        if schema.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                schema = schema.Elem()
        }</span>
        <span class="cov6" title="8">for i := 0; i &lt; schema.NumField(); i++ </span><span class="cov9" title="30">{
                field := schema.Field(i)
                if field.Tag.Get("mapstructure") == ",squash" </span><span class="cov1" title="1">{
                        nestedFields := resolveFieldsSquashed(field.Type)
                        fields = append(fields, nestedFields...)
                        continue</span>
                }
                <span class="cov9" title="29">if field.PkgPath != "" </span><span class="cov0" title="0">{ // unexported field
                        continue</span>
                }
                <span class="cov9" title="29">fields = append(fields, field)</span>
        }
        <span class="cov6" title="8">return fields</span>
}

func findFieldByName(schema reflect.Type, name string) *reflect.StructField <span class="cov4" title="4">{
        flagNameTitled := strings.Replace(strings.Replace(strings.Title(name), "-", "", -1), "_", "", -1)
        if schema.Kind() == reflect.Ptr </span><span class="cov1" title="1">{
                schema = schema.Elem()
        }</span>
        <span class="cov4" title="4">field, ok := schema.FieldByName(flagNameTitled)
        if ok </span><span class="cov0" title="0">{
                return &amp;field
        }</span>
        <span class="cov4" title="4">actualFields := resolveFieldsSquashed(schema)
        for i := 0; i &lt; len(actualFields); i++ </span><span class="cov6" title="8">{
                possibleField := actualFields[i]
                if strings.EqualFold(possibleField.Name, flagNameTitled) </span><span class="cov3" title="3">{
                        return &amp;possibleField
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// SerializeResponseToJSON takes an io.ReadCloser response and serializes it to a JSON string.
//
// SerializeResponseToJSON reads all data from the provided io.ReadCloser, attempts to
// parse it as JSON, and returns a properly formatted JSON string. If the input data
// is not valid JSON, it returns the original data as a string. This function is useful
// for normalizing response data into a consistent JSON format.
//
// Parameters:
//   - response: The io.ReadCloser containing the response data to serialize
//
// Returns a JSON string representation of the response data, or the original data
// as a string if JSON parsing fails.
//
// Example:
//
//        jsonStr := SerializeResponseToJSON(httpResponse.Body)
//        fmt.Println(jsonStr) // Outputs properly formatted JSON
func SerializeResponseToJSON(response io.ReadCloser) string <span class="cov6" title="10">{
        data, err := io.ReadAll(response)
        if err != nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov6" title="9">jsonMap := make(map[string]interface{})
        err = json.Unmarshal(data, &amp;jsonMap)
        if err != nil </span><span class="cov5" title="7">{
                return string(data)
        }</span>
        <span class="cov2" title="2">jsonData, err := json.Marshal(jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return string(data)
        }</span>
        <span class="cov2" title="2">return string(jsonData)</span>
}

// ConvertToSnakeCase converts a map with camelCase keys to snake_case keys.
//
// ConvertToSnakeCase recursively processes data structures, converting all string keys
// from camelCase to snake_case format. It supports nested maps, slices, and arbitrary
// data types. When a schema is provided, it uses struct field information to determine
// whether specific fields should be converted or preserved as-is (e.g., for map fields
// with string keys that should not be converted).
//
// Parameters:
//   - data: The data structure to convert (supports maps, slices, and primitive types)
//   - schema: Optional reflect.Type pointer for schema-aware conversion (nil for simple conversion)
//
// Returns the converted data structure with snake_case keys.
//
// Example:
//
//        input := map[string]interface{}{"firstName": "John", "lastName": "Doe"}
//        result := ConvertToSnakeCase(input, nil)
//        // result: map[string]interface{}{"first_name": "John", "last_name": "Doe"}
func ConvertToSnakeCase(data interface{}, schema *reflect.Type) interface{} <span class="cov10" title="40">{
        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov7" title="13">
                snakeMap := make(map[string]interface{})
                for key, value := range v </span><span class="cov8" title="24">{
                        snakeKey := strcase.ToSnake(key)
                        var innerFieldType *reflect.Type
                        if schema != nil </span><span class="cov0" title="0">{
                                innerField := findFieldByName(*schema, key)
                                if innerField == nil || (innerField.Type.Kind() == reflect.Map &amp;&amp; innerField.Type.Key().Kind() == reflect.String) </span><span class="cov0" title="0">{
                                        snakeKey = key
                                }</span>
                                <span class="cov0" title="0">if innerField != nil </span><span class="cov0" title="0">{
                                        if innerField.Type.Kind() == reflect.Slice || innerField.Type.Kind() == reflect.Array || innerField.Type.Kind() == reflect.Map </span><span class="cov0" title="0">{
                                                elem := innerField.Type.Elem()
                                                innerFieldType = &amp;elem
                                        }</span> else<span class="cov0" title="0"> {
                                                innerFieldType = &amp;innerField.Type
                                        }</span>
                                }
                        }
                        <span class="cov8" title="24">snakeMap[snakeKey] = ConvertToSnakeCase(value, innerFieldType)</span>
                }
                <span class="cov7" title="13">return snakeMap</span>
        case []interface{}:<span class="cov2" title="2">
                for i, item := range v </span><span class="cov4" title="4">{
                        v[i] = ConvertToSnakeCase(item, schema)
                }</span>
                <span class="cov2" title="2">return v</span>
        default:<span class="cov8" title="25">
                return v</span>
        }
}

// ConvertToCamelCase converts a map with snake_case keys to camelCase keys.
//
// ConvertToCamelCase recursively processes data structures, converting all string keys
// from snake_case to camelCase format. It supports nested maps, slices, and arbitrary
// data types. When a schema is provided, it uses struct field information to determine
// whether specific fields should be converted or preserved as-is (e.g., for map fields
// with string keys that should not be converted).
//
// Parameters:
//   - data: The data structure to convert (supports maps, slices, and primitive types)
//   - schema: Optional reflect.Type pointer for schema-aware conversion (nil for simple conversion)
//
// Returns the converted data structure with camelCase keys.
//
// Example:
//
//        input := map[string]interface{}{"first_name": "John", "last_name": "Doe"}
//        result := ConvertToCamelCase(input, nil)
//        // result: map[string]interface{}{"firstName": "John", "lastName": "Doe"}
func ConvertToCamelCase(data interface{}, schema *reflect.Type) interface{} <span class="cov10" title="40">{
        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov7" title="12">
                camelMap := make(map[string]interface{})
                for key, value := range v </span><span class="cov9" title="27">{
                        camelKey := strcase.ToLowerCamel(key)
                        var innerFieldType *reflect.Type
                        if schema != nil </span><span class="cov0" title="0">{
                                innerField := findFieldByName(*schema, key)
                                if innerField == nil || (innerField.Type.Kind() == reflect.Map &amp;&amp; innerField.Type.Key().Kind() == reflect.String) </span><span class="cov0" title="0">{
                                        camelKey = key
                                }</span>
                                <span class="cov0" title="0">if innerField != nil </span><span class="cov0" title="0">{
                                        if innerField.Type.Kind() == reflect.Slice || innerField.Type.Kind() == reflect.Array || innerField.Type.Kind() == reflect.Map </span><span class="cov0" title="0">{
                                                elem := innerField.Type.Elem()
                                                innerFieldType = &amp;elem
                                        }</span> else<span class="cov0" title="0"> {
                                                innerFieldType = &amp;innerField.Type
                                        }</span>
                                }
                        }
                        <span class="cov9" title="27">camelMap[camelKey] = ConvertToCamelCase(value, innerFieldType)</span>
                }
                <span class="cov7" title="12">return camelMap</span>
        case []interface{}:<span class="cov1" title="1">
                for i, item := range v </span><span class="cov2" title="2">{
                        v[i] = ConvertToCamelCase(item, schema)
                }</span>
                <span class="cov1" title="1">return v</span>
        default:<span class="cov9" title="27">
                return v</span>
        }
}

// DeserializeJSONSnake takes an io.ReadCloser response and deserializes it into a map with snake_case keys.
//
// DeserializeJSONSnake reads JSON data from the provided io.ReadCloser, parses it,
// and converts all keys from the original format to snake_case. This function is
// useful for normalizing JSON responses that may have keys in camelCase or other
// formats to a consistent snake_case format.
//
// Parameters:
//   - response: The io.ReadCloser containing JSON data to deserialize
//
// Returns the deserialized data with snake_case keys and any error encountered
// during JSON decoding.
//
// Example:
//
//        data, err := DeserializeJSONSnake(httpResponse.Body)
//        if err != nil {
//            log.Fatal(err)
//        }
//        // data contains the JSON with snake_case keys
func DeserializeJSONSnake(response io.ReadCloser) (interface{}, error) <span class="cov4" title="5">{
        var result interface{}
        err := json.NewDecoder(response).Decode(&amp;result)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov4" title="4">return ConvertToSnakeCase(result, nil).(interface{}), nil</span>
}

// SerializeJSONCamel takes an interface and serializes it into a map with camelCase keys.
//
// SerializeJSONCamel converts the provided data structure to JSON, then parses it
// back into a map with all keys converted to camelCase format. This function is
// useful for preparing data for APIs or systems that expect camelCase key naming
// conventions.
//
// Parameters:
//   - item: The data structure to serialize (must be JSON-serializable)
//
// Returns a map with camelCase keys and any error encountered during JSON
// marshaling or unmarshaling.
//
// Example:
//
//        input := struct{ FirstName string }{FirstName: "John"}
//        result, err := SerializeJSONCamel(input)
//        if err != nil {
//            log.Fatal(err)
//        }
//        // result: map[string]interface{}{"firstName": "John"}
func SerializeJSONCamel(item interface{}) (map[string]interface{}, error) <span class="cov4" title="4">{
        resultBytes, err := json.Marshal(item)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov3" title="3">var result map[string]interface{}
        err = json.Unmarshal(resultBytes, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="3">return ConvertToCamelCase(result, nil).(map[string]interface{}), nil</span>
}

// DeserializeJSONSnakeSchema takes an io.ReadCloser response and deserializes it into a map with snake_case keys.
//
// DeserializeJSONSnakeSchema reads JSON data from the provided io.ReadCloser, parses it,
// and converts all keys from the original format to snake_case using schema-aware
// conversion. The schema parameter allows for more intelligent key conversion by
// considering struct field types and tags, which helps preserve certain fields
// (like maps with string keys) that should not be converted.
//
// Parameters:
//   - response: The io.ReadCloser containing JSON data to deserialize
//   - schema: Pointer to reflect.Type for schema-aware conversion (can be nil)
//
// Returns the deserialized data with snake_case keys and any error encountered
// during JSON decoding.
//
// Example:
//
//        var schemaType reflect.Type = reflect.TypeOf(MyStruct{})
//        data, err := DeserializeJSONSnakeSchema(httpResponse.Body, &amp;schemaType)
//        if err != nil {
//            log.Fatal(err)
//        }
//        // data contains the JSON with schema-aware snake_case keys
func DeserializeJSONSnakeSchema(response io.ReadCloser, schema *reflect.Type) (interface{}, error) <span class="cov2" title="2">{
        var result interface{}
        err := json.NewDecoder(response).Decode(&amp;result)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return ConvertToSnakeCase(result, schema).(interface{}), nil</span>
}

// SerializeJSONCamelSchema takes an interface and serializes it into a map with camelCase keys.
//
// SerializeJSONCamelSchema converts the provided data structure to JSON, then parses it
// back into a map with all keys converted to camelCase format using schema-aware
// conversion. The schema parameter allows for more intelligent key conversion by
// considering struct field types and tags, which helps preserve certain fields
// (like maps with string keys) that should not be converted.
//
// Parameters:
//   - item: The data structure to serialize (must be JSON-serializable)
//   - schema: Pointer to reflect.Type for schema-aware conversion (can be nil)
//
// Returns a map with camelCase keys and any error encountered during JSON
// marshaling or unmarshaling.
//
// Example:
//
//        var schemaType reflect.Type = reflect.TypeOf(MyStruct{})
//        input := struct{ FirstName string }{FirstName: "John"}
//        result, err := SerializeJSONCamelSchema(input, &amp;schemaType)
//        if err != nil {
//            log.Fatal(err)
//        }
//        // result: map[string]interface{}{"firstName": "John"}
func SerializeJSONCamelSchema(item interface{}, schema *reflect.Type) (map[string]interface{}, error) <span class="cov2" title="2">{
        resultBytes, err := json.Marshal(item)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var result map[string]interface{}
        err = json.Unmarshal(resultBytes, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return ConvertToCamelCase(result, schema).(map[string]interface{}), nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package common provides shared utilities and types for the ARK SDK.
//
// This package handles configuration for colored output, interactive mode, certificate
// verification, output control, logging levels, and trusted certificates. It provides
// a centralized way to control various system behaviors through global state and
// environment variables.
package common

import (
        "os"
)

var (
        noColor                   = false
        isInteractive             = true
        isCertificateVerification = true
        isAllowingOutput          = false
        trustedCert               = ""
)

// ArkDisableCertificateVerificationEnvVar is the environment variable name for disabling certificate validation.
//
// When this environment variable is set to any non-empty value, certificate verification
// will be disabled regardless of the internal isCertificateVerification setting.
const (
        ArkDisableCertificateVerificationEnvVar = "ARK_DISABLE_CERTIFICATE_VERIFICATION"
)

// DisableColor disables colored output in the console.
//
// DisableColor sets the global noColor flag to true, which will cause IsColoring()
// to return false. This affects all subsequent console output that checks for
// color support throughout the application.
//
// Example:
//
//        DisableColor()
//        if IsColoring() {
//            // This block will not execute
//        }
func DisableColor() <span class="cov7" title="6">{
        noColor = true
}</span>

// EnableColor enables colored output in the console.
//
// EnableColor sets the global noColor flag to false, which will cause IsColoring()
// to return true. This enables colored console output throughout the application.
//
// Example:
//
//        EnableColor()
//        if IsColoring() {
//            // This block will execute, allowing colored output
//        }
func EnableColor() <span class="cov8" title="8">{
        noColor = false
}</span>

// IsColoring checks if colored output is enabled.
//
// IsColoring returns true when colored output is enabled (noColor is false) and
// false when colored output is disabled. This function is used throughout the
// application to determine whether to apply color formatting to console output.
//
// Returns true if colored output is enabled, false otherwise.
//
// Example:
//
//        if IsColoring() {
//            fmt.Print("\033[31mRed text\033[0m")
//        } else {
//            fmt.Print("Plain text")
//        }
func IsColoring() bool <span class="cov9" title="10">{
        return !noColor
}</span>

// EnableInteractive enables interactive mode.
//
// EnableInteractive sets the global isInteractive flag to true, allowing the
// application to prompt for user input and display interactive elements.
//
// Example:
//
//        EnableInteractive()
//        if IsInteractive() {
//            // Show interactive prompts
//        }
func EnableInteractive() <span class="cov7" title="7">{
        isInteractive = true
}</span>

// DisableInteractive disables interactive mode.
//
// DisableInteractive sets the global isInteractive flag to false, preventing
// the application from displaying interactive prompts or requiring user input.
// This is useful for automated scripts or CI/CD environments.
//
// Example:
//
//        DisableInteractive()
//        if IsInteractive() {
//            // This block will not execute
//        }
func DisableInteractive() <span class="cov7" title="7">{
        isInteractive = false
}</span>

// IsInteractive checks if interactive mode is enabled.
//
// IsInteractive returns true when the application is allowed to display
// interactive prompts and request user input, and false when running in
// non-interactive mode (suitable for automation).
//
// Returns true if interactive mode is enabled, false otherwise.
//
// Example:
//
//        if IsInteractive() {
//            response := promptUser("Continue? (y/n): ")
//        }
func IsInteractive() bool <span class="cov9" title="10">{
        return isInteractive
}</span>

// AllowOutput allows output to be displayed.
//
// AllowOutput sets the global isAllowingOutput flag to true, enabling the
// application to display output messages, logs, and other information to
// the console or other output destinations.
//
// Example:
//
//        AllowOutput()
//        if IsAllowingOutput() {
//            fmt.Println("This message will be displayed")
//        }
func AllowOutput() <span class="cov7" title="6">{
        isAllowingOutput = true
}</span>

// DisallowOutput disallows output to be displayed.
//
// DisallowOutput sets the global isAllowingOutput flag to false, preventing
// the application from displaying output. This is useful for silent operation
// modes or when output needs to be suppressed.
//
// Example:
//
//        DisallowOutput()
//        if IsAllowingOutput() {
//            // This block will not execute
//        }
func DisallowOutput() <span class="cov8" title="8">{
        isAllowingOutput = false
}</span>

// IsAllowingOutput checks if output is allowed to be displayed.
//
// IsAllowingOutput returns true when the application is permitted to display
// output messages and false when output should be suppressed.
//
// Returns true if output is allowed, false otherwise.
//
// Example:
//
//        if IsAllowingOutput() {
//            logger.Info("Operation completed successfully")
//        }
func IsAllowingOutput() bool <span class="cov9" title="10">{
        return isAllowingOutput
}</span>

// EnableVerboseLogging enables verbose logging with the specified log level.
//
// EnableVerboseLogging sets the LogLevel environment variable to the provided
// log level string. If an empty string is provided, it defaults to "DEBUG".
// This affects the logging verbosity throughout the application.
//
// Parameters:
//   - logLevel: The desired log level string (defaults to "DEBUG" if empty)
//
// Example:
//
//        EnableVerboseLogging("INFO")
//        EnableVerboseLogging("") // Uses "DEBUG" as default
func EnableVerboseLogging(logLevel string) <span class="cov6" title="5">{
        if logLevel == "" </span><span class="cov1" title="1">{
                logLevel = "DEBUG"
        }</span>
        <span class="cov6" title="5">_ = os.Setenv(LogLevel, logLevel)</span>
}

// DisableVerboseLogging disables verbose logging.
//
// DisableVerboseLogging sets the LogLevel environment variable to "CRITICAL",
// effectively reducing the logging output to only critical messages.
//
// Example:
//
//        DisableVerboseLogging()
//        // Only critical log messages will be displayed
func DisableVerboseLogging() <span class="cov3" title="2">{
        _ = os.Setenv(LogLevel, "CRITICAL")
}</span>

// SetLoggerStyle sets the logger style based on the provided string.
//
// SetLoggerStyle configures the LoggerStyle environment variable. If the
// provided style is "default", it sets the style to "default"; otherwise,
// it defaults to "default" regardless of the input value.
//
// Parameters:
//   - loggerStyle: The desired logger style ("default" or any other value defaults to "default")
//
// Example:
//
//        SetLoggerStyle("default")
//        SetLoggerStyle("custom") // Also sets to "default"
func SetLoggerStyle(loggerStyle string) <span class="cov4" title="3">{
        if loggerStyle == "default" </span><span class="cov1" title="1">{
                _ = os.Setenv(LoggerStyle, loggerStyle)
        }</span> else<span class="cov3" title="2"> {
                _ = os.Setenv(LoggerStyle, "default")
        }</span>
}

// EnableCertificateVerification enables certificate verification.
//
// EnableCertificateVerification sets the global isCertificateVerification flag
// to true, enabling SSL/TLS certificate validation for network connections.
// Note that if the ArkDisableCertificateVerificationEnvVar environment variable
// is set, certificate verification will still be disabled.
//
// Example:
//
//        EnableCertificateVerification()
//        if IsVerifyingCertificates() {
//            // Certificates will be verified
//        }
func EnableCertificateVerification() <span class="cov8" title="8">{
        isCertificateVerification = true
}</span>

// DisableCertificateVerification disables certificate verification.
//
// DisableCertificateVerification sets the global isCertificateVerification flag
// to false, disabling SSL/TLS certificate validation for network connections.
// This should be used with caution as it reduces security.
//
// Example:
//
//        DisableCertificateVerification()
//        if IsVerifyingCertificates() {
//            // This block will not execute
//        }
func DisableCertificateVerification() <span class="cov7" title="6">{
        isCertificateVerification = false
}</span>

// IsVerifyingCertificates checks if certificate verification is enabled.
//
// IsVerifyingCertificates returns false if the ArkDisableCertificateVerificationEnvVar
// environment variable is set to any non-empty value, regardless of the internal
// isCertificateVerification setting. Otherwise, it returns the value of the
// isCertificateVerification flag.
//
// Returns true if certificate verification is enabled, false otherwise.
//
// Example:
//
//        if IsVerifyingCertificates() {
//            // Use secure connection with certificate validation
//        } else {
//            // Use connection without certificate validation
//        }
func IsVerifyingCertificates() bool <span class="cov7" title="7">{
        if os.Getenv(ArkDisableCertificateVerificationEnvVar) != "" </span><span class="cov4" title="3">{
                return false
        }</span>
        <span class="cov5" title="4">return isCertificateVerification</span>
}

// SetTrustedCertificate sets the trusted certificate for verification.
//
// SetTrustedCertificate stores the provided certificate string in the global
// trustedCert variable. This certificate can be used for custom certificate
// validation scenarios.
//
// Parameters:
//   - cert: The certificate string to be stored as trusted
//
// Example:
//
//        cert := "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
//        SetTrustedCertificate(cert)
func SetTrustedCertificate(cert string) <span class="cov10" title="13">{
        trustedCert = cert
}</span>

// TrustedCertificate returns the trusted certificate for verification.
//
// TrustedCertificate retrieves the currently stored trusted certificate string
// that was previously set using SetTrustedCertificate. Returns an empty string
// if no certificate has been set.
//
// Returns the trusted certificate string, or empty string if none is set.
//
// Example:
//
//        cert := TrustedCertificate()
//        if cert != "" {
//            // Use the trusted certificate for validation
//        }
func TrustedCertificate() string <span class="cov8" title="9">{
        return trustedCert
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package common provides shared utilities and types for the ARK SDK.
//
// This package handles user agent string generation for HTTP requests made by the
// ARK SDK, combining browser user agent strings with SDK version information to
// provide proper identification in network communications.
package common

import (
        "fmt"

        browser "github.com/EDDYCJY/fake-useragent"
)

// UserAgent returns the user agent string for the Ark SDK in Golang.
//
// UserAgent generates a composite user agent string by combining a Chrome browser
// user agent (obtained from the fake-useragent library) with the current ARK SDK
// version. This provides proper identification for HTTP requests made by the SDK
// while maintaining compatibility with web services that expect browser-like
// user agents.
//
// Returns a formatted user agent string in the format:
// "{Chrome User Agent} Ark-SDK-Golang/{version}"
//
// Example:
//
//        userAgent := UserAgent()
//        // userAgent might be:
//        // "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Ark-SDK-Golang/1.2.3"
func UserAgent() string <span class="cov10" title="15">{
        return browser.Chrome() + fmt.Sprintf(" Ark-SDK-Golang/%s", ArkVersion())
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package common provides shared utilities and types for the ARK SDK.
//
// This package handles version information storage and retrieval for the ARK SDK,
// providing a centralized way to manage and access the current SDK version throughout
// the application lifecycle.
package common

var arkVersion = "0.0.0"

// SetArkVersion sets the version of the Ark SDK.
//
// SetArkVersion updates the global arkVersion variable with the provided version
// string. If an empty string is provided, the version remains unchanged. This
// function is typically called during application initialization to set the
// correct SDK version.
//
// Parameters:
//   - version: The version string to set (empty string is ignored)
//
// Example:
//
//        SetArkVersion("1.2.3")
//        fmt.Println(ArkVersion()) // Outputs: 1.2.3
//
//        SetArkVersion("") // No change
//        fmt.Println(ArkVersion()) // Still outputs: 1.2.3
func SetArkVersion(version string) <span class="cov10" title="78">{
        if version != "" </span><span class="cov9" title="67">{
                arkVersion = version
        }</span>
}

// ArkVersion returns the current version of the Ark SDK.
//
// ArkVersion retrieves the currently stored SDK version string. The default
// version is "0.0.0" if no version has been explicitly set using SetArkVersion.
//
// Returns the current SDK version string.
//
// Example:
//
//        version := ArkVersion()
//        fmt.Printf("Current SDK version: %s\n", version)
func ArkVersion() string <span class="cov9" title="56">{
        return arkVersion
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package ssh provides Secure Shell (SSH) connection capabilities
// for the ARK SDK Golang. This package implements the ArkConnection interface
// to enable secure command execution on Linux/Unix machines using the SSH protocol.
//
// The package supports multiple authentication methods including password
// authentication and public key authentication (both from file and from content).
// It includes automatic retry mechanisms for connection failures and provides
// session management for command execution.
//
// Key features:
//   - Secure SSH connections with multiple authentication methods
//   - Password-based authentication
//   - Public key authentication (file-based and content-based)
//   - Automatic retry with connection failure detection
//   - Session-based command execution
//   - Connection suspend/restore functionality
//
// Example:
//
//        conn := NewArkSSHConnection()
//        err := conn.Connect(&amp;connectionsmodels.ArkConnectionDetails{
//                Address: "linux-server.example.com",
//                Port:    22,
//                Credentials: &amp;connectionsmodels.ArkConnectionCredentials{
//                        User:     "username",
//                        Password: "password",
//                },
//        })
//        if err != nil {
//                // handle error
//        }
//        defer conn.Disconnect()
//
//        result, err := conn.RunCommand(&amp;connectionsmodels.ArkConnectionCommand{
//                Command:    "ls -la",
//                ExpectedRC: 0,
//        })
package ssh

import (
        "bytes"
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/common/connections"
        connectionsmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common/connections"
        "golang.org/x/crypto/ssh"
)

const (
        // SSHPort is the default port for SSH connections.
        SSHPort = 22
)

const (
        // connectionTimeout defines the maximum time to wait for SSH connection establishment.
        connectionTimeout = 10 * time.Second
)

// ArkSSHConnection is a struct that implements the ArkConnection interface for SSH connections.
//
// It provides secure Secure Shell functionality including connection management,
// command execution with session handling, and automatic retry mechanisms.
// The connection supports multiple authentication methods including password
// and public key authentication.
//
// The struct maintains connection state and provides suspend/restore functionality
// for connection lifecycle management.
type ArkSSHConnection struct {
        connections.ArkConnection
        isConnected bool
        isSuspended bool
        sshClient   *ssh.Client
        logger      *common.ArkLogger
}

// NewArkSSHConnection creates a new instance of ArkSSHConnection.
//
// Creates and initializes a new SSH connection instance with default settings.
// The connection is created in a disconnected state and must be explicitly
// connected using the Connect method before use.
//
// Returns a pointer to the newly created ArkSSHConnection instance with
// isConnected and isSuspended set to false, and a logger configured for
// SSH operations.
//
// Example:
//
//        conn := NewArkSSHConnection()
//        err := conn.Connect(connectionDetails)
//        if err != nil {
//                // handle connection error
//        }
func NewArkSSHConnection() *ArkSSHConnection <span class="cov10" title="19">{
        return &amp;ArkSSHConnection{
                isConnected: false,
                isSuspended: false,
                logger:      common.GetLogger("ArkSSHConnection", common.Unknown),
        }
}</span>

// Connect establishes an SSH connection using the provided connection details.
//
// Establishes a secure SSH connection to the target machine using the provided
// connection details. The method supports multiple authentication methods including
// password authentication and public key authentication (both from file and
// content). It handles automatic retry logic for connection failures.
//
// If the connection is already established, this method returns immediately
// without error. The method uses the default SSH port (22) if no port is
// specified in the connection details.
//
// The method supports three authentication methods in order of precedence:
// 1. Password authentication (if password is provided)
// 2. Private key file authentication (if PrivateKeyFilepath is provided)
// 3. Private key content authentication (if PrivateKeyContents is provided)
//
// Parameters:
//   - connectionDetails: Connection configuration including address, port,
//     credentials, retry settings, and authentication information
//
// Returns an error if the connection cannot be established, including cases
// where credentials are missing, private key files cannot be read or parsed,
// or the SSH connection fails.
//
// The method supports automatic retry with configurable retry count and
// tick period. Connection failures are detected and retried up to the
// specified limit.
//
// Example:
//
//        details := &amp;connectionsmodels.ArkConnectionDetails{
//                Address: "linux-server.example.com",
//                Port:    22,
//                Credentials: &amp;connectionsmodels.ArkConnectionCredentials{
//                        User:     "username",
//                        Password: "password",
//                },
//                ConnectionRetries: 3,
//                RetryTickPeriod:   5,
//        }
//        err := conn.Connect(details)
func (c *ArkSSHConnection) Connect(connectionDetails *connectionsmodels.ArkConnectionDetails) error <span class="cov6" title="6">{
        if c.isConnected </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="5">if connectionDetails.ConnectionRetries == 0 </span><span class="cov5" title="4">{
                connectionDetails.ConnectionRetries = 1
        }</span>

        <span class="cov5" title="5">var authMethods []ssh.AuthMethod
        if connectionDetails.Credentials != nil </span><span class="cov5" title="5">{
                if connectionDetails.Credentials.Password != "" </span><span class="cov3" title="2">{
                        authMethods = append(authMethods, ssh.Password(connectionDetails.Credentials.Password))
                }</span> else<span class="cov4" title="3"> if connectionDetails.Credentials.PrivateKeyFilepath != "" </span><span class="cov3" title="2">{
                        _, err := os.Stat(connectionDetails.Credentials.PrivateKeyFilepath)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to check private key file exists: %w", err)
                        }</span>
                        <span class="cov1" title="1">keyData, err := os.ReadFile(connectionDetails.Credentials.PrivateKeyFilepath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read private key file: %w", err)
                        }</span>
                        <span class="cov1" title="1">signer, err := ssh.ParsePrivateKey(keyData)
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to parse private key: %w", err)
                        }</span>
                        <span class="cov0" title="0">authMethods = append(authMethods, ssh.PublicKeys(signer))</span>
                } else<span class="cov1" title="1"> if connectionDetails.Credentials.PrivateKeyContents != "" </span><span class="cov1" title="1">{
                        signer, err := ssh.ParsePrivateKey([]byte(connectionDetails.Credentials.PrivateKeyContents))
                        if err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to parse private key contents: %w", err)
                        }</span>
                        <span class="cov0" title="0">authMethods = append(authMethods, ssh.PublicKeys(signer))</span>
                }
        }

        <span class="cov3" title="2">config := &amp;ssh.ClientConfig{
                User:            connectionDetails.Credentials.User,
                Auth:            authMethods,
                HostKeyCallback: ssh.InsecureIgnoreHostKey(),
                Timeout:         connectionTimeout,
        }

        address := fmt.Sprintf("%s:%d", connectionDetails.Address, connectionDetails.Port)
        var client *ssh.Client
        var err error
        for i := 0; i &lt; connectionDetails.ConnectionRetries; i++ </span><span class="cov3" title="2">{
                client, err = ssh.Dial("tcp", address, config)
                if err != nil </span><span class="cov3" title="2">{
                        if common.IsConnectionRefused(err) </span><span class="cov0" title="0">{
                                if i &lt; connectionDetails.ConnectionRetries-1 </span><span class="cov0" title="0">{
                                        time.Sleep(time.Duration(connectionDetails.RetryTickPeriod) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov3" title="2">return fmt.Errorf("failed to connect to SSH server: %w", err)</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">c.logger.Debug("Connected to SSH server [%s] on port [%d]", connectionDetails.Address, connectionDetails.Port)
        c.sshClient = client
        c.isConnected = true
        c.isSuspended = false
        return nil</span>
}

// Disconnect closes the SSH connection.
//
// Closes the active SSH client connection and cleans up the connection resources.
// If the connection is not currently established, this method returns
// immediately without error.
//
// The method attempts to close the SSH client gracefully. If the client
// closure fails, a warning is logged but the method continues to clean
// up the connection state.
//
// After successful completion, the connection state is reset to disconnected
// and not suspended.
//
// Returns an error only in exceptional circumstances. Client closure errors
// are logged as warnings but do not cause the method to fail.
//
// Example:
//
//        err := conn.Disconnect()
//        if err != nil {
//                // handle disconnect error (rare)
//        }
func (c *ArkSSHConnection) Disconnect() error <span class="cov1" title="1">{
        if !c.isConnected </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">err := c.sshClient.Close()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warning("Failed to close SSH client: %s", err.Error())
        }</span>
        <span class="cov0" title="0">c.sshClient = nil
        c.isConnected = false
        c.isSuspended = false
        return nil</span>
}

// SuspendConnection suspends the SSH connection.
//
// Marks the connection as suspended without actually closing the underlying
// SSH connection. When suspended, the connection will refuse to execute
// commands until it is restored using RestoreConnection.
//
// This is useful for temporarily disabling command execution while keeping
// the underlying network connection alive.
//
// Returns nil as this operation always succeeds.
//
// Example:
//
//        err := conn.SuspendConnection()
//        // Commands will now fail until RestoreConnection is called
func (c *ArkSSHConnection) SuspendConnection() error <span class="cov3" title="2">{
        c.isSuspended = true
        return nil
}</span>

// RestoreConnection restores the SSH connection.
//
// Restores a previously suspended connection, allowing command execution
// to resume. This method clears the suspended state without affecting
// the underlying SSH connection.
//
// Returns nil as this operation always succeeds.
//
// Example:
//
//        err := conn.RestoreConnection()
//        // Commands can now be executed again
func (c *ArkSSHConnection) RestoreConnection() error <span class="cov3" title="2">{
        c.isSuspended = false
        return nil
}</span>

// IsSuspended checks if the SSH connection is suspended.
//
// Returns the current suspension state of the connection. When suspended,
// the connection will refuse to execute commands even if the underlying
// SSH connection is still active.
//
// Returns true if the connection is currently suspended, false otherwise.
//
// Example:
//
//        if conn.IsSuspended() {
//                // Connection is suspended, restore before running commands
//                conn.RestoreConnection()
//        }
func (c *ArkSSHConnection) IsSuspended() bool <span class="cov3" title="2">{
        return c.isSuspended
}</span>

// IsConnected checks if the SSH connection is established.
//
// Returns the current connection state indicating whether an SSH connection
// has been successfully established and is ready for use. This does not
// check the network connectivity, only the internal connection state.
//
// Returns true if the connection is established, false otherwise.
//
// Example:
//
//        if !conn.IsConnected() {
//                err := conn.Connect(connectionDetails)
//                if err != nil {
//                        // handle connection error
//                }
//        }
func (c *ArkSSHConnection) IsConnected() bool <span class="cov3" title="2">{
        return c.isConnected
}</span>

// RunCommand executes a command on the connected system.
//
// Executes the specified command on the remote machine through the established
// SSH connection. The method creates a new SSH session for each command execution,
// captures stdout and stderr output, and handles exit status detection.
//
// The method validates that the connection is active and not suspended before
// execution. Commands that return a different exit code than expected will
// result in an error.
//
// Session management is handled automatically - a new session is created for
// each command execution and cleaned up afterward. The method properly handles
// SSH exit errors to extract the actual exit status from the remote command.
//
// Parameters:
//   - command: The command configuration including the command string and
//     expected return code for validation
//
// Returns the command execution result containing stdout, stderr, and return
// code, or an error if the command cannot be executed, the session cannot be
// created, or the command returns an unexpected return code.
//
// Example:
//
//        cmd := &amp;connectionsmodels.ArkConnectionCommand{
//                Command:    "ls -la /home",
//                ExpectedRC: 0,
//        }
//        result, err := conn.RunCommand(cmd)
//        if err != nil {
//                // handle execution error
//        }
//        fmt.Printf("Output: %s\n", result.Stdout)
func (c *ArkSSHConnection) RunCommand(command *connectionsmodels.ArkConnectionCommand) (*connectionsmodels.ArkConnectionResult, error) <span class="cov4" title="3">{
        if !c.isConnected || c.isSuspended </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("cannot run command while not being connected")
        }</span>
        <span class="cov0" title="0">c.logger.Debug("Running command [%s]", command.Command)
        session, err := c.sshClient.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create SSH session: %w", err)
        }</span>
        <span class="cov0" title="0">var stdoutBuf, stderrBuf bytes.Buffer
        session.Stdout = &amp;stdoutBuf
        session.Stderr = &amp;stderrBuf
        err = session.Run(command.Command)
        rc := 0
        if err != nil </span><span class="cov0" title="0">{
                var exitErr *ssh.ExitError
                if errors.As(err, &amp;exitErr) </span><span class="cov0" title="0">{
                        rc = exitErr.ExitStatus()
                }</span>
        }

        <span class="cov0" title="0">stdout := stdoutBuf.String()
        stderr := stderrBuf.String()

        if rc != command.ExpectedRC </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute command [%s] - [%d] - [%s]", command.Command, rc, stderr)
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Command rc: [%d]", rc)
        c.logger.Debug("Command stdout: [%s]", stdout)
        c.logger.Debug("Command stderr: [%s]", stderr)

        return &amp;connectionsmodels.ArkConnectionResult{
                Stdout: stdout,
                Stderr: stderr,
                RC:     rc,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package winrm provides Windows Remote Management (WinRM) connection capabilities
// for the ARK SDK Golang. This package implements the ArkConnection interface
// to enable secure command execution on Windows machines using the WinRM protocol.
//
// The package supports HTTPS connections with optional certificate validation,
// automatic retry mechanisms, and handles large command execution through
// file-based chunking when commands exceed size limits.
//
// Key features:
//   - Secure WinRM HTTPS connections
//   - Automatic retry with connection failure detection
//   - Large command handling with UTF-16 encoding
//   - PowerShell script execution
//   - Connection suspend/restore functionality
//
// Example:
//
//        conn := NewArkWinRMConnection()
//        err := conn.Connect(&amp;connectionsmodels.ArkConnectionDetails{
//                Address: "windows-server.example.com",
//                Port:    5986,
//                Credentials: &amp;connectionsmodels.ArkConnectionCredentials{
//                        User:     "administrator",
//                        Password: "password",
//                },
//        })
//        if err != nil {
//                // handle error
//        }
//        defer conn.Disconnect()
//
//        result, err := conn.RunCommand(&amp;connectionsmodels.ArkConnectionCommand{
//                Command:    "Get-Process",
//                ExpectedRC: 0,
//        })
package winrm

import (
        "bytes"
        "context"
        "encoding/base64"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/cyberark/ark-sdk-golang/pkg/common"
        "github.com/cyberark/ark-sdk-golang/pkg/common/connections"
        connectionsmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common/connections"
        "github.com/cyberark/ark-sdk-golang/pkg/models/common/connections/connectiondata"
        "github.com/google/uuid"
        "github.com/masterzen/winrm"
        "golang.org/x/text/encoding/unicode"
)

const (
        // WinRMHTTPSPort is the default port for WinRM HTTPS connections.
        WinRMHTTPSPort = 5986
)

const (
        // winrmConnectionTimeout defines the maximum time to wait for WinRM connection establishment.
        winrmConnectionTimeout = 10 * time.Second

        // maxSingleCommandSize defines the maximum size in bytes for a single WinRM command
        // before it needs to be split into chunks and executed via a temporary file.
        maxSingleCommandSize = 2000

        // maxChunkSize defines the maximum size in bytes for each chunk when splitting
        // large commands for file-based execution.
        maxChunkSize = 4000
)

// ArkWinRMConnection is a struct that implements the ArkConnection interface for WinRM connections.
//
// It provides secure Windows Remote Management functionality including connection management,
// command execution, and automatic retry mechanisms. The connection supports both simple
// commands and large command execution through temporary file creation when commands
// exceed the maximum size limit.
//
// The struct maintains connection state and provides suspend/restore functionality
// for connection lifecycle management.
type ArkWinRMConnection struct {
        connections.ArkConnection
        isConnected bool
        isSuspended bool
        winrmClient *winrm.Client
        winrmShell  *winrm.Shell
        logger      *common.ArkLogger
}

// NewArkWinRMConnection creates a new instance of ArkWinRMConnection.
//
// Creates and initializes a new WinRM connection instance with default settings.
// The connection is created in a disconnected state and must be explicitly
// connected using the Connect method before use.
//
// Returns a pointer to the newly created ArkWinRMConnection instance with
// isConnected and isSuspended set to false, and a logger configured for
// WinRM operations.
//
// Example:
//
//        conn := NewArkWinRMConnection()
//        err := conn.Connect(connectionDetails)
//        if err != nil {
//                // handle connection error
//        }
func NewArkWinRMConnection() *ArkWinRMConnection <span class="cov10" title="16">{
        return &amp;ArkWinRMConnection{
                isConnected: false,
                isSuspended: false,
                logger:      common.GetLogger("ArkWinRMConnection", common.Unknown),
        }
}</span>

// Connect establishes a WinRM connection using the provided connection details.
//
// Establishes a secure WinRM HTTPS connection to the target Windows machine
// using the provided connection details. The method handles certificate
// validation, retry logic, and creates both the WinRM client and shell
// required for command execution.
//
// If the connection is already established, this method returns immediately
// without error. The method uses the default HTTPS port (5986) if no port
// is specified in the connection details.
//
// Parameters:
//   - connectionDetails: Connection configuration including address, port,
//     credentials, retry settings, and optional certificate settings
//
// Returns an error if the connection cannot be established, including cases
// where credentials are missing, certificate files cannot be read, or the
// WinRM client/shell creation fails.
//
// The method supports automatic retry with configurable retry count and
// tick period. Connection failures are detected and retried up to the
// specified limit.
//
// Example:
//
//        details := &amp;connectionsmodels.ArkConnectionDetails{
//                Address: "windows-server.example.com",
//                Port:    5986,
//                Credentials: &amp;connectionsmodels.ArkConnectionCredentials{
//                        User:     "administrator",
//                        Password: "password",
//                },
//                ConnectionRetries: 3,
//                RetryTickPeriod:   5,
//        }
//        err := conn.Connect(details)
//        if err != nil {
//                // handle connection error
//        }
func (c *ArkWinRMConnection) Connect(connectionDetails *connectionsmodels.ArkConnectionDetails) error <span class="cov5" title="4">{
        if c.isConnected </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov4" title="3">targetPort := WinRMHTTPSPort
        if connectionDetails.Port != 0 </span><span class="cov4" title="3">{
                targetPort = connectionDetails.Port
        }</span>
        <span class="cov4" title="3">if connectionDetails.ConnectionRetries == 0 </span><span class="cov4" title="3">{
                connectionDetails.ConnectionRetries = 1
        }</span>
        <span class="cov4" title="3">var err error
        var certData []byte
        certPath := ""
        trustCert := false
        if winrmData, ok := connectionDetails.ConnectionData.(*connectiondata.ArkWinRMConnectionData); ok </span><span class="cov3" title="2">{
                certPath = winrmData.CertificatePath
                trustCert = winrmData.TrustCertificate
        }</span>
        <span class="cov4" title="3">if certPath != "" </span><span class="cov3" title="2">{
                certData, err = os.ReadFile(certPath)
                if err != nil </span><span class="cov3" title="2">{
                        return fmt.Errorf("failed to read certificate file: %w", err)
                }</span>
        }

        <span class="cov1" title="1">c.logger.Debug("Connecting to WinRM server [%s] on port [%d]", connectionDetails.Address, targetPort)
        endpoint := winrm.NewEndpoint(
                connectionDetails.Address,
                targetPort,
                true,
                trustCert,
                certData,
                nil,
                nil,
                winrmConnectionTimeout,
        )
        if connectionDetails.Credentials == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("missing credentials for WinRM connection")
        }</span>

        <span class="cov0" title="0">var client *winrm.Client
        var shell *winrm.Shell
        for i := 0; i &lt; connectionDetails.ConnectionRetries; i++ </span><span class="cov0" title="0">{
                params := winrm.DefaultParameters
                params.TransportDecorator = func() winrm.Transporter </span><span class="cov0" title="0">{ return &amp;winrm.ClientNTLM{} }</span>
                <span class="cov0" title="0">client, err = winrm.NewClientWithParameters(endpoint, connectionDetails.Credentials.User, connectionDetails.Credentials.Password, params)
                if err != nil </span><span class="cov0" title="0">{
                        if common.IsConnectionRefused(err) &amp;&amp; i &lt; connectionDetails.ConnectionRetries-1 </span><span class="cov0" title="0">{
                                c.logger.Info("Failed to create WinRM client: %s - Retrying...", err.Error())
                                time.Sleep(time.Duration(connectionDetails.RetryTickPeriod) * time.Second)
                                continue</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("failed to create WinRM client: %w", err)</span>
                }
                <span class="cov0" title="0">shell, err = client.CreateShell()
                if err != nil </span><span class="cov0" title="0">{
                        if common.IsConnectionRefused(err) &amp;&amp; i &lt; connectionDetails.ConnectionRetries-1 </span><span class="cov0" title="0">{
                                c.logger.Info("Failed to create WinRM shell: %s - Retrying...", err.Error())
                                time.Sleep(time.Duration(connectionDetails.RetryTickPeriod) * time.Second)
                                continue</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("failed to create WinRM shell: %w", err)</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">c.logger.Debug("WinRM client and shell created successfully for [%s]", connectionDetails.Address)
        c.winrmClient = client
        c.winrmShell = shell
        c.isConnected = true
        c.isSuspended = false
        return nil</span>
}

// Disconnect closes the WinRM connection.
//
// Closes the active WinRM shell and cleans up the connection resources.
// If the connection is not currently established, this method returns
// immediately without error.
//
// The method attempts to close the WinRM shell gracefully. If the shell
// closure fails, a warning is logged but the method continues to clean
// up the connection state.
//
// After successful completion, the connection state is reset to disconnected
// and not suspended.
//
// Returns an error only in exceptional circumstances. Shell closure errors
// are logged as warnings but do not cause the method to fail.
//
// Example:
//
//        err := conn.Disconnect()
//        if err != nil {
//                // handle disconnect error (rare)
//        }
func (c *ArkWinRMConnection) Disconnect() error <span class="cov1" title="1">{
        if !c.isConnected </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">err := c.winrmShell.Close()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warning("failed to close WinRM shell: %s", err.Error())
        }</span>
        <span class="cov0" title="0">c.winrmShell = nil
        c.winrmClient = nil
        c.isConnected = false
        c.isSuspended = false
        return nil</span>
}

// SuspendConnection suspends the WinRM connection.
//
// Marks the connection as suspended without actually closing the underlying
// WinRM connection. When suspended, the connection will refuse to execute
// commands until it is restored using RestoreConnection.
//
// This is useful for temporarily disabling command execution while keeping
// the underlying network connection alive.
//
// Returns nil as this operation always succeeds.
//
// Example:
//
//        err := conn.SuspendConnection()
//        // Commands will now fail until RestoreConnection is called
func (c *ArkWinRMConnection) SuspendConnection() error <span class="cov3" title="2">{
        c.isSuspended = true
        return nil
}</span>

// RestoreConnection restores the WinRM connection.
//
// Restores a previously suspended connection, allowing command execution
// to resume. This method clears the suspended state without affecting
// the underlying WinRM connection.
//
// Returns nil as this operation always succeeds.
//
// Example:
//
//        err := conn.RestoreConnection()
//        // Commands can now be executed again
func (c *ArkWinRMConnection) RestoreConnection() error <span class="cov3" title="2">{
        c.isSuspended = false
        return nil
}</span>

// IsSuspended checks if the WinRM connection is suspended.
//
// Returns the current suspension state of the connection. When suspended,
// the connection will refuse to execute commands even if the underlying
// WinRM connection is still active.
//
// Returns true if the connection is currently suspended, false otherwise.
//
// Example:
//
//        if conn.IsSuspended() {
//                // Connection is suspended, restore before running commands
//                conn.RestoreConnection()
//        }
func (c *ArkWinRMConnection) IsSuspended() bool <span class="cov3" title="2">{
        return c.isSuspended
}</span>

// IsConnected checks if the WinRM connection is established.
//
// Returns the current connection state indicating whether a WinRM connection
// has been successfully established and is ready for use. This does not
// check the network connectivity, only the internal connection state.
//
// Returns true if the connection is established, false otherwise.
//
// Example:
//
//        if !conn.IsConnected() {
//                err := conn.Connect(connectionDetails)
//                if err != nil {
//                        // handle connection error
//                }
//        }
func (c *ArkWinRMConnection) IsConnected() bool <span class="cov3" title="2">{
        return c.isConnected
}</span>

// RunCommand executes a command on the remote machine using WinRM.
//
// Executes the specified command on the remote Windows machine through the
// established WinRM connection. The method handles both small and large
// commands automatically, using different execution strategies based on
// command size.
//
// For commands smaller than maxSingleCommandSize (2000 bytes), the command
// is executed directly using PowerShell's encoded command feature with
// UTF-16 encoding. For larger commands, the method splits the command into
// chunks, writes them to a temporary PowerShell script file on the remote
// machine, executes the file, and cleans up afterward.
//
// The method can be forced to use the file-based approach for any command
// by setting ExtraCommandData["force_command_split"] to true.
//
// Parameters:
//   - command: The command configuration including the command string,
//     expected return code, and optional extra data for execution control
//
// Returns the command execution result containing stdout, stderr, and return
// code, or an error if the command cannot be executed or returns an unexpected
// return code.
//
// The method validates that the connection is active and not suspended before
// execution. Commands that return a different exit code than expected will
// result in an error.
//
// Example:
//
//        cmd := &amp;connectionsmodels.ArkConnectionCommand{
//                Command:    "Get-Process | Where-Object {$_.ProcessName -eq 'notepad'}",
//                ExpectedRC: 0,
//        }
//        result, err := conn.RunCommand(cmd)
//        if err != nil {
//                // handle execution error
//        }
//        fmt.Printf("Output: %s\n", result.Stdout)
//
// For large commands:
//
//        cmd := &amp;connectionsmodels.ArkConnectionCommand{
//                Command:    veryLargeScript,
//                ExpectedRC: 0,
//                ExtraCommandData: map[string]interface{}{
//                        "force_command_split": true,
//                },
//        }
//        result, err := conn.RunCommand(cmd)
func (c *ArkWinRMConnection) RunCommand(command *connectionsmodels.ArkConnectionCommand) (*connectionsmodels.ArkConnectionResult, error) <span class="cov3" title="2">{
        if !c.isConnected || c.isSuspended </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("cannot run command while not being connected")
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Running command [%s]", command.Command)

        if len(command.Command) &gt; maxSingleCommandSize || (command.ExtraCommandData != nil &amp;&amp; command.ExtraCommandData["force_command_split"] == true) </span><span class="cov0" title="0">{
                encoder := unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM).NewEncoder()
                utf16EncodedString, err := encoder.String(command.Command)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to encode string: %w", err)
                }</span>
                <span class="cov0" title="0">encodedCommand := []byte(utf16EncodedString)
                maxSize := maxChunkSize
                var chunks [][]byte
                for i := 0; i &lt; len(encodedCommand); i += maxSize </span><span class="cov0" title="0">{
                        end := i + maxSize
                        if end &gt; len(encodedCommand) </span><span class="cov0" title="0">{
                                end = len(encodedCommand)
                        }</span>
                        <span class="cov0" title="0">chunks = append(chunks, encodedCommand[i:end])</span>
                }

                <span class="cov0" title="0">commandUniqueFileName := uuid.New().String()
                commandFile := fmt.Sprintf("C:\\temp\\%s.ps1", commandUniqueFileName)

                // Ensure C:\temp exists
                _, err = c.winrmShell.ExecuteWithContext(context.Background(), "if not exist C:\\temp mkdir C:\\temp")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create temp directory: %w", err)
                }</span>

                // Write chunks to the file
                <span class="cov0" title="0">for _, chunk := range chunks </span><span class="cov0" title="0">{
                        base64utf16EncodedString := base64.StdEncoding.EncodeToString(chunk)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to encode string: %w", err)
                        }</span>
                        <span class="cov0" title="0">_, err = c.winrmShell.ExecuteWithContext(context.Background(), fmt.Sprintf(
                                `powershell -Command "[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('%s')) | Add-Content -Path %s -Encoding Unicode -NoNewline"`,
                                base64utf16EncodedString, commandFile))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to write chunk to file: %w", err)
                        }</span>
                }

                // Execute the PowerShell script
                <span class="cov0" title="0">commandOutput, err := c.winrmShell.ExecuteWithContext(context.Background(), fmt.Sprintf("powershell -File %s", commandFile))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute command: %w", err)
                }</span>

                // Clean up the temporary file
                <span class="cov0" title="0">_, _ = c.winrmShell.ExecuteWithContext(context.Background(), fmt.Sprintf("del /f %s", commandFile))

                stdout := &amp;bytes.Buffer{}
                stderr := &amp;bytes.Buffer{}
                go io.Copy(stdout, commandOutput.Stdout)
                go io.Copy(stderr, commandOutput.Stderr)
                commandOutput.Wait()
                if command.ExpectedRC != commandOutput.ExitCode() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute command [%s] - [%d] - [%s]", command.Command, commandOutput.ExitCode(), stderr.String())
                }</span>

                <span class="cov0" title="0">c.logger.Debug("Command rc: [%d]", commandOutput.ExitCode())
                c.logger.Debug("Command stdout: [%s]", stdout)
                c.logger.Debug("Command stderr: [%s]", stderr)

                return &amp;connectionsmodels.ArkConnectionResult{
                        Stdout: stdout.String(),
                        Stderr: stderr.String(),
                        RC:     commandOutput.ExitCode(),
                }, nil</span>
        }

        <span class="cov0" title="0">encoder := unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM).NewEncoder()
        utf16EncodedString, err := encoder.String(command.Command)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode string: %w", err)
        }</span>
        <span class="cov0" title="0">base64utf16EncodedString := base64.StdEncoding.EncodeToString([]byte(utf16EncodedString))
        encodedCommand := fmt.Sprintf("powershell -encodedcommand \"%s\"", base64utf16EncodedString)
        commandOutput, err := c.winrmShell.ExecuteWithContext(context.Background(), encodedCommand)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute command: %w", err)
        }</span>
        <span class="cov0" title="0">stdout := &amp;bytes.Buffer{}
        stderr := &amp;bytes.Buffer{}
        go io.Copy(stdout, commandOutput.Stdout)
        go io.Copy(stderr, commandOutput.Stderr)
        commandOutput.Wait()
        if command.ExpectedRC != commandOutput.ExitCode() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute command [%s] - [%d] - [%s]", command.Command, commandOutput.ExitCode(), stderr.String())
        }</span>

        <span class="cov0" title="0">c.logger.Debug("Command rc: [%d]", commandOutput.ExitCode())
        c.logger.Debug("Command stdout: [%s]", stdout)
        c.logger.Debug("Command stderr: [%s]", stderr)

        return &amp;connectionsmodels.ArkConnectionResult{
                Stdout: stdout.String(),
                Stderr: stderr.String(),
                RC:     commandOutput.ExitCode(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package isp provides ISP (Identity Service Provider) client functionality for the ARK SDK.
//
// This package contains the ArkISPServiceClient which handles authentication and service
// URL resolution for ISP-based services. It provides functionality to create clients,
// resolve service URLs based on tenant information, and manage JWT token-based authentication
// with cookie support.
package isp

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/url"
        "os"
        "strings"

        "github.com/cyberark/ark-sdk-golang/pkg/auth"
        "github.com/cyberark/ark-sdk-golang/pkg/common"
        commonmodels "github.com/cyberark/ark-sdk-golang/pkg/models/common"
        "github.com/golang-jwt/jwt/v5"
        cookiejar "github.com/juju/persistent-cookiejar"
)

// ArkISPServiceClient is a struct that represents a client for the Ark ISP service.
//
// This client extends the common ArkClient with ISP-specific functionality including
// tenant environment management and JWT token parsing for service URL resolution.
// It handles authentication headers, cookies, and maintains connection state for
// ISP-based services.
type ArkISPServiceClient struct {
        *common.ArkClient
        tenantEnv commonmodels.AwsEnv
}

// NewArkISPServiceClient creates a new instance of ArkISPServiceClient.
//
// This function initializes a new ISP service client with the provided configuration.
// It resolves the service URL based on the tenant information and JWT token, sets up
// the underlying ArkClient with appropriate headers, and configures authentication.
// If tenantEnv is empty, it attempts to resolve it from environment variables or
// defaults to production.
//
// Parameters:
//   - serviceName: The name of the service to connect to (e.g., "api", "portal")
//   - tenantSubdomain: The tenant subdomain to use for URL construction
//   - baseTenantURL: The base tenant URL to use if subdomain resolution fails
//   - tenantEnv: The AWS environment (dev, staging, prod) - uses DEPLOY_ENV if empty
//   - token: The JWT authentication token for the service
//   - authHeaderName: The name of the authorization header (typically "Authorization")
//   - separator: The separator character used between tenant and service name in URLs
//   - basePath: Additional base path to append to the service URL
//   - cookieJar: The cookie jar for maintaining session state
//   - refreshConnectionCallback: Callback function to refresh the connection when needed
//
// Returns a configured ArkISPServiceClient instance and any error that occurred during
// initialization, particularly from URL parsing or service URL resolution.
//
// Example:
//
//        client, err := NewArkISPServiceClient(
//            "api",
//            "mytenant",
//            "https://mytenant.cyberark.cloud",
//            commonmodels.Prod,
//            jwtToken,
//            "Authorization",
//            "-",
//            "v1",
//            cookieJar,
//            refreshCallback,
//        )
func NewArkISPServiceClient(
        serviceName string,
        tenantSubdomain string,
        baseTenantURL string,
        tenantEnv commonmodels.AwsEnv,
        token string,
        authHeaderName string,
        separator string,
        basePath string,
        cookieJar *cookiejar.Jar,
        refreshConnectionCallback func(*common.ArkClient) error,
) (*ArkISPServiceClient, error) <span class="cov7" title="7">{
        if tenantEnv == "" </span><span class="cov1" title="1">{
                tenantEnv = commonmodels.AwsEnv(os.Getenv("DEPLOY_ENV"))
                if tenantEnv == "" </span><span class="cov1" title="1">{
                        tenantEnv = commonmodels.Prod
                }</span>
        }

        <span class="cov7" title="7">serviceURL, err := resolveServiceURL(serviceName, tenantSubdomain, baseTenantURL, tenantEnv, token, separator)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov6" title="5">if basePath != "" </span><span class="cov5" title="4">{
                serviceURL = fmt.Sprintf("%s/%s", serviceURL, basePath)
        }</span>
        <span class="cov6" title="5">parsedURL, err := url.Parse(serviceURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse service URL: %w", err)
        }</span>
        <span class="cov6" title="5">client := common.NewArkClient(serviceURL, token, "Bearer", authHeaderName, cookieJar, refreshConnectionCallback)
        client.SetHeader("Origin", fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host))
        client.SetHeader("Referer", fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host))
        client.SetHeader("Content-Type", "application/json")
        client.SetHeader("Accept", "*/*")
        client.SetHeader("Connection", "keep-alive")

        return &amp;ArkISPServiceClient{
                ArkClient: client,
                tenantEnv: tenantEnv,
        }, nil</span>
}

// resolveServiceURL resolves the complete service URL based on tenant and service information.
//
// This internal function constructs the full service URL by analyzing the JWT token,
// extracting tenant subdomain information, and resolving the appropriate platform domain.
// It supports multiple methods of subdomain resolution: from JWT token claims, explicit
// subdomain parameter, base tenant URL parsing, and unique_name claim extraction.
//
// Parameters:
//   - serviceName: The name of the service to connect to
//   - tenantSubdomain: Explicit tenant subdomain (used if JWT parsing fails)
//   - baseTenantURL: Base tenant URL for subdomain extraction as fallback
//   - tenantEnv: The AWS environment, resolved from token or environment if empty
//   - token: JWT token containing tenant and platform information
//   - separator: Separator character for URL construction between tenant and service
//
// Returns the resolved service URL string and any error that occurred during JWT parsing
// or URL construction. Returns an error if tenant subdomain cannot be resolved through
// any available method.
func resolveServiceURL(
        serviceName string,
        tenantSubdomain string,
        baseTenantURL string,
        tenantEnv commonmodels.AwsEnv,
        token string,
        separator string,
) (string, error) <span class="cov10" title="16">{
        if tenantEnv == "" </span><span class="cov4" title="3">{
                tenantEnv = commonmodels.AwsEnv(os.Getenv("DEPLOY_ENV"))
                if tenantEnv == "" </span><span class="cov4" title="3">{
                        tenantEnv = commonmodels.Prod
                }</span>
        }

        <span class="cov10" title="16">platformDomain := commonmodels.RootDomain[tenantEnv]
        var tenantChosenSubdomain string

        if token != "" </span><span class="cov10" title="16">{
                parsedToken, _, err := new(jwt.Parser).ParseUnverified(token, jwt.MapClaims{})
                if err != nil </span><span class="cov4" title="3">{
                        return "", err
                }</span>
                <span class="cov9" title="13">claims := parsedToken.Claims.(jwt.MapClaims)
                if subdomain, ok := claims["subdomain"].(string); ok </span><span class="cov8" title="9">{
                        tenantChosenSubdomain = subdomain
                }</span>
                <span class="cov9" title="13">if platformTokenDomain, ok := claims["platform_domain"].(string); ok </span><span class="cov5" title="4">{
                        platformDomain = platformTokenDomain
                        if strings.HasPrefix(platformDomain, "shell.") &amp;&amp; serviceName != "" </span><span class="cov1" title="1">{
                                platformDomain = strings.TrimPrefix(platformDomain, "shell.")
                        }</span>
                        <span class="cov5" title="4">for env, domain := range commonmodels.RootDomain </span><span class="cov6" title="6">{
                                if domain == platformDomain </span><span class="cov4" title="3">{
                                        tenantEnv = env
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov9" title="13">if tenantChosenSubdomain == "" &amp;&amp; tenantSubdomain != "" </span><span class="cov1" title="1">{
                tenantChosenSubdomain = tenantSubdomain
        }</span>

        <span class="cov9" title="13">if tenantChosenSubdomain == "" &amp;&amp; baseTenantURL != "" </span><span class="cov1" title="1">{
                if !strings.HasPrefix(baseTenantURL, "https://") </span><span class="cov0" title="0">{
                        baseTenantURL = "https://" + baseTenantURL
                }</span>
                <span class="cov1" title="1">parsedURL, err := url.Parse(baseTenantURL)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov1" title="1">tenantChosenSubdomain = strings.Split(parsedURL.Host, ".")[0]</span>
        }

        <span class="cov9" title="13">if tenantChosenSubdomain == "" </span><span class="cov3" title="2">{
                parsedToken, _, err := new(jwt.Parser).ParseUnverified(token, jwt.MapClaims{})
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov3" title="2">claims := parsedToken.Claims.(jwt.MapClaims)
                if uniqueName, ok := claims["unique_name"].(string); ok </span><span class="cov1" title="1">{
                        fullDomain := strings.Split(uniqueName, "@")
                        if len(fullDomain) &gt; 1 </span><span class="cov1" title="1">{
                                domainPart := fullDomain[1]
                                for env, domain := range commonmodels.RootDomain </span><span class="cov3" title="2">{
                                        if strings.Contains(domainPart, domain) </span><span class="cov1" title="1">{
                                                tenantChosenSubdomain = strings.Split(domainPart, ".")[0]
                                                platformDomain = domain
                                                tenantEnv = env
                                                break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov9" title="13">if tenantChosenSubdomain == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to resolve tenant subdomain")
        }</span>

        <span class="cov9" title="12">var baseURL string
        if serviceName != "" </span><span class="cov8" title="11">{
                baseURL = fmt.Sprintf("https://%s%s%s.%s", tenantChosenSubdomain, separator, serviceName, platformDomain)
        }</span> else<span class="cov1" title="1"> {
                baseURL = fmt.Sprintf("https://%s.%s", tenantChosenSubdomain, platformDomain)
        }</span>

        <span class="cov9" title="12">return baseURL, nil</span>
}

// TenantEnv returns the tenant environment of the ArkISPServiceClient.
//
// This method provides access to the AWS environment (dev, staging, prod) that was
// resolved during client initialization. The environment is determined from the JWT
// token, explicit parameter, or environment variables during client creation.
//
// Returns the commonmodels.AwsEnv value representing the current tenant environment.
//
// Example:
//
//        env := client.TenantEnv()
//        if env == commonmodels.Prod {
//            // Handle production environment logic
//        }
func (client *ArkISPServiceClient) TenantEnv() commonmodels.AwsEnv <span class="cov5" title="4">{
        return client.tenantEnv
}</span>

// TenantID returns the tenant ID from the JWT token of the ArkISPServiceClient.
//
// This method extracts the tenant ID from the JWT token claims stored in the client.
// It parses the token without verification to access the tenant_id claim. The method
// requires a valid JWT token to be present in the client.
//
// Returns the tenant ID as a string and any error that occurred during JWT token
// parsing. Returns an error if no token is available or if the token cannot be parsed.
// Note: This method performs type assertion on the tenant_id claim and may panic if
// the claim is not a string type.
//
// Example:
//
//        tenantID, err := client.TenantID()
//        if err != nil {
//            log.Printf("Failed to get tenant ID: %v", err)
//            return
//        }
//        fmt.Printf("Current tenant: %s", tenantID)
func (client *ArkISPServiceClient) TenantID() (string, error) <span class="cov1" title="1">{
        if client.ArkClient.GetToken() != "" </span><span class="cov0" title="0">{
                parsedToken, _, err := new(jwt.Parser).ParseUnverified(client.ArkClient.GetToken(), jwt.MapClaims{})
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">claims := parsedToken.Claims.(jwt.MapClaims)
                return claims["tenant_id"].(string), nil</span>
        }
        <span class="cov1" title="1">return "", fmt.Errorf("failed to retrieve tenant id")</span>
}

// FromISPAuth creates a new ArkISPServiceClient from an ArkISPAuth instance.
//
// This function creates an ISP service client using authentication information from
// an existing ArkISPAuth instance. It extracts tenant environment information from
// the auth token's username or metadata, decodes and sets up cookies from the token
// metadata, and initializes the client with the appropriate configuration.
//
// Parameters:
//   - ispAuth: The ArkISPAuth instance containing authentication information and tokens
//   - serviceName: The name of the service to connect to
//   - separator: The separator character used in URL construction
//   - basePath: Additional base path to append to the service URL
//   - refreshConnectionCallback: Callback function for connection refresh operations
//
// Returns a configured ArkISPServiceClient and any error that occurred during client
// creation, cookie unmarshaling, or service URL resolution.
//
// Example:
//
//        client, err := FromISPAuth(
//            ispAuth,
//            "api",
//            "-",
//            "v1",
//            refreshCallback,
//        )
//        if err != nil {
//            return fmt.Errorf("failed to create client: %w", err)
//        }
func FromISPAuth(ispAuth *auth.ArkISPAuth, serviceName string, separator string, basePath string, refreshConnectionCallback func(*common.ArkClient) error) (*ArkISPServiceClient, error) <span class="cov3" title="2">{
        var tenantEnv commonmodels.AwsEnv
        var baseTenantURL string
        if ispAuth.Token.Username != "" </span><span class="cov3" title="2">{
                for env, domain := range commonmodels.RootDomain </span><span class="cov3" title="2">{
                        if strings.Contains(ispAuth.Token.Username, domain) &amp;&amp; strings.Contains(ispAuth.Token.Username, "@") </span><span class="cov3" title="2">{
                                baseTenantURL = strings.Split(ispAuth.Token.Username, "@")[1]
                                tenantEnv = env
                                break</span>
                        }
                }
        }
        <span class="cov3" title="2">if tenantEnv == "" &amp;&amp; ispAuth.Token.Metadata["env"] != "" </span><span class="cov0" title="0">{
                tenantEnv = commonmodels.AwsEnv(ispAuth.Token.Metadata["env"].(string))
        }</span>
        <span class="cov3" title="2">if tenantEnv == "" </span><span class="cov0" title="0">{
                tenantEnv = commonmodels.AwsEnv(os.Getenv("DEPLOY_ENV"))
                if tenantEnv == "" </span><span class="cov0" title="0">{
                        tenantEnv = commonmodels.Prod
                }</span>
        }
        <span class="cov3" title="2">cookieJar, _ := cookiejar.New(nil)
        if cookies, ok := ispAuth.Token.Metadata["cookies"]; ok </span><span class="cov0" title="0">{
                decoded, _ := base64.StdEncoding.DecodeString(cookies.(string))
                err := common.UnmarshalCookies(decoded, cookieJar)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov3" title="2">return NewArkISPServiceClient(serviceName, "", baseTenantURL, tenantEnv, ispAuth.Token.Token, "Authorization", separator, basePath, cookieJar, refreshConnectionCallback)</span>
}

// RefreshClient refreshes the ArkISPServiceClient with the latest authentication token and cookies.
//
// This function updates an existing ArkClient with fresh authentication credentials
// by loading the latest authentication token from the provided ArkISPAuth instance.
// It updates both the authentication token and any associated cookies stored in the
// token metadata. The cookies are base64 decoded and applied to the client.
//
// Parameters:
//   - client: The ArkClient instance to refresh with new credentials
//   - ispAuth: The ArkISPAuth instance to load fresh authentication from
//
// Returns any error that occurred during authentication loading, token updating,
// or cookie processing. The function performs forced authentication refresh by
// passing true as the refresh parameter to LoadAuthentication.
//
// Example:
//
//        err := RefreshClient(client.ArkClient, ispAuth)
//        if err != nil {
//            return fmt.Errorf("failed to refresh client: %w", err)
//        }
func RefreshClient(client *common.ArkClient, ispAuth *auth.ArkISPAuth) error <span class="cov0" title="0">{
        token, err := ispAuth.LoadAuthentication(ispAuth.ActiveProfile, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if token != nil </span><span class="cov0" title="0">{
                client.UpdateToken(token.Token, client.GetTokenType())
                cookieJar := make(map[string]string)
                if cookies, ok := token.Metadata["cookies"]; ok </span><span class="cov0" title="0">{
                        decoded, _ := base64.StdEncoding.DecodeString(cookies.(string))
                        _ = json.Unmarshal(decoded, &amp;cookieJar)
                }</span>
                <span class="cov0" title="0">client.UpdateCookies(cookieJar)</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package models provides data structures and types for the ARK SDK.
// This package contains profile and configuration models used to represent
// various ARK SDK entities and their properties for authentication and
// configuration management.
package models

import (
        "encoding/json"

        "github.com/cyberark/ark-sdk-golang/pkg/models/auth"
)

// ArkProfile represents a profile configuration for the ARK SDK.
// This structure contains the essential information needed to define a profile
// including its name, description, and associated authentication profiles.
// It supports JSON marshaling/unmarshaling with custom handling for auth profiles
// to ensure proper type safety during deserialization.
//
// The struct fields include validation tags, mapstructure tags for configuration
// mapping, and flag tags for command-line interface integration.
//
// Example usage:
//
//        profile := &amp;ArkProfile{
//                ProfileName:        "my-profile",
//                ProfileDescription: "Development environment profile",
//                AuthProfiles:       make(map[string]*auth.ArkAuthProfile),
//        }
type ArkProfile struct {
        ProfileName        string                          `json:"profile_name" mapstructure:"profile_name" validate:"required" flag:"profile-name" desc:"The name of the profile to use"`
        ProfileDescription string                          `json:"profile_description" mapstructure:"profile_description" validate:"required" flag:"profile-description" desc:"Profile Description"`
        AuthProfiles       map[string]*auth.ArkAuthProfile `json:"auth_profiles" mapstructure:"auth_profile" validate:"required" flag:"-"`
}

// UnmarshalJSON implements the json.Unmarshaler interface for ArkProfile.
// It performs custom JSON unmarshaling to properly handle the AuthProfiles field
// which contains a map of authentication profiles that need special type handling.
//
// The method uses an auxiliary struct with json.RawMessage to defer the unmarshaling
// of individual auth profiles, allowing for proper type conversion from the raw
// JSON data to the specific ArkAuthProfile type.
//
// Parameters:
//   - data: JSON byte data containing the profile information to unmarshal
//
// Returns:
//   - error: nil if unmarshaling succeeds, otherwise an error describing the failure
//
// Example JSON input:
//
//        {
//                "profile_name": "my-profile",
//                "profile_description": "Development profile",
//                "auth_profiles": {
//                        "default": {
//                                "auth_type": "service_user",
//                                "username": "user@example.com"
//                        }
//                }
//        }
func (p *ArkProfile) UnmarshalJSON(data []byte) error <span class="cov10" title="12">{
        type Alias ArkProfile
        aux := &amp;struct {
                AuthProfiles map[string]json.RawMessage `json:"auth_profiles"`
                *Alias
        }{
                Alias: (*Alias)(p),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="12">p.AuthProfiles = make(map[string]*auth.ArkAuthProfile)
        for key, rawMessage := range aux.AuthProfiles </span><span class="cov9" title="10">{
                var authProfile auth.ArkAuthProfile
                if err := json.Unmarshal(rawMessage, &amp;authProfile); err != nil </span><span class="cov4" title="3">{
                        return err
                }</span>
                <span class="cov8" title="7">p.AuthProfiles[key] = &amp;authProfile</span>
        }

        <span class="cov8" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package auth

import (
        "encoding/json"
        "fmt"
)

// ArkAuthProfile represents the authentication profile for Ark SIA.
type ArkAuthProfile struct {
        Username           string                `json:"username" mapstructure:"username" flag:"username" desc:"Username"`
        AuthMethod         ArkAuthMethod         `json:"auth_method" mapstructure:"auth_method" flag:"-"`
        AuthMethodSettings ArkAuthMethodSettings `json:"auth_method_settings" mapstructure:"auth_method_settings" flag:"-"`
}

// UnmarshalJSON unmarshals the JSON data into the ArkAuthProfile struct.
func (a *ArkAuthProfile) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias ArkAuthProfile
        aux := &amp;struct {
                AuthMethodSettings json.RawMessage `json:"auth_method_settings"`
                *Alias
        }{
                Alias: (*Alias)(a),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var settings ArkAuthMethodSettings
        switch a.AuthMethod </span>{
        case Identity:<span class="cov0" title="0">
                settings = &amp;IdentityArkAuthMethodSettings{}</span>
        case IdentityServiceUser:<span class="cov0" title="0">
                settings = &amp;IdentityServiceUserArkAuthMethodSettings{}</span>
        case Direct:<span class="cov0" title="0">
                settings = &amp;DirectArkAuthMethodSettings{}</span>
        case Default:<span class="cov0" title="0">
                settings = &amp;DefaultArkAuthMethodSettings{}</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown auth method: %s", a.AuthMethod)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal(aux.AuthMethodSettings, settings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">a.AuthMethodSettings = settings
        return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package common provides common models and utilities for AWS environment management
// and configuration handling within the ARK SDK. This package contains environment
// type definitions, environment detection utilities, and mapping configurations
// for different AWS environments including production and government cloud deployments.
package common

import (
        "os"
        "regexp"
        "strings"
)

// AwsEnv represents the AWS environment type used throughout the ARK SDK.
//
// This type is used to distinguish between different AWS deployment environments
// such as production and government cloud environments. It provides type safety
// when working with environment-specific configurations and mappings.
type AwsEnv string

// Supported AWS environments for ARK SDK deployments.
//
// These constants define the available AWS environments that the ARK SDK
// can operate within. Each environment has specific configurations and
// endpoint mappings defined in the associated maps below.
const (
        // Prod represents the standard AWS production environment.
        Prod AwsEnv = "prod"
        // GovProd represents the AWS GovCloud production environment.
        GovProd AwsEnv = "gov-prod"
)

// Environment variable and tenant configuration constants.
//
// These constants define the standard environment variables and default
// values used for environment detection and tenant configuration across
// different AWS environments.
const (
        // DeployEnv is the environment variable name used to determine the current deployment environment.
        DeployEnv = "DEPLOY_ENV"
        // IdentityTenantName is the default tenant name used for identity services.
        IdentityTenantName = "isp"
)

// RootDomain maps AWS environments to their respective root domain names.
//
// This mapping provides the base domain for each AWS environment, which is used
// to construct various service endpoints and URLs throughout the ARK SDK.
// The root domains differ between standard AWS and GovCloud environments.
var RootDomain = map[AwsEnv]string{
        Prod:    "cyberark.cloud",
        GovProd: "cyberarkgov.cloud",
}

// IdentityEnvUrls maps AWS environments to their respective identity service URLs.
//
// This mapping provides the identity service endpoints for each AWS environment.
// These URLs are used for authentication and identity management operations
// and vary between standard AWS and GovCloud deployments.
var IdentityEnvUrls = map[AwsEnv]string{
        Prod:    "idaptive.app",
        GovProd: "id.cyberarkgov.cloud",
}

// IdentityTenantNames maps AWS environments to their respective identity tenant names.
//
// This mapping provides the default tenant names used for identity services
// in each AWS environment. Currently, both environments use the same default
// tenant name, but this mapping allows for environment-specific customization.
var IdentityTenantNames = map[AwsEnv]string{
        Prod:    IdentityTenantName,
        GovProd: IdentityTenantName,
}

// IdentityGeneratedSuffixPattern maps AWS environments to their respective regex patterns.
//
// These patterns are used to validate and identify auto-generated identity suffixes
// for each AWS environment. The patterns help distinguish between different
// environment-specific tenant naming conventions and ensure proper tenant routing.
var IdentityGeneratedSuffixPattern = map[AwsEnv]string{
        Prod:    `cyberark\.cloud\.\d.*`,
        GovProd: `cyberarkgov\.cloud\.\d.*`,
}

// GetDeployEnv returns the current AWS environment based on the DEPLOY_ENV environment variable.
//
// This function reads the DEPLOY_ENV environment variable to determine the current
// deployment environment. If the environment variable is not set or is empty,
// it defaults to the production environment for backward compatibility.
//
// Returns the AwsEnv corresponding to the current deployment environment.
//
// Example:
//
//        // Set environment variable
//        os.Setenv("DEPLOY_ENV", "gov-prod")
//        env := GetDeployEnv()
//        if env == GovProd {
//            // Handle GovCloud-specific logic
//        }
//
//        // Default behavior when not set
//        os.Unsetenv("DEPLOY_ENV")
//        env = GetDeployEnv() // Returns Prod
func GetDeployEnv() AwsEnv <span class="cov7" title="4">{
        deployEnv := os.Getenv(DeployEnv)
        if deployEnv == "" </span><span class="cov1" title="1">{
                return Prod
        }</span>
        <span class="cov6" title="3">return AwsEnv(deployEnv)</span>
}

// CheckIfIdentityGeneratedSuffix validates if a tenant suffix matches the environment-specific pattern.
//
// This function checks whether the provided tenant suffix matches the expected
// pattern for auto-generated identity suffixes in the specified AWS environment.
// It uses regex patterns defined in IdentityGeneratedSuffixPattern to perform
// the validation, helping to ensure proper tenant routing and identification.
//
// Parameters:
//   - tenantSuffix: The tenant suffix string to validate against the pattern
//   - env: The AWS environment to check the pattern against
//
// Returns true if the tenant suffix matches the environment's pattern, false otherwise.
// Returns false if the environment is not recognized or the pattern match fails.
//
// Example:
//
//        // Check production environment suffix
//        isValid := CheckIfIdentityGeneratedSuffix("cyberark.cloud.123", Prod)
//        if isValid {
//            // Handle auto-generated tenant
//        }
//
//        // Check GovCloud environment suffix
//        isValid = CheckIfIdentityGeneratedSuffix("cyberarkgov.cloud.456", GovProd)
func CheckIfIdentityGeneratedSuffix(tenantSuffix string, env AwsEnv) bool <span class="cov8" title="5">{
        pattern, exists := IdentityGeneratedSuffixPattern[env]
        if !exists </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov7" title="4">matched, _ := regexp.MatchString(pattern, tenantSuffix)
        return matched</span>
}

// IsGovCloud determines if the current AWS region is a government cloud region.
//
// This function checks the AWS region environment variables to determine if the
// current deployment is running in an AWS GovCloud region. It first checks the
// AWS_REGION environment variable, and if that's not set, falls back to checking
// AWS_DEFAULT_REGION. GovCloud regions are identified by the "us-gov" prefix.
//
// Returns true if the current region is a GovCloud region, false otherwise.
// Returns false if no region environment variables are set.
//
// Example:
//
//        // Set GovCloud region
//        os.Setenv("AWS_REGION", "us-gov-west-1")
//        if IsGovCloud() {
//            // Configure for GovCloud deployment
//            env := GovProd
//        }
//
//        // Standard AWS region
//        os.Setenv("AWS_REGION", "us-east-1")
//        if !IsGovCloud() {
//            // Configure for standard AWS deployment
//            env := Prod
//        }
func IsGovCloud() bool <span class="cov10" title="7">{
        regionName := os.Getenv("AWS_REGION")
        if regionName == "" </span><span class="cov7" title="4">{
                regionName = os.Getenv("AWS_DEFAULT_REGION")
        }</span>
        <span class="cov10" title="7">return strings.HasPrefix(regionName, "us-gov")</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package common provides common data models and utilities for the ARK SDK.
// This package contains shared data types and helper functions that are used
// across different components of the ARK SDK for consistent data handling.
package common

import (
        "encoding/json"
        "time"
)

// ArkRFC3339Time is a custom time type that represents a time in RFC 3339 format.
// This type provides JSON marshaling and unmarshaling capabilities for time values
// that need to be serialized in RFC 3339 format with microsecond precision.
// It wraps the standard time.Time type and implements the json.Marshaler and
// json.Unmarshaler interfaces for proper JSON handling.
//
// Example usage:
//
//        var arkTime ArkRFC3339Time
//        err := json.Unmarshal([]byte(`"2023-01-01T12:00:00.123456Z"`), &amp;arkTime)
//        if err != nil {
//                // handle error
//        }
type ArkRFC3339Time time.Time

// customTimeFormat defines the RFC 3339 time format with microsecond precision
// used for JSON marshaling and unmarshaling operations.
// Format: "2006-01-02T15:04:05.999999Z07:00"
const customTimeFormat = "2006-01-02T15:04:05.999999Z07:00"

// UnmarshalJSON implements the json.Unmarshaler interface for ArkRFC3339Time.
// It parses JSON data containing a time string in RFC 3339 format with microsecond
// precision and converts it to an ArkRFC3339Time value.
//
// The method handles both quoted and unquoted JSON strings, automatically removing
// surrounding quotes if present. It uses the customTimeFormat constant to parse
// the time string with the expected RFC 3339 format.
//
// Parameters:
//   - data: JSON byte data containing the time string to parse
//
// Returns:
//   - error: nil if parsing succeeds, otherwise an error describing the parse failure
//
// Example JSON input: "2023-01-01T12:00:00.123456Z"
func (ct *ArkRFC3339Time) UnmarshalJSON(data []byte) error <span class="cov10" title="22">{
        str := string(data)
        if str[0] == '"' &amp;&amp; str[len(str)-1] == '"' </span><span class="cov9" title="18">{
                str = str[1 : len(str)-1]
        }</span>
        <span class="cov10" title="22">t, err := time.Parse(customTimeFormat, str)
        if err != nil </span><span class="cov7" title="8">{
                return err
        }</span>
        <span class="cov8" title="14">*ct = ArkRFC3339Time(t)
        return nil</span>
}

// MarshalJSON implements the json.Marshaler interface for ArkRFC3339Time.
// It converts an ArkRFC3339Time value to JSON format by formatting the underlying
// time value as an RFC 3339 string with microsecond precision.
//
// The method formats the time using the customTimeFormat constant and returns
// the result as a JSON-encoded string value.
//
// Returns:
//   - []byte: JSON-encoded byte array containing the formatted time string
//   - error: nil if marshaling succeeds, otherwise an error from json.Marshal
//
// Example output: "2023-01-01T12:00:00.123456Z"
func (ct *ArkRFC3339Time) MarshalJSON() ([]byte, error) <span class="cov8" title="14">{
        timeStr := time.Time(*ct).Format(customTimeFormat)
        return json.Marshal(timeStr)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package identity provides data structures and types for ARK Identity directory services.
// This package contains models for directory service metadata, query requests and responses,
// and data structures for users, groups, and roles within the ARK Identity system.
// It supports various directory types including Active Directory, Identity (CDS), and FDS.
package identity

import (
        "encoding/json"
)

// Directory type constants represent the supported directory service types.
const (
        // AD represents Active Directory Proxy directory type.
        AD = "AdProxy"
        // Identity represents CDS (Centrify Directory Service) directory type.
        Identity = "CDS"
        // FDS represents FDS (Federated Directory Service) directory type.
        FDS = "FDS"
)

// AllDirectoryTypes contains all supported directory service types.
// This slice includes AD, Identity, and FDS directory types for validation
// and enumeration purposes.
var (
        AllDirectoryTypes = []string{
                AD,
                Identity,
                FDS,
        }
)

// DirectoryServiceMetadata represents metadata information for a directory service.
// This structure contains essential identification information for directory services
// including the service type and unique identifier used for directory operations.
type DirectoryServiceMetadata struct {
        Service              string `json:"Service" mapstructure:"Service"`
        DirectoryServiceUUID string `json:"directoryServiceUuid" mapstructure:"directoryServiceUuid"`
}

// DirectoryServiceRow represents a single row of directory service metadata.
// This structure wraps DirectoryServiceMetadata to match the expected JSON
// structure returned by directory service queries.
type DirectoryServiceRow struct {
        Row DirectoryServiceMetadata `json:"Row" mapstructure:"Row"`
}

// GetDirectoryServicesResult represents the collection of directory services results.
// This structure contains an array of directory service rows returned from
// directory service enumeration queries with validation requiring at least one result.
type GetDirectoryServicesResult struct {
        Results []DirectoryServiceRow `json:"Results" mapstructure:"Results" validate:"min=1"`
}

// GetDirectoryServicesResponse represents the complete response for directory services queries.
// This structure wraps the directory services results in the expected API response format.
type GetDirectoryServicesResponse struct {
        Result GetDirectoryServicesResult `json:"Result" mapstructure:"Result"`
}

// DirectorySearchArgs represents search and pagination arguments for directory queries.
// This structure contains parameters for controlling query behavior including
// pagination, sorting, caching, and result ordering options.
type DirectorySearchArgs struct {
        PageNumber int    `json:"PageNumber,omitempty" mapstructure:"PageNumber,omitempty"`
        PageSize   int    `json:"PageSize,omitempty" mapstructure:"PageSize,omitempty"`
        Limit      int    `json:"Limit,omitempty" mapstructure:"Limit,omitempty"`
        SortBy     string `json:"SortBy,omitempty" mapstructure:"SortBy,omitempty"`
        Caching    int    `json:"Caching,omitempty" mapstructure:"Caching,omitempty"`
        Dir        string `json:"Direction,omitempty" mapstructure:"Direction,omitempty"`
        Ascending  bool   `json:"Ascending,omitempty" mapstructure:"Ascending,omitempty"`
}

// DirectoryServiceQueryRequest represents a comprehensive query request for directory services.
// This structure contains filter criteria for groups, roles, and users along with
// directory service specifications and search arguments for controlling query behavior.
type DirectoryServiceQueryRequest struct {
        DirectoryServices []string            `json:"directoryServices" mapstructure:"directoryServices"`
        Group             string              `json:"group,omitempty" mapstructure:"group,omitempty"`
        Roles             string              `json:"roles,omitempty" mapstructure:"roles,omitempty"`
        User              string              `json:"user,omitempty" mapstructure:"user,omitempty"`
        Args              DirectorySearchArgs `json:"Args" mapstructure:"Args"`
}

// NewDirectoryServiceQueryRequest creates a new DirectoryServiceQueryRequest with optional search filtering.
// It initializes the request with default empty JSON objects for user, roles, and group filters.
// If a search string is provided, it creates appropriate filter criteria for searching across
// display names and system names for groups, role names, and user display names.
//
// Parameters:
//   - searchString: Optional search term to filter results across groups, roles, and users
//
// Returns:
//   - *DirectoryServiceQueryRequest: Initialized request with search filters applied if searchString provided
//
// Example:
//
//        // Create request without search filtering
//        request := NewDirectoryServiceQueryRequest("")
//
//        // Create request with search filtering
//        request := NewDirectoryServiceQueryRequest("admin")
func NewDirectoryServiceQueryRequest(searchString string) *DirectoryServiceQueryRequest <span class="cov10" title="6">{
        request := &amp;DirectoryServiceQueryRequest{}
        request.User = "{}"
        request.Roles = "{}"
        request.Group = "{}"
        if searchString != "" </span><span class="cov9" title="5">{
                groupFilter := map[string]interface{}{
                        "_or": []map[string]interface{}{
                                {"DisplayName": map[string]string{"_like": searchString}},
                                {"SystemName": map[string]string{"_like": searchString}},
                        },
                }
                rolesFilter := map[string]interface{}{
                        "Name": map[string]interface{}{
                                "_like": map[string]interface{}{
                                        "value":      searchString,
                                        "ignoreCase": true,
                                },
                        },
                }
                usersFilter := map[string]interface{}{
                        "DisplayName": map[string]string{"_like": searchString},
                }
                grp, _ := json.Marshal(groupFilter)
                roles, _ := json.Marshal(rolesFilter)
                users, _ := json.Marshal(usersFilter)
                request.Group = string(grp)
                request.Roles = string(roles)
                request.User = string(users)
        }</span>
        <span class="cov10" title="6">return request</span>
}

// DirectoryServiceQuerySpecificRoleRequest represents a query request targeting a specific role.
// This structure is similar to DirectoryServiceQueryRequest but is specialized for querying
// specific roles by exact name match rather than general search filtering.
type DirectoryServiceQuerySpecificRoleRequest struct {
        DirectoryServices []string            `json:"directoryServices" mapstructure:"directoryServices"`
        Group             string              `json:"group,omitempty" mapstructure:"group,omitempty"`
        Roles             string              `json:"roles,omitempty" mapstructure:"roles,omitempty"`
        User              string              `json:"user,omitempty" mapstructure:"user,omitempty"`
        Args              DirectorySearchArgs `json:"Args" mapstructure:"Args"`
}

// NewDirectoryServiceQuerySpecificRoleRequest creates a new DirectoryServiceQuerySpecificRoleRequest for a specific role.
// It initializes the request with default empty JSON objects and sets up an exact match
// filter for the specified role name if provided.
//
// Parameters:
//   - roleName: The exact name of the role to query for
//
// Returns:
//   - *DirectoryServiceQuerySpecificRoleRequest: Initialized request with role name filter applied if roleName provided
//
// Example:
//
//        // Create request for specific role
//        request := NewDirectoryServiceQuerySpecificRoleRequest("System Administrator")
//
//        // Create request without role filtering
//        request := NewDirectoryServiceQuerySpecificRoleRequest("")
func NewDirectoryServiceQuerySpecificRoleRequest(roleName string) *DirectoryServiceQuerySpecificRoleRequest <span class="cov10" title="6">{
        request := &amp;DirectoryServiceQuerySpecificRoleRequest{}
        request.User = "{}"
        request.Roles = "{}"
        request.Group = "{}"
        if roleName != "" </span><span class="cov9" title="5">{
                request.Roles = `{"Name":{"_eq":"` + roleName + `"}}`
        }</span>
        <span class="cov10" title="6">return request</span>
}

// GroupRow represents detailed information about a directory group.
// This structure contains group metadata including display names, service information,
// directory service type, system identifiers, and internal references.
type GroupRow struct {
        DisplayName              string `json:"DisplayName,omitempty" mapstructure:"DisplayName"`
        ServiceInstanceLocalized string `json:"ServiceInstanceLocalized" mapstructure:"ServiceInstanceLocalized"`
        DirectoryServiceType     string `json:"ServiceType" mapstructure:"ServiceType"`
        SystemName               string `json:"SystemName,omitempty" mapstructure:"SystemName"`
        InternalID               string `json:"InternalName,omitempty" mapstructure:"InternalName"`
}

// GroupResult represents a single group result from directory queries.
// This structure wraps GroupRow to match the expected JSON structure
// returned by directory service group queries.
type GroupResult struct {
        Row GroupRow `json:"Row" mapstructure:"Row"`
}

// GroupsResult represents the complete collection of group query results.
// This structure contains an array of group results along with the total
// count of matching groups for pagination purposes.
type GroupsResult struct {
        Results   []GroupResult `json:"Results" mapstructure:"Results"`
        FullCount int           `json:"FullCount,omitempty" mapstructure:"FullCount"`
}

// RoleAdminRight represents administrative rights and permissions for a role.
// This structure defines the scope and service context for role-based
// administrative privileges within the directory system.
type RoleAdminRight struct {
        Path        string `json:"Path" mapstructure:"Path"`
        ServiceName string `json:"ServiceName,omitempty" mapstructure:"ServiceName"`
}

// RoleRow represents detailed information about a directory role.
// This structure contains role metadata including name, unique identifier,
// administrative rights, visibility status, and descriptive information.
type RoleRow struct {
        Name        string           `json:"Name,omitempty" mapstructure:"Name"`
        ID          string           `json:"_ID" mapstructure:"_ID"`
        AdminRights []RoleAdminRight `json:"AdministrativeRights,omitempty" mapstructure:"AdministrativeRights"`
        IsHidden    bool             `json:"IsHidden,omitempty" mapstructure:"IsHidden"`
        Description string           `json:"Description,omitempty" mapstructure:"Description"`
}

// RoleResult represents a single role result from directory queries.
// This structure wraps RoleRow to match the expected JSON structure
// returned by directory service role queries.
type RoleResult struct {
        Row RoleRow `json:"Row" mapstructure:"Row"`
}

// RolesResult represents the complete collection of role query results.
// This structure contains an array of role results along with the total
// count of matching roles for pagination purposes.
type RolesResult struct {
        Results   []RoleResult `json:"Results" mapstructure:"Results"`
        FullCount int          `json:"FullCount,omitempty" mapstructure:"FullCount"`
}

// UserRow represents detailed information about a directory user.
// This structure contains comprehensive user metadata including display information,
// service details, distinguished name, system identifiers, contact information,
// and descriptive data.
type UserRow struct {
        DisplayName              string `json:"DisplayName,omitempty" mapstructure:"DisplayName"`
        ServiceInstanceLocalized string `json:"ServiceInstanceLocalized" mapstructure:"ServiceInstanceLocalized"`
        DistinguishedName        string `json:"DistinguishedName" mapstructure:"DistinguishedName"`
        SystemName               string `json:"SystemName,omitempty" mapstructure:"SystemName"`
        DirectoryServiceType     string `json:"ServiceType" mapstructure:"ServiceType"`
        Email                    string `json:"EMail,omitempty" mapstructure:"EMail"`
        InternalID               string `json:"InternalName,omitempty" mapstructure:"InternalName"`
        Description              string `json:"Description,omitempty" mapstructure:"Description"`
}

// UserResult represents a single user result from directory queries.
// This structure wraps UserRow to match the expected JSON structure
// returned by directory service user queries.
type UserResult struct {
        Row UserRow `json:"Row" mapstructure:"Row"`
}

// UsersResult represents the complete collection of user query results.
// This structure contains an array of user results along with the total
// count of matching users for pagination purposes.
type UsersResult struct {
        Results   []UserResult `json:"Results" mapstructure:"Results"`
        FullCount int          `json:"FullCount,omitempty" mapstructure:"FullCount"`
}

// QueryResult represents the comprehensive results from directory service queries.
// This structure aggregates results for groups, roles, and users into a single
// response object, allowing for combined query operations across all entity types.
type QueryResult struct {
        Groups *GroupsResult `json:"Group,omitempty" mapstructure:"Group"`
        Roles  *RolesResult  `json:"Roles,omitempty" mapstructure:"Roles"`
        Users  *UsersResult  `json:"User,omitempty" mapstructure:"User"`
}

// DirectoryServiceQueryResponse represents the complete response for directory service queries.
// This structure wraps the query results in the expected API response format for
// directory service operations involving groups, roles, and users.
type DirectoryServiceQueryResponse struct {
        Result QueryResult `json:"Result" mapstructure:"Result"`
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package identity provides data structures and types for ARK Identity API operations.
// This package contains models for authentication, authorization, and identity management
// operations including authentication challenges, tokens, tenant information, and
// various response structures used in ARK Identity service interactions.
package identity

import (
        "strings"
)

// BaseIdentityAPIResponse represents the common response structure from the ARK Identity API.
// This structure contains standard fields that are present in most Identity API responses
// including success status, error information, and diagnostic details for troubleshooting
// API interactions.
type BaseIdentityAPIResponse struct {
        Success   bool   `json:"Success" validate:"required"`
        Exception string `json:"Exception"`
        ErrorCode string `json:"ErrorCode"`
        Message   string `json:"Message"`
        ErrorID   string `json:"ErrorID"`
}

// PodFqdnResult represents the result containing Pod Fully Qualified Domain Name information.
// This structure contains the Pod FQDN which is used to identify the specific Identity
// service instance and extract tenant information for multi-tenant operations.
type PodFqdnResult struct {
        PodFqdn string `json:"PodFqdn" validate:"required,min=2"`
}

// GetTenantID extracts the tenant identifier from the Pod FQDN.
// It parses the PodFqdn field by splitting on the first dot character and
// returns the leftmost component, which represents the tenant ID in the
// ARK Identity service naming convention.
//
// Returns:
//   - string: The tenant ID extracted from the Pod FQDN, or empty string if PodFqdn is empty
//
// Example:
//
//        podResult := &amp;PodFqdnResult{PodFqdn: "tenant123.example.com"}
//        tenantID := podResult.GetTenantID() // Returns "tenant123"
func (p *PodFqdnResult) GetTenantID() string <span class="cov10" title="2">{
        return strings.Split(p.PodFqdn, ".")[0]
}</span>

// AdvanceAuthResult represents the result of a successful advanced authentication request.
// This structure contains authentication tokens, user information, and session details
// returned when authentication is completed successfully through the ARK Identity system.
type AdvanceAuthResult struct {
        DisplayName   string `json:"DisplayName" validate:"omitempty,min=2"`
        Auth          string `json:"Auth" validate:"required,min=2"`
        Summary       string `json:"Summary" validate:"required,min=2"`
        Token         string `json:"Token" validate:"omitempty,min=2"`
        RefreshToken  string `json:"RefreshToken" validate:"omitempty,min=2"`
        TokenLifetime int    `json:"TokenLifetime"`
        CustomerID    string `json:"CustomerID"`
        UserID        string `json:"UserId"`
        PodFqdn       string `json:"PodFqdn"`
}

// AdvanceAuthMidResult represents the result of an in-progress advanced authentication request.
// This structure contains intermediate state information when authentication is still
// being processed and polling is required to check for completion.
type AdvanceAuthMidResult struct {
        Summary            string `json:"Summary" validate:"required,min=2"`
        GeneratedAuthValue string `json:"GeneratedAuthValue"`
}

// Mechanism represents an authentication mechanism within an authentication challenge.
// This structure defines the properties and prompts for a specific authentication
// method that can be used to complete an authentication challenge in the ARK Identity system.
type Mechanism struct {
        AnswerType       string `json:"AnswerType" validate:"required,min=2"`
        Name             string `json:"Name" validate:"required,min=2"`
        PromptMechChosen string `json:"PromptMechChosen" validate:"required,min=2"`
        PromptSelectMech string `json:"PromptSelectMech" validate:"omitempty,min=2"`
        MechanismID      string `json:"MechanismId" validate:"required,min=2"`
}

// Challenge represents an authentication challenge containing available mechanisms.
// This structure groups one or more authentication mechanisms that can be used
// to satisfy an authentication requirement in the multi-factor authentication flow.
type Challenge struct {
        Mechanisms []Mechanism `json:"Mechanisms" validate:"required,dive,required"`
}

// StartAuthResult represents the result of initiating an authentication request.
// This structure contains authentication challenges, session information, and
// Identity Provider (IdP) redirect details for starting the authentication process.
type StartAuthResult struct {
        Challenges            []Challenge `json:"Challenges" validate:"omitempty,dive,required"`
        SessionID             string      `json:"SessionId" validate:"omitempty,min=2"`
        IdpRedirectURL        string      `json:"IdpRedirectUrl"`
        IdpLoginSessionID     string      `json:"IdpLoginSessionId"`
        IdpRedirectShortURL   string      `json:"IdpRedirectShortUrl"`
        IdpShortURLID         string      `json:"IdpShortUrlId"`
        IdpOobAuthPinRequired bool        `json:"IdpOobAuthPinRequired"`
        TenantID              string      `json:"TenantId"`
}

// IdpAuthStatusResult represents the result of an Identity Provider authentication status check.
// This structure contains the current state of an IdP authentication session
// along with token information when authentication is completed.
type IdpAuthStatusResult struct {
        AuthLevel     string `json:"AuthLevel"`
        DisplayName   string `json:"DisplayName"`
        Auth          string `json:"Auth"`
        UserID        string `json:"UserId"`
        State         string `json:"State"`
        TokenLifetime int    `json:"TokenLifetime"`
        Token         string `json:"Token"`
        RefreshToken  string `json:"RefreshToken"`
        EmailAddress  string `json:"EmailAddress"`
        UserDirectory string `json:"UserDirectory"`
        PodFqdn       string `json:"PodFqdn"`
        User          string `json:"User"`
        CustomerID    string `json:"CustomerID"`
        Forest        string `json:"Forest"`
        SystemID      string `json:"SystemID"`
        SourceDsType  string `json:"SourceDsType"`
        Summary       string `json:"Summary"`
}

// TenantFqdnResponse represents the complete response for tenant FQDN requests.
// This structure combines the base API response with Pod FQDN result data
// for tenant identification and service endpoint discovery operations.
type TenantFqdnResponse struct {
        BaseIdentityAPIResponse
        Result PodFqdnResult `json:"Result"`
}

// AdvanceAuthMidResponse represents the complete response for in-progress authentication requests.
// This structure combines the base API response with intermediate authentication
// state information for polling-based authentication flows.
type AdvanceAuthMidResponse struct {
        BaseIdentityAPIResponse
        Result AdvanceAuthMidResult `json:"Result"`
}

// AdvanceAuthResponse represents the complete response for successful authentication requests.
// This structure combines the base API response with authentication tokens and
// user information when authentication has been completed successfully.
type AdvanceAuthResponse struct {
        BaseIdentityAPIResponse
        Result AdvanceAuthResult `json:"Result"`
}

// StartAuthResponse represents the complete response for authentication initiation requests.
// This structure combines the base API response with authentication challenges
// and session information for starting the authentication process.
type StartAuthResponse struct {
        BaseIdentityAPIResponse
        Result StartAuthResult `json:"Result"`
}

// GetTenantSuffixResult represents the complete response for tenant suffix requests.
// This structure combines the base API response with a flexible result map
// containing tenant-specific configuration and suffix information.
type GetTenantSuffixResult struct {
        BaseIdentityAPIResponse
        Result map[string]interface{} `json:"Result"`
}

// IdpAuthStatusResponse represents the complete response for IdP authentication status requests.
// This structure combines the base API response with Identity Provider authentication
// status and token information for federated authentication flows.
type IdpAuthStatusResponse struct {
        BaseIdentityAPIResponse
        Result IdpAuthStatusResult `json:"Result"`
}

// TenantEndpointResponse represents the response containing tenant endpoint information.
// This structure provides the endpoint URL for accessing tenant-specific services
// in the ARK Identity system.
type TenantEndpointResponse struct {
        Endpoint string `json:"endpoint"`
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package profiles

import (
        "encoding/json"
        "github.com/cyberark/ark-sdk-golang/pkg/models"
        "os"
        "path/filepath"
)

// ProfileLoader is an interface that defines methods for loading, saving, and managing Ark profiles.
type ProfileLoader interface {
        LoadProfile(profileName string) (*models.ArkProfile, error)
        SaveProfile(profile *models.ArkProfile) error
        LoadAllProfiles() ([]*models.ArkProfile, error)
        LoadDefaultProfile() (*models.ArkProfile, error)
        DeleteProfile(profileName string) error
        ClearAllProfiles() error
        ProfileExists(profileName string) bool
}

// FileSystemProfilesLoader is a struct that implements the ProfileLoader interface using the file system.
type FileSystemProfilesLoader struct {
        ProfileLoader
}

// DefaultProfilesLoader returns a default implementation of the ProfileLoader interface, which is filesystem.
func DefaultProfilesLoader() *ProfileLoader <span class="cov1" title="1">{
        var profilesLoader ProfileLoader = &amp;FileSystemProfilesLoader{}
        return &amp;profilesLoader
}</span>

// GetProfilesFolder returns the folder path where Ark profiles are stored.
func GetProfilesFolder() string <span class="cov10" title="21">{
        if folder := os.Getenv("ARK_PROFILES_FOLDER"); folder != "" </span><span class="cov9" title="19">{
                return folder
        }</span>
        <span class="cov3" title="2">return filepath.Join(os.Getenv("HOME"), ".ark_profiles")</span>
}

// DefaultProfileName returns the default profile name.
func DefaultProfileName() string <span class="cov7" title="8">{
        return "ark"
}</span>

// DeduceProfileName deduces the profile name based on the provided name and environment variables.
func DeduceProfileName(profileName string) string <span class="cov7" title="8">{
        if profileName != "" &amp;&amp; profileName != DefaultProfileName() </span><span class="cov3" title="2">{
                return profileName
        }</span>
        <span class="cov6" title="6">if profile := os.Getenv("ARK_PROFILE"); profile != "" </span><span class="cov3" title="2">{
                return profile
        }</span>
        <span class="cov5" title="4">if profileName != "" </span><span class="cov1" title="1">{
                return profileName
        }</span>
        <span class="cov4" title="3">return DefaultProfileName()</span>
}

// LoadDefaultProfile loads the default profile from the file system.
func (fspl *FileSystemProfilesLoader) LoadDefaultProfile() (*models.ArkProfile, error) <span class="cov3" title="2">{
        folder := GetProfilesFolder()
        profileName := DeduceProfileName("")
        profilePath := filepath.Join(folder, profileName)
        if _, err := os.Stat(profilePath); err == nil </span><span class="cov1" title="1">{
                return fspl.LoadProfile(profileName)
        }</span>
        <span class="cov1" title="1">return &amp;models.ArkProfile{}, nil</span>
}

// LoadProfile loads a profile from the file system based on the provided profile name.
func (fspl *FileSystemProfilesLoader) LoadProfile(profileName string) (*models.ArkProfile, error) <span class="cov6" title="6">{
        folder := GetProfilesFolder()
        profilePath := filepath.Join(folder, profileName)
        if _, err := os.Stat(profilePath); err == nil </span><span class="cov5" title="5">{
                data, err := os.ReadFile(profilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="5">var profile models.ArkProfile
                if err := json.Unmarshal(data, &amp;profile); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="5">return &amp;profile, nil</span>
        }
        <span class="cov1" title="1">return nil, nil</span>
}

// SaveProfile saves a profile to the file system, will create needed folders if not already present.
func (fspl *FileSystemProfilesLoader) SaveProfile(profile *models.ArkProfile) error <span class="cov3" title="2">{
        folder := GetProfilesFolder()
        if _, err := os.Stat(folder); os.IsNotExist(err) </span><span class="cov1" title="1">{
                if err := os.MkdirAll(folder, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov3" title="2">profilePath := filepath.Join(folder, profile.ProfileName)
        data, err := json.MarshalIndent(profile, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">return os.WriteFile(profilePath, data, 0644)</span>
}

// LoadAllProfiles loads all profiles from the file system.
func (fspl *FileSystemProfilesLoader) LoadAllProfiles() ([]*models.ArkProfile, error) <span class="cov3" title="2">{
        folder := GetProfilesFolder()
        if _, err := os.Stat(folder); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">files, err := os.ReadDir(folder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var profiles []*models.ArkProfile
        for _, file := range files </span><span class="cov5" title="4">{
                if !file.IsDir() </span><span class="cov4" title="3">{
                        profile, err := fspl.LoadProfile(file.Name())
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov4" title="3">profiles = append(profiles, profile)</span>
                }
        }
        <span class="cov1" title="1">return profiles, nil</span>
}

// DeleteProfile deletes a profile from the file system.
func (fspl *FileSystemProfilesLoader) DeleteProfile(profileName string) error <span class="cov3" title="2">{
        folder := GetProfilesFolder()
        profilePath := filepath.Join(folder, profileName)
        if _, err := os.Stat(profilePath); err == nil </span><span class="cov1" title="1">{
                return os.Remove(profilePath)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// ClearAllProfiles clears all profiles from the file system.
func (fspl *FileSystemProfilesLoader) ClearAllProfiles() error <span class="cov3" title="2">{
        folder := GetProfilesFolder()
        if _, err := os.Stat(folder); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">files, err := os.ReadDir(folder)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">for _, file := range files </span><span class="cov5" title="4">{
                if !file.IsDir() </span><span class="cov4" title="3">{
                        if err := os.Remove(filepath.Join(folder, file.Name())); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov1" title="1">return nil</span>
}

// ProfileExists checks if a profile exists in the file system.
func (fspl *FileSystemProfilesLoader) ProfileExists(profileName string) bool <span class="cov3" title="2">{
        folder := GetProfilesFolder()
        profilePath := filepath.Join(folder, profileName)
        _, err := os.Stat(profilePath)
        return err == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
